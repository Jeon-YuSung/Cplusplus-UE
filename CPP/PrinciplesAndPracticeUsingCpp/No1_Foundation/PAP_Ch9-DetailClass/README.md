# 9장 언어적 세부 사항 : 클래스 

## 개요
9장에서는 클래스와 열거형(enum)을 비롯한 사용자 정의 타입에 관련된 언어적 세부 사항에 대해 알아본다. <br>
이를 바탕으로 예제 Date 타입을 점지적으로 개선하면서 클래스 설계 기법에 대해 알아보는 챕터이다. 

--------------------------------------------------------
### 9.1 사용자 정의 타입
  int, char, double, float... 이러한 자료형들은 **내장형 타입(혹은 내장형 자료형)** 이라고 하고, 내장형 타입은 개발자가 그에 대한 선언을 소스 코드에 제공하지 않아도 컴파일러 스스로 해당 객체를 어떻게 표현하고, 그 객체에 적용 가능한 연산이 무엇인지 알고 있는 타입을 뜻한다. <br>
  반대로, 내장형 타입이 아닌 모든 타입은 **사용자 정의 타입(UDT, User-Defined Type)** 이라고 하고, 모든 ISO 표준 C++ 구현체에서 사용할 수 있는 string, vector, ostream... 등 비롯한 표준 라이브러리 혹은 직접 만드는 타입들이 사용자 정의 타입이라고 한다. <br>
  표준 라이브러리 타입은 내장형 타입 처럼 언어의 구성 요소라고도 할 수 있으나, 스스로 정의하는 타입과 동일한 구성 요소와 기법으로 만들어져서 여전히 사용자 정의 타입으로 볼 수 있다. → 표준 라이브러리 개발자가 특별한 권한을 보유하거나 남들에게 제공되지 않은 기능을 사용할 수 없다는 뜻이다. 
  내장형 타입과 마찬가지로 대부분의 사용자 정의 타입은 **연산**을 제공한다.

  타입을 만드는 이유는 뭘까? 단순하다, 모든 타입을 컴파일러가 알 수 없거나 모르기 때문이다. <br>
  타입의 유용성은 뭘까?  개발자가 아이디어를 코드로 직접적으로 표현할 때이다. <br>
  정수 타입은 int, 실수 타입은 float, double 혹은 문자(텍스트)는 string이 도움이 된다. 

  1. 메모리 표현(Memory Representation) - 타입은 해당 객체에 필요한 데이터를 표현하는 방식을 알려준다.
  2. 연산(Operation) - 타입은 해당 객체에 적용할 수 있는 연산의 종류를 알려준다.

  그리고 연산의 결과는 객체의 데이터(현재 상태)에 의존한다. 

  C++의 대표적인 사용자 정의 타입으로 struct, class, enum, union이 있으며, 9장에서는 클래스와 열거형에 대해 알아본다. 

  클래스는 프로그램 안에서 특정 개념을 **직접적으로 표현**하는 사용자 정의 타입으로, 해당 타입의 객체를 표현하는 방법과 객체를 생성하는 방법, 객체를 사용하는 방법, 객체를 소멸시키는 방법을 명시한다 (정의, 생성자, 소멸자)
  
### 9.2 클래스와 멤버 
  클래스는 내장형 타입과 그 밖의 사용자 정의 타입과 함수로 이루어진 사용자 정의 타입이라고 하며, 클래스를 구성하는 일부를 **멤버**라고 지칭하고 클래스는 보통 0개 이상의 멤버로 구성 된다. 

```cpp
class X{
  public: //클래스는 구조체와 달리 기본적으로 private이기에 명시적으로 접근제어자를 설정하는게 좋다. 
    int m; //데이터 멤버
    inline int mf(int v) { //함수 멤버 
      int old = m;
      m = v;
      return old;
    }
};
```
  멤버의 종류는 다양하지만, 대부분 클래스의 객체를 표현하는 데이터 멤버이거나 해당 객체에 연산을 수행하는 함수이다. <br>
  그리고 함수 멤버에 inline 키워드를 붙였는데, 컴파일러에게 함수 호출 대신 함수 정의 코드를 직접 삽입하도록 요청하는 키워드이다. 함수 호출 오버헤드를 제거하여 실행 속도를 높이지만, 호출이 반복되면 코드 크기가 커질 수 있기 때문에, 주로 속도가 중요한 짧은 함수에 사용되는 편이다. <br>
  또한 멤버는 다음과 같이 object.member의 표기법으로 접근이 가능하다. <br>

```cpp
X var; // var는 X 클래스 타입의 변수
var.m = 7; // var의 데이터 멤버에 대입
int x;
x = var.mf(9); //var의 멤버 함수 mf() 함수를 호출
```
  멤버의 타입에 따라 그 멤버에 수행할 수 있는 연산이 정해진다. 

### 인터페이스와 구현
  일반적으로 class는 인터페이스와 구현으로 이루어진다. 인터페이스는 사용자가 직접 접근하는 클래스 선언의 일부이다. 구현은 클래스 선언 중 사용자가 인터페이스를 바탕으로 간접적으로 접근하는 부분을 뜻 한다. 공개 인터페이스는 접근 지정 제어자가 public: 이며, 구현은 private:로 구현된다. <br> 
  기본적으로 class는 **접근 제어 지정자가 private**이기 때문에, 사용자가 비공개 멤버에 바로 접근할 수 없고, 사용자가 접근할 수 있는 공개 함수를 거쳐 호출해야 가능하다. <br>
  private와 public를 이용해서 인터페이스와 상세 구현 사이의 중요한 구분이 가능해진다. <br>
  그리고 **구조체 struct는 기본적으로 public으로 직접 접근이 가능**하다. 그렇기 때문에, 주로 멤버가 어떤 값이든 가질 수 있는 자료구조, 즉 유의미한 불변 규칙(Invariant)을 정의할 수 없는 경우에 사용한다. 

--------------------------------------------------------------------------

### 클래스로의 진화 
  여기서는 Date 예제를 통해 간단한 자료 구조를 비공개 상세 구현과 유용한 연산을 포함하는 클래스로 개선하는 방법을 알아보자. 

##### struct와 함수
```cpp
strcut Date{
  int y;
  int m;
  int d;
};

int main(void){
  Date today;

  today.y = 2025;
  today.m = 11;
  today.d = 19;

  return 0;
}
```
  위의 코드를 봐라, 단순해보이지만, 논리적 오류가 있다. <br>

```
  Date t;

  t.y = -25;
  t.m = 13;
  t.d = 37;
```

  이럴 경우는? 혹은 윤년이 있는 경우는? 문법 오류은 없을지라도, 문제가 있는건 확실하다. <br>
  이렇기 때문에, 일반적인 연산을 하는 헬퍼 함수(Helper Function)가 필요하다. 이를 통해 같은 코드를 계속 반복하거나, 같은 실수를 반복해서 저지르고 찾아내고, 수정하는 행동을 줄일 수 있다. 
  거의 모든 타입에서 초기화와 대입은 가장 일반적인 연산중 하나이다. 

```cpp
void initDay(Date& dd, int y, int m, int d){

  // parameter y, m, d가 유효한 날짜인지 확인하고, dd를 주어진 날짜로 초기화 해준다. 
}

void addDay(Date& dd, int n){
  //dd룰 n일 증가해준다. 
}

void f(){
  Date today;
  initDay(today, 11,19,2025);
  addDay(today, 1);
}
```
  헬퍼 함수를 통해 연산의 유용함을 알 수 있다, 근데 뭔가 이상하지 않는가? 2025일은 없는 숫자이다. 날짜의 유효성을 확인하지 않기 때문에 이처럼 버그가 생길 수 있다. <br>
  또한, 타입을 정의할 때 연산이 필요하며, 필요한 연산는 그때마다 다르다, 그러니 타입을 정의할 때, 어떤 연산이 필요하는가?를 고민하면서 작성하는 것이 좋다.
  
##### 멤버 함수와 생성자 
위에서 Date의 초기화 함수를 작성하고, 그 함수의 유효성을 확인하는 기능도 제공 했지만, 확인 함수를 사용하지 않으면 아무 쓸모가 없다. 

```cpp
void f(){
  Date today;
  //...
  cout << today << endl; // today 사용
  //...
  initDay(today, 2025, 11,22);
  //..
  Date tomorrow;

  tomorrow.y = today.y;
  tomorrow.m = today.m;
  tomorrow.d = today.d + 1;
  cout << tomorrow << endl;
}
```

생성 즉시 today를 초기하는 걸 깜빡했고, initDay함수를 호출하기 전에 today를 사용했다. 그리고 addDay가 있으나, tomorrow를 직접 생성해서 사용했다. 이런 코드는 나쁜 코드인데, 수정을 살짝만해도 심각한 오류가 발생할 수 있다. 예를 들어 Date를 초기화하지 않고, 출력시 쓰레기 값이 나오고, 멤버 변수 d에 +1 하는 방식으로 구현 하면 월의 마지막인 경우 유효하지 않은 날짜가 나올 수 도 있다. <br>
그러니, 함수를 클래스 몸체 안에 멤버로 선언하는 멤버 함수를 사용 해보자. 

```cpp
// 생성자로 초기화
strcut Date{
  int y;
  int m;
  int d;
  Date(int y, int m, int d); // 날짜의 유효성 확인후 초기화
  void addDay(int n); // Date객체에 n 일을 더하는 함수
};

//초기화 하는 예시
Date Last {2025,12,31};
Date Next = {2025,11,23};
Date Christmas = Date{2025,12,25};
```
해당 클래스와 이름이 같은 특수한 함수를 **생성자**라고하고, 해당 클래스의 객체를 초기화할 때 사용한다. Argument를 요구하는 생성자를 포함하는 클래스의 객체를 명시적으로 초기화하지 않으면 컴파일러가 오류 낼 수 있다. <br>

##### private를 사용하는 이유 
멤버함수인 addDay함수를 사용하지 않으면 어찌 될까?  혹은 Month를 직접 바꿀려고 한다면? 

```
Date Birthday = {2022,12,31};
++Birthday.d; // 유효하지 않은 날짜임

Date Today = {2015,5,6};
Today.m = 15 ; // 유효하지 않은 날짜
```

Date를 나타내는 데이터를 누구나 접근할 수 있게하면(public) Date를 망칠려고 할 수 있다, 누군가는 유효하지 않은 값으로 만들 수 있기 때문에, Date에 유효하지 않은 숫자가 생길 수 있다. 
그러니 private를 통해 접근할 수 없도록 고쳐보.

```cpp
class Date{
private: //기본적으로 private이지만 명시적 선언 해줌
  int y, m, d;
public:
  Date(int y, int m, int d); // 날짜 유효성 확인 후 초기화 (생성자)
  void addDay(int n);
  int year() { return y; }
  int month() { return m; }
  int day() { return d;}
};


int main(void){
  Date birthday(2005,11,22); //가능
  birthday.m = 14 // Error -> Date:m은 비공개
  cout << birthday.month() << endl; // m을 수정하는건 불가능하나, 읽어오는건 가능하다.
  return 0;
}

```
프로그래머는 값이 항상 유효하다는 사실이 보장되도록 타입을 설계해야 한다. 세부 사항은 private로 숨기고, 유효한 객체만 만드는 생성자를 제공하고, 모든 멤버 함수가 유효한 값을 바탕으로 작동하며, 멤버 함수가 반환한 후에도 값이 유효하게 해야한다. 이 때 객체의 값을 **상태(State)** 라고도 하며, 유효한 값을 객체의 **유효한 상태**라고 한다. <br>
유효한 값의 기준을 **불변 규칙**이라고 하지만 Date의 불변 규칙은 유년, 그레고리력, 시간대...등을 고려해보면 정확히 규정하기 어렵다. 그렇기 때문에, 불변 규칙을 정하기 어렵다면, 일반적인 데이터로 클래스가 아닌 구조체로 사용해도 괜찮다.  

##### 멤버 함수 정의 
인터페이스 설계자와 사용자의 관점에서 Date를 살펴 봤고, 이제 멤버 함수를 구현하는 법에 대해 알아보자. 

```cpp
//Date.h
class Date{
private: //기본적으로 private이지만 명시적 선언 해줌
  int y, m, d;
public:
  Date(int y, int m, int d); // 날짜 유효성 확인 후 초기화 (생성자)
  void addDay(int n);
  int year() { return y; }
  int month() { return m; }
  int day() { return d;}
};
```

책에는 공개 인터페이스가 대부분의 사람들이 관심을 갖는 부분이라서 앞에 두는걸 추천한다고 하는데, 본인은 pirvate를 우선 두는걸 선호한다. 어차피 컴파일러는 클래스 안의 함수와 데이터 멤버의 순서를 상관하지 않고, 그대로 받아 들인다. <br>
클래스 밖에서 멤버 정의할 때는 그 멤버가 어떤 클래스로 속하는지 반드시 **명시**해야 한다. 
**클래스 이름 :: 멤버 이름**으로  표기한다. 

```cpp
//Date.cpp
#include "Date.h"

// Date 생성자와 멤버 초기 값 
Date::Date(int yy, int mm, int dd) : y {yy}, m {mm}, d {dd}  { }

void Date::addDay(int n) {
  //..
}   

```
: y {yy}, m {mm}, d {dd}는 멤버를 초기화하는 표기법으로, 멤버 초기값 목록이다. 혹은 다음 코드처럼 작성 할 수 있다. 

```cpp
Date::Date(int yy, int mm, int dd) {
  y = yy;
  m = mm;
  d = dd;
}
```
하지만, 멤버가 먼저 기본 값으로 초기화 된 후에 값을 대입하기 때문에, 초기화 하지 않은 멤버를 실수로 사용할 수 있다. <br>
위처럼 하는 경우 밑에 x값을 대입하는 방법과 같다.

```cpp
int x; //x를 먼저 정의 하고
x = 2; // 나중에 x에 대입 한다.

// y, z를 정의하고, 즉시 값을 초기화 해준다. 
int y = 2;
int z {2};
```

위처럼 클래스를 선언과 정의(구현)을 클래스 안에서 바로 할 수 있다. 다만 클래스가 더러워지고 복잡해지기 때문에 추천하지 않은 방식이다. 

```cpp
class Date{
private: //기본적으로 private이지만 명시적 선언 해줌
  int y, m, d;
public:
  Date(int y, int m, int d) : y{yy}, m{mm}, d{dd} {
  //..
  }

  void addDay(int n){
  //..
  }
  int year() { return y; }
  int month() { return m; }
  int day() { return d;}
};
```

함수 내용이 길어지면, 클래스 선언이 더 길어지고, 인터페이스와 상세 구현을 구별하기 어려워지니깐 추천하지 않는다. 하지만 month함수처럼 짧다면? <br>
클래스 선언 외부에서 Date::month()를 하는것보다 짧고 직관적이라, 짧은 함수는 클래스 안에서 정의하는 방식을 생각해볼만하다. <br>
m이 month함수보다 나중에 선언되더라도 month안에서 m를 접근할 수 있다, 그 이유는 클래스에서 다른 멤버가 해당 클래스의 어디에 선언됐는지에 상관 없이 한 멤버는 다른 멤버 함수나 멤버 데이터에 접근할 수 있기 때문이다. 
즉, 이름을 사용하기 전에 선언해야 한다는 규칙은 클래스 내에서는 예외적이다. <br>
클래스안에서 멤버 함수를 정의하는 방식은 다음과 같은 효과가 있다. 
1. **Inline 함수**가 된다. - 즉, 공통적인 코드를 사용하기 위해 함수 호출 명령을 실행하는 대신 함수를 사용하는 지점마다 코드를 생성한다. 그럼, month함수처럼 하는 일은 거의 없지만, 자주 사용하는 함수의 경우에 지대한 성능 향상을 기대할 수 있다. 명시적으로 inline 키워드를 선언해줘도 되고, 클래스 안에서 멤버 함수를 정의해주면 컴파일러가 자동적으로 키워드를 붙여서 인식해준다. 
2. 인라인 함수의 몸체를 변경할 때 마다 해당 클래스를 사용하는 코드도 **다시 컴파일 해야한다.** 반면에 함수 몸체가 클래스 선언 밖에 있다면, 해당 클래스의 선언을 변경하는 경우에만 클래스를 사용하는 코드를 다시 컴파일 하면된다. 이처럼, 함수 몸체만 바뀐 경우에 호출하는 쪽에서 다시 컴파일 하지 않아도 된다는 점은 대규모 프로그램에 있어, 매우 큰 장점이 된다. 
3. 클래스 정의가 **길어진다** - 결국 멤버 함수 정의 사이에서 특정 멤버을 찾기 어려워진다. 

다섯 줄 이상 아니.. 3줄 이상 구현한 함수에서는 인라인의 이점을 얻을 수 없기 때문에 비추천하는 방식이니 진짜 짧을 경우에만 사용하는걸 추천한다. 

##### 현재 객체 참조
암묵적인 인자를 사용해서 현재 객체 참조를 하는데 이는 17장에서 알 수 있다. 일단 다음 코드를 보자. 

```cpp
void f(Date d1, Date d2){
  cout << "d1의 월 : " << d1.month() << " d2의 월 : "  << d2.month() << endl;
}
```

Date::month는 첫 번째 호출에서 d1.m을 반환해야하고, 두 번째 호출에서 d2.m를 반환해야하는데 이러한 사실을 어찌 알까? <br>
class Date나  Date::month를 봐도 argument가 없는데, Date::month함수는 어떤 객체에서 자신을 호출 했는지 어떻게 알까? <br>
멤버 함수는 자신을 호출한 객체를 알 수 있도록 **암묵적인 인자를** 전달 받기 때문이다. 
즉, 첫 번째 호출은 d1.m이고 두 번째 호출은 d2.m이라는걸 알 수 있다. 

##### 오류보고
유효하지 않은 날짜라면? 당연히 예외를 던져야하며, 유효하지 않은 날짜는 어디서 확인해야 할까는? 생성자, 즉 DAte를 처음 생성하는 곳에서 확인하면 된다. 
유효하지 않은 Date를 생성하지 않고 멤버 함수도 올바르게 작성한다면, Date에 유효하지 않은 날짜가 들어갈 수 없기 때문에, 절대로 사용자가 Date를 유효하지 않은 상태로 만들 수도 없다. 

-----------------------------------------------------------
### 열거형(enum type)
Enum은 매우 간단한 사용자 정의 타입으로, 값(열가자)의 집합을 기호 상수로 정의하는 것이다. 

```cpp
enum class Month{
  jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
};
```

열거형의 몸체는 단순히 열거자enumerator의 목록이고, enum class에서 class의 의미는 열가자가 해당 열거형의 유효 범위 안에 있다는 것이다. 즉, jan을 참조하려면 Month::jan으로 사용해야한다. <br>
열거자에 특정한 값을 지정할 수도 있고, 컴파일러가 적절한 값을 알아서 고르게 내버려둘 수도 있다. 컴파일러가 값을 알아서 고르게 하면, 각 열거자 이전의 열거자 값에 1을 더한 값을 지정한다. 
하지만, 컴파일러가 단순히 기계적인 일을 하게 두는게 좋다. 

또한 Enum 타입의 첫 번째 열거자를 초기화하지 않으면 0부터 초기화한다. 

```cpp
enum class Day{
  monday, tuesday, wednesday, thursday, friday, saturday, sunday
};
```
monday는 0이고, sunday은 6이다. <br>
그리고 열거형은 초기 값을 확인하는 생성자를 만들 수 없지만, 확인 작업을 수행하는 간단한 함수는 만들 수 있다 

```cpp
Month CheckMon(int x){
  if(x < int(Month::jan) || int(Month::dec) < x) {
  return 0; //책에서는 error("bad Month");라고 나왔지만, 이 코드에서는 에러가 나오면 바로 프로그램 종료를 할 것임.  
  }
  return Month(x);
}

void f(int m){
  Month mm = CheckMon(m);
  //...
}
```
Enum 타입은 주로 서로 연관돼 있는 명명된 정수형 상수의 집합이나 서로 구별되는 값을 표현할 때 유용한 방법이다.

#### 일반적인 열거형
**범위 제한 열거형(Scoped Enumeration)** 이라고 부르는 enum class외에 **일반적인 열거형(Plain Enumeration)** 타입 있는데, enum class와 달리, 해당 타입 안의 열거자를 해당 타입이 선언된 범위로 **암묵적으로 노출(Export)** 시킨다. <br> 
밑의 코드를 보면, int로 암무적 변환을 허용한다. 

```cpp
enum Month{
  jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
};

Month m = feb;
Month m2 = Month::feb;
int n = m;
Month mm = Month(7); // 명시적 변환으로 가능 단, 100처럼 이넘에 존재하지 않은 값을 넣으면 의미 없는 값
                    // 즉, Month m = feb;처럼 열거자 이름을 사용하는게 안전함.
mm = static_cast<Month>(7); // 이 또한 명시적 형변환이기 때문에 가능하다. 
```
enum → int는 암시적 변환이 되지만, int → enum의 암시적 변환은 불가능하다. <br>
Plain Enumeration이 enum class보다 덜 엄격하지만, 열거형이 정의된 범위를 오염 시킬 수 있는 단점도 있다. <br>
즉, enum class는 범위에서 벗어난 열거자 값이라면 컴파일러가 되지 않지만 Plain Enumeration는 컴파일러가 되어 예측하지 못하는 값이 나올 수 있다. 그렇기 때문에 주로 enum보다는 enum class를 권장하고, C++11에서 enum class가 도입되었기 때문에, 레거시 코드라면 enum을 사용한 코드가 있을 수도 있다. 

#### 연산자 오버로딩 
연산자 오버로딩이란? 사용자가 만든 클래스도 int 타입처럼 +, -, ==, << 같은 연산자를 사용할 수 있게 만드는 기능이다. <br>
그리고 거의 모든 C++에서 연산자에 클래스와 열거형을 피연산자로서 받아들이게 정의할 수 있다.<br>
보통, 설계하는 타입에 관례적인 표기법을 적용할 때 유용한 편이다. 

```cpp
enum class Month{
  jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
};


Month operator++ (Month& m){ // 전치 연산 증가
    if (m == Month::dec) {
        m = Month::jan;
    } else {
        m = static_cast<Month>(static_cast<int>(m) + 1);
    }
  return m;
}
```

이처럼 +, -, *, /,... 등 C++에 존재하는 연산자는 정의 할 수 있으나, **새로운 연산자를 정의 할 수 없다**<br>
그리고 관례적으로 정해진 개수의 피연산자만 지정할 수 있다. -를 단항 연산자로 정의 가능해도, <=를 단항 연산자로 할 수 없는 것 처럼 <br>
즉, 존재하는 구문은 적용이 가능하나, 새로운 구문으로 확장할 수 없다.

-----------------------------------------------------------------------
### 클래스의 인터페이스 
클래스의 공개 인터페이스와 구현 부분을 분리해야한다고 하였는데, 그럼 좋은 인터페이스는 어떻게 설계하고 구현해야할까? 
다음과 같은 일반적인 원칙을 C++에 적용하면 유용하다.

1. 인터페이스를 완전하게 정의 및 최소화
2. 생성자를 제공.
3. 복사를 제공(또는 복사 불가능하게 만들기)
4. 적절한 인자 검사 방법을 제공하는 타입 사용.
5. 객체 상태를 변경하지 않는 멤버 함수를 명시.
6. 소멸자에서 모든 자원 해제.

인터페이스를 작게 유지하면 배우고 기억하기 쉽고, 잘 쓰이지 않는 불필요한 기능을 구현하느라 시간낭비 할 필요가 없어진다. 그리고, 문제가 생겼을 때 확인을 해야할 함수의 개수가 적어진다. 일반적으로 공개된 멤버 함수가 많으면 버그를 찾기 어려워지고, 공개된 데이터를 포함한 클래스를 디버깅하는 어려움이 굳이 겪을 필요가 없다. 

### 복사 
 항상 객체를 만들기 때문에, **초기화와 생성자를 고려하는건 필수적인 요소**이다. <br>
 생성자는 클래스의 가장 중요한 멤버이기 때문에, 생성자를 작성할려면 객체를 생성할 때 무엇을 인자로 받고, 유효한 값이 무엇인지 혹은 불변 규칙이 무엇인지를 결정해야한다. 초기화에 대해 고민하는 일만으로도 오류를 방지하는데 큰 도움이 된다. 

객체를 복사할 수 있는지의 여부도 고려해야하고, 복사를 하게 된다면 어떻게 복사를 해야하는지도 생각해야한다. <br>
Date나 Month에서 해당 타입의 객체를 복사한다는 의미는 그냥 모든 멤버를 복사면 된다. 이런 경우가 일반적이다. <br>
컴파일러가 다른 명령을 수행하지 않는 이상, 그대로 수행한다. 
 
### 기본 생성자 
 초기화하지 않은 변수는 심각한 오류의 원인이 아니기에, 클래스의 모든 객체가 초기화 되었다는 것을 보장하는 생성자가 필요하다. <br>
 아니면, 기본생성자가 없으면 명시적으로 지정하는 방법도 있다. 

### 멤버 함수와 헬퍼 함수 
인터페이스를 최소한으로 설계하려면 유용한 독립적인 형태로 구현하는 편이 좋을 수도 있다.<br> 
즉, class.h와 class.cpp로 분리하는 편이 좋다. 그러면 함수의 버그로 인해 클래스 안의 데이터가 직접적으로 손상되는 일을 막을 수 있다. <br>
일반적으로 디버깅의 원리를 생각해보면, 클래스 내부 데이터에 직접 접근하지 않은 일은 중요하다. 즉, 클래스가에서 뭔가 이슈가 생기면, 멤버 데이터에 직접 접근하는 함수를 우선 살펴봐야한다. <br>
또한 클래스의 데이터를 변경할 때, 그 데이터에 직접적으로 접근하는 멤버 함수만 변경하면 된다는 점도 기억하자. <br>
헬퍼 함수는 프로그래밍 언어의 개념이 아닌 설계 관점의 개념이기에, 대부분의 헬퍼 함수는 돕고자하는 클래스를 인자로 받지만, 예외인 경우도 있다. 
 

