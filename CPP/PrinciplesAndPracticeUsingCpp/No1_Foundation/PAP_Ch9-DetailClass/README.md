# 9장 언어적 세부 사항 : 클래스 

## 개요
9장에서는 클래스와 열거형(enum)을 비롯한 사용자 정의 타입에 관련된 언어적 세부 사항에 대해 알아본다. <br>
이를 바탕으로 예제 Date 타입을 점지적으로 개선하면서 클래스 설계 기법에 대해 알아보는 챕터이다. 

--------------------------------------------------------
### 9.1 사용자 정의 타입
  int, char, double, float... 이러한 자료형들은 **내장형 타입(혹은 내장형 자료형)** 이라고 하고, 내장형 타입은 개발자가 그에 대한 선언을 소스 코드에 제공하지 않아도 컴파일러 스스로 해당 객체를 어떻게 표현하고, 그 객체에 적용 가능한 연산이 무엇인지 알고 있는 타입을 뜻한다. <br>
  반대로, 내장형 타입이 아닌 모든 타입은 **사용자 정의 타입(UDT, User-Defined Type)** 이라고 하고, 모든 ISO 표준 C++ 구현체에서 사용할 수 있는 string, vector, ostream... 등 비롯한 표준 라이브러리 혹은 직접 만드는 타입들이 사용자 정의 타입이라고 한다. <br>
  표준 라이브러리 타입은 내장형 타입 처럼 언어의 구성 요소라고도 할 수 있으나, 스스로 정의하는 타입과 동일한 구성 요소와 기법으로 만들어져서 여전히 사용자 정의 타입으로 볼 수 있다. → 표준 라이브러리 개발자가 특별한 권한을 보유하거나 남들에게 제공되지 않은 기능을 사용할 수 없다는 뜻이다. 
  내장형 타입과 마찬가지로 대부분의 사용자 정의 타입은 **연산**을 제공한다.

  타입을 만드는 이유는 뭘까? 단순하다, 모든 타입을 컴파일러가 알 수 없거나 모르기 때문이다. <br>
  타입의 유용성은 뭘까?  개발자가 아이디어를 코드로 직접적으로 표현할 때이다. <br>
  정수 타입은 int, 실수 타입은 float, double 혹은 문자(텍스트)는 string이 도움이 된다. 

  1. 메모리 표현(Memory Representation) - 타입은 해당 객체에 필요한 데이터를 표현하는 방식을 알려준다.
  2. 연산(Operation) - 타입은 해당 객체에 적용할 수 있는 연산의 종류를 알려준다.

  그리고 연산의 결과는 객체의 데이터(현재 상태)에 의존한다. 

  C++의 대표적인 사용자 정의 타입으로 struct, class, enum, union이 있으며, 9장에서는 클래스와 열거형에 대해 알아본다. 

  클래스는 프로그램 안에서 특정 개념을 **직접적으로 표현**하는 사용자 정의 타입으로, 해당 타입의 객체를 표현하는 방법과 객체를 생성하는 방법, 객체를 사용하는 방법, 객체를 소멸시키는 방법을 명시한다 (정의, 생성자, 소멸자)
  
### 9.2 클래스와 멤버 
  클래스는 내장형 타입과 그 밖의 사용자 정의 타입과 함수로 이루어진 사용자 정의 타입이라고 하며, 클래스를 구성하는 일부를 **멤버**라고 지칭하고 클래스는 보통 0개 이상의 멤버로 구성 된다. 

```cpp
class X{
  public: //클래스는 구조체와 달리 기본적으로 private이기에 명시적으로 접근제어자를 설정하는게 좋다. 
    int m; //데이터 멤버
    inline int mf(int v) { //함수 멤버 
      int old = m;
      m = v;
      return old;
    }
};
```
  멤버의 종류는 다양하지만, 대부분 클래스의 객체를 표현하는 데이터 멤버이거나 해당 객체에 연산을 수행하는 함수이다. <br>
  그리고 함수 멤버에 inline 키워드를 붙였는데, 컴파일러에게 함수 호출 대신 함수 정의 코드를 직접 삽입하도록 요청하는 키워드이다. 함수 호출 오버헤드를 제거하여 실행 속도를 높이지만, 호출이 반복되면 코드 크기가 커질 수 있기 때문에, 주로 속도가 중요한 짧은 함수에 사용되는 편이다. <br>
  또한 멤버는 다음과 같이 object.member의 표기법으로 접근이 가능하다. <br>

```cpp
X var; // var는 X 클래스 타입의 변수
var.m = 7; // var의 데이터 멤버에 대입
int x;
x = var.mf(9); //var의 멤버 함수 mf() 함수를 호출
```
  멤버의 타입에 따라 그 멤버에 수행할 수 있는 연산이 정해진다. 

### 인터페이스와 구현
  일반적으로 class는 인터페이스와 구현으로 이루어진다. 인터페이스는 사용자가 직접 접근하는 클래스 선언의 일부이다. 구현은 클래스 선언 중 사용자가 인터페이스를 바탕으로 간접적으로 접근하는 부분을 뜻 한다. 공개 인터페이스는 접근 지정 제어자가 public: 이며, 구현은 private:로 구현된다. <br> 
  기본적으로 class는 접근 제어 지정자가 private이기 때문에, 사용자가 비공개 멤버에 바로 접근할 수 없고, 사용자가 접근할 수 있는 공개 함수를 거쳐 호출해야 가능하다. <br>
  private와 public를 이용해서 인터페이스와 상세 구현 사이의 중요한 구분이 가능해진다. <br>
  그리고 구조체 struct는 기본적으로 public으로 직접 접근이 가능하다. 그렇기 때문에, 주로 멤버가 어떤 값이든 가질 수 있는 자료구조, 즉 유의미한 불변 규칙(Invariant)을 정의할 수 없는 경우에 사용한다. 

--------------------------------------------------------------------------

### 클래스로의 진화 
  여기서는 Date 예제를 통해 간단한 자료 구조를 비공개 상세 구현과 유용한 연산을 포함하는 클래스로 개선하는 방법을 알아보자. 

##### struct와 함수
```cpp
strcut Date{
  int y;
  int m;
  int d;
}today;

int main(void){
  Date today;

  today.y = 2025;
  today.m = 11;
  today.d = 19;

  return 0;
}
```
  위의 코드를 봐라, 단순해보이지만, 논리적 오류가 있다. <br>

```
  Date t;

  t.y = -25;
  t.m = 13;
  t.d = 37;
```

  이럴 경우는? 혹은 윤년이 있는 경우는? 문법 오류은 없을지라도, 문제가 있는건 확실하다. <br>
  이렇기 때문에, 일반적인 연산을 하는 헬퍼 함수(Helper Function)가 필요하다. 이를 통해 같은 코드를 계속 반복하거나, 같은 실수를 반복해서 저지르고 찾아내고, 수정하는 행동을 줄일 수 있다. 
  거의 모든 타입에서 초기화와 대입은 가장 일반적인 연산중 하나이다. 

```cpp
void initDay(Date& dd, int y, int m, int d){

  // parameter y, m, d가 유효한 날짜인지 확인하고, dd를 주어진 날짜로 초기화 해준다. 
}

void addDay(Date& dd, int n){
  //dd룰 n일 증가해준다. 
}

void f(){
  Date today;
  initDay(today, 11,19,2025);
  addDay(today, 1);
}
```
  헬퍼 함수를 통해 연산의 유용함을 알 수 있다, 근데 뭔가 이상하지 않는가? 2025일은 없는 숫자이다. 날짜의 유효성을 확인하지 않기 때문에 이처럼 버그가 생길 수 있다. <br>
  또한, 타입을 정의할 때 연산이 필요하며, 필요한 연산는 그때마다 다르다, 그러니 타입을 정의할 때, 어떤 연산이 필요하는가?를 고민하면서 작성하는 것이 좋다.
  
##### 멤버 함수와 생성자 

##### private를 사용하는 이유 

##### 멤버 함수 정의 
##### 현재 객체 참조
##### 오류보고
-----------------------------------------------------------
### 열거형(enum type)

### 클래스의 인터 페이스 
### Argument Type 
### 복사 
### 기본 생성자 
### const 멤버 함수 
### 멤버 함수와 헬퍼 함수 

-------------------------------------------
### Date 클래스 
