# Ch 5 오류 (Error)

##  5.1 개요 - 오류 분류 
오류 없는 완벽한 프로그램은 없다. 오류를 완전히 피활 수 없지만, 완성된 프로그램은 오류가 전혀 없거나, 적어도 받아들일 수 없다고 치부되는 오류를 포함해서는 안된다.

오류를 분류하는 다양한 방법은 다음과 같다.
1. 컴파일 시간 오류(Compile-Time Error) : 컴파일러가 찾아낸 오류로, 컴파일 시간 오류는 해당 오류가 위반한 언어의 규칙에 따라 더 세부적으로 나눌 수 있음.
   - 문법 오류
   - 타입 오류
   
2. 링크 시간 오류(Linker Error) : 목적 파일을 실행 프로그램에 통합하는 과정에서 링커가 찾아낸 오류
3. 실행 시간 오류(Run-Time Error) : 프로그램을 실행하는 동안 확인된 오류로, 이 또한 더 세부적으로 나눌 수 있다.
   - 컴퓨터(HW or OS)가 감지한 오류
   - 라이브러리가 감지한 오류
   - 사용자 코드가 감지한 오류
4. 논리 오류(Logic Error) : 프로그래머가 잘못된 결과의 원인을 분석하는 과정에서 찾아낸 오류.

모든 오류를 제거하는 것은 불가능하다. 하지만 프로그램이 손상되어도 시스템의 어딘가에서 적절한 조치를 취해줄 수 있다. <br>
즉, 핵심은 **이 프로그램이 그런 오류를 감지해야하는가?** 라고 할 수 있고, 우리는 프로그램에 대해 다음과 같이 정의한다.
1. 모든 적법한 입력에 대해 요구받은 결과를 생성한다.
2. 모든 적법하지 않은 입력에 대해 적절한 오류 메시지를 출력한다.
3. 하드웨어의 오동작은 고려하지 않는다.
4. 시스템 소프트웨어의 오동작은 고려하지 않는다.
5. 오류를 감지한 후에는 종료해도 좋다.

3,4,5번 가정을 만족하지 않은 모든 프로그램은 진보된 프로그램이라고 생각하면 된다. 반면 1,2번 가정은 가장 기본적이고 프로그래머가 추구해야할 목표이다. <br>
그럼 **오류를 어떻게 처리해야할까?** 오류를 잘 처리하고, 기본적으로 적절한 수준의 소프트웨어를 만들기 위해서 다음과 같은 3가지 접근 방법을 항상 생각하자.
1. 소프트웨어를 조직화해서 오류를 최소화한다.
2. 우리가 만든 대부분의 오류를 테스트와 디버깅을 바탕으로 제거한다.
3. 남아있는 오류는 사소한 오류임을 확인하다.

항상 올바르게 작동하는 프로그램이 목표이기에 거기에 달성할 수 있도록 노력하자. 

--------------------------------------------------------------
## 5-2 오류의 원인 
이제 오류가 생기는 이유를 알아보자. 
1. 엉터리 명세 : 프로그램이 해야 할 일을 정확히 명시하지 않으면, 사각 지대를 제대로 확인하고, 모든 경우를 처리했는지 알기 어렵다.
2. 불완전한 프로그램 : 개발 과정에서 고려하지 않은 경우가 있을 수 있다. 이를 피할 수 없겠지만, 적어도 모든 경우를 처리했음을 확인하는 일을 목표로 삼아야한다.
3. 예상 밖의 인자(Argument) : 함수는 인자를 받아들이며, 우리가 처리하지 않은 인자가 함수에 전달되면 문제가 된다.
4. 예상 밖의 입력 : 일반적으로 프로그램은 데이터를 읽는다. 프로그램은 이러한 입력에 대해 많은 가정을 하지만, 예상 밖의 입력이 들어오면 문제가 생긴다
```cpp
int a;
cin >> a;
//근데 정수형 20 대신에 "Hello"를 넣어봐라 
```
5. 예상 밖의 상태 : 대부분의 프로그램은 시스템의 서로 다른 부분에서 사용할 데이터(상태)를 유지한다. 주소 목록, 전화번호부, 온도 측정 결과를 저장하는 Vector 등... 근데 그런 데이터가 불완전하거나 틀렸다면 어찌할까? 이건 추후에 26장에서 다룬다.
6. 논리 오류 : 코드가 의도한대로 작동하지 않은 경우를 말하고, 이런 문제는 찾아서 고칠 수 밖에 없다, 6장에서 다룬다. 
**이 목록은 실용적으로 쓸모가 있다** 즉, 프로그램을 어느정도 확인해야 하는지 알려주는 CheckList로 사용할 수 있다.

잠재적인 오류의 원인을 모두 고려하지 않으면 그 어떤 프로그램도 완벽하지 않다.

-------------------------------------------------------------------------

## 5-3 컴파일 시간 오류(Compile Time Error)
컴파일러는 목적 코드를 생성하기 전에 코드를 분석해서 문법 오류와 타입 오류를 찾아낸다. <br>
즉, 프로그램이 언어의 명세에 '완전히' 부합할 때만 다음 과정을 진행 할 수 있고, 컴파일러가 찾아내는 오류 중 대다수는 편집 미완료로 인한 **단순 실수 오류**이다. 그 외의 오류는 프로그램의 각 부분이 상호작용하는 방법을 잘못 이해하는데서 오는 결함이다. 

```cpp
int area(int length, int width){
   return length * width; 
}

int maind(void){
   int s1 = area(7; // )누락 
   int s2 = area(7) // ;누락
   Int s3 = area(7); // Int는 타입이 아님
   int s4 = area('7); //종료하지 않은 문자 '누락
return 0;
}
```
위의 코드는 모두 문법 오류가 포함 된 코드이다. 즉, C++ 문법에 부합하지 않는 코드를 컴파일러가 거부한다. <br>
또한, 문법 오류가 발생한 경우에 컴파일러가 지적한 행에서 문제를 찾을 수 없다면 프로그램의 이전 행을 살펴보자. <br>
그리고 컴파일러는 있는 프로그래머가 짠 의도를 알 수 없기 때문에, 그대로 보이는대로 오류를 잡을수 밖에 없다. 

이제 문법 오류를 제거하면 컴파일러는 타입 오류를 잡기 시작한다. <br>
즉, 프로그래머가 선언한 변수, 함수 등의 타입과 표현식, 인자 등의 타입이 일치하지 않은 경우를 보여준다.  

```cpp
   int x0 = arean(7,2); //선언하지 않은 함수
   int x1 = area(7); // 인자 혹은 매개변수의 수가 맞지 않음
   int x2 = area("seven",2); //첫번째 매개변수의 타입이 다름
```

오류가 아닌 경우가 있는데, 컴파일러가 보고하는 오류 중 일부를 오류가 아니라고 생각할 수 있다. <br> 
즉 문법적으로, 혹은 타입적으로 옳지만 논리적 오류가 발생하는 경우이다. <br>
```cpp
   int x4 = area(10,-7); // 문법적으로, 타입적으로 옳음 그러나 너비가 -70인 사각형이 있을까? 
   int x5 = area(10.7, 9.3); // int 정수형 타입으로 소수점을 버리고 10, 9를 호출
   char x6 = area(100, 9999); // 결과를 축소 변환 
```
 x4를 봐라 int는 unsigned int가 아니라면, 음수 부터 정수까지 표현 할 수 있다 (unsigned int 는 양수만 표현) 그러니 컴파일러 입장에서는 저건 틀린 문법이 아니기에 오류라고 하지 않는다. <br>
 x5는 컴파일러가 좋은거라면 10.7, 9.3이 정수 10, 9로 축소 변환한다고 경고하지만, double or float를 int로 축소 변환을 할 수 있기 때문에 이또한 오류라고 하지 않는다 <br>
 x6는 결과를 char 대입하는데, 여기서 결과로 가장 가능성이 큰 값은 축소 변환된 값 -36이고, 컴파일러는 이를 오류라고 잡아주지 않는다 <br>

 **내 프로그램이 컴파일 되었다고** 프로그램이 실행되는 것을 의미하지 않고, 실행된다고 해도 논리적 결함을 찾아내기 전에는 잘못된 결과가 나오기 마련이다. 

 -------------------------------------------------------------------------

## 5-4 링크 시간 오류 
프로그램은 변환 단위라고 일컬어지는 분리돼 컴파일된 다수의 부분으로 이뤄진다. <br>
한 프로그램 안의 모든 함수는 그 함수를 사용하는 모든 변환 단위에서 동일한 타입으로 선언되어야하며, 이를 보장하기위해 헤더 파일을 이용한다. <br>
그러나 **모든 함수는 한 프로그램 안에서 딱 한 번 정의되어야 한다.** 두 규칙중 하나라도 위반하면 링커 오류가 난다. <br>
그리고, 함수 이름에 오타가 있는 경우는 링컥 오류를 보고하지 않는다, 대신 컴파일러가 선언하지 않은 함수를 발견하는 즉시 오류를 일으킨다. <br> 
함수 링크 규칙은 변수와 타입을 비롯한 프로그램의 모든 구성 요소에도 동일하게 적용되니깐 꼭 기억하자.
1. 동일한 이름의 구성 요소는 **딱 한 번** 정의돼야 한다.
2. 선언은 여러번 할 수 있지만, 모든 선언의 타입은 정의한 타입과 **일치**해야한다.

----------------------------------------------------------------------------------------

## 5-5 실행시간 오류 
이제 컴파일 시간 오류와 링크 시간 오류에서 문제가 없다면, 프로그램을 실행할 수 있다. <br>
프로그램을 작성할 때 오류를 찾을 수 있지만, 실행 중에 감지한 오류를 처리하는 방법을 알아내기란 항상 쉽지 않다. 
```cpp
int area(int len, int wid){
   return len * wid;
}

int framed_area(int x, int y){
   return area(x - 2, y - 2);
}

int main(void){
   int x = -1;
   int y = 2;
   int z = 4;

   int area1 = area(x,y);
   int area2 = framed_area(1,z);
   int area3 = framed_area(y,z);
   double ratio = double(area1)/area3;

   return 0;
}
```
위의 코드를 봐라, area1과 area2는 음수가 대입이 되는데, 이 오류를 용인해야할까? 아니면 오류를 찾아내야할까? 만약에 오류를 찾아내야한다면 어디서 찾아야하는가? <br>
그리고 ratio에서의 결함을 찾아보자. area3의 값은 0이므로, 하드웨어 감지 오류가 발생하여 프로그램이 종료된다. <br>
그럼 어떻게 해결해볼까? 일단 area함수쪽 argument에 관한 오류를 고쳐보자. 
1. area함수를 호출하는 쪽에서 잘못된 인자를 처리한다.
2. area함수의 안에서 잘못된 인자를 처리한다.

그럼 1번 대안인 **호출하는 쪽(caller)에서의 오류처리**에 대해 보자. 
area()가 라이브러리안에 포함된 ㅎ재적인 오류의 원인을 모두 고려하지 않으면 그 어떤 프로그램도 완벽하지 않다.

-------------------------------------------------------------------------

## 5-3 컴파일 시간 오류(Compile Time Error)
컴파일러는 목적 코드를 생성하기 전에 코드를 분석해서 문법 오류와 타입 오류를 찾아낸다. <br>
즉, 프로그램이 언어의 명세에 '완전히' 부합할 때만 다음 과정을 진행 할 수 있고, 컴파일러가 찾아내는 오류 중 대다수는 편집 미완료로 인한 **단순 실수 오류**이다. 그 외의 오류는 프로그램의 각 부분이 상호작용하는 방법을 잘못 이해하는데서 오는 결함이다. 

```cpp
int area(int length, int width){
   return length * width; 
}

int maind(void){
   int s1 = area(7; // )누락 
   int s2 = area(7) // ;누락
   Int s3 = area(7); // Int는 타입이 아님
   int s4 = area('7); //종료하지 않은 문자 '누락
return 0;
}
```
위의 코드는 모두 문법 오류가 포함 된 코드이다. 즉, C++ 문법에 부합하지 않는 코드를 컴파일러가 거부한다. <br>
또한, 문법 오류가 발생한 경우에 컴파일러가 지적한 행에서 문제를 찾을 수 없다면 프로그램의 이전 행을 살펴보자. <br>
그리고 컴파일러는 있는 프로그래머가 짠 의도를 알 수 없기 때문에, 그대로 보이는대로 오류를 잡을수 밖에 없다. 

이제 문법 오류를 제거하면 컴파일러는 타입 오류를 잡기 시작한다. <br>
즉, 프로그래머가 선언한 변수, 함수 등의 타입과 표현식, 인자 등의 타입이 일치하지 않은 경우를 보여준다.  

```cpp
   int x0 = arean(7,2); //선언하지 않은 함수
   int x1 = area(7); // 인자 혹은 매개변수의 수가 맞지 않음
   int x2 = area("seven",2); //첫번째 매개변수의 타입이 다름
```

오류가 아닌 경우가 있는데, 컴파일러가 보고하는 오류 중 일부를 오류가 아니라고 생각할 수 있다. <br> 
즉 문법적으로, 혹은 타입적으로 옳지만 논리적 오류가 발생하는 경우이다. <br>
```cpp
   int x4 = area(10,-7); // 문법적으로, 타입적으로 옳음 그러나 너비가 -70인 사각형이 있을까? 
   int x5 = area(10.7, 9.3); // int 정수형 타입으로 소수점을 버리고 10, 9를 호출
   char x6 = area(100, 9999); // 결과를 축소 변환 
```
 x4를 봐라 int는 unsigned int가 아니라면, 음수 부터 정수까지 표현 할 수 있다 (unsigned int 는 양수만 표현) 그러니 컴파일러 입장에서는 저건 틀린 문법이 아니기에 오류라고 하지 않는다. <br>
 x5는 컴파일러가 좋은거라면 10.7, 9.3이 정수 10, 9로 축소 변환한다고 경고하지만, double or float를 int로 축소 변환을 할 수 있기 때문에 이또한 오류라고 하지 않는다 <br>
 x6는 결과를 char 대입하는데, 여기서 결과로 가장 가능성이 큰 값은 축소 변환된 값 -36이고, 컴파일러는 이를 오류라고 잡아주지 않는다 <br>

 **내 프로그램이 컴파일 되었다고** 프로그램이 실행되는 것을 의미하지 않고, 실행된다고 해도 논리적 결함을 찾아내기 전에는 잘못된 결과가 나오기 마련이다. 

 -------------------------------------------------------------------------

## 5-4 링크 시간 오류 
프로그램은 변환 단위라고 일컬어지는 분리돼 컴파일된 다수의 부분으로 이뤄진다. <br>
한 프로그램 안의 모든 함수는 그 함수를 사용하는 모든 변환 단위에서 동일한 타입으로 선언되어야하며, 이를 보장하기위해 헤더 파일을 이용한다. <br>
그러나 **모든 함수는 한 프로그램 안에서 딱 한 번 정의되어야 한다.** 두 규칙중 하나라도 위반하면 링커 오류가 난다. <br>
그리고, 함수 이름에 오타가 있는 경우는 링컥 오류를 보고하지 않는다, 대신 컴파일러가 선언하지 않은 함수를 발견하는 즉시 오류를 일으킨다. <br> 
함수 링크 규칙은 변수와 타입을 비롯한 프로그램의 모든 구성 요소에도 동일하게 적용되니깐 꼭 기억하자.
1. 동일한 이름의 구성 요소는 **딱 한 번** 정의돼야 한다.
2. 선언은 여러번 할 수 있지만, 모든 선언의 타입은 정의한 타입과 **일치**해야한다.

----------------------------------------------------------------------------------------

## 5-5 실행시간 오류 
이제 컴파일 시간 오류와 링크 시간 오류에서 문제가 없다면, 프로그램을 실행할 수 있다. <br>
프로그램을 작성할 때 오류를 찾을 수 있지만, 실행 중에 감지한 오류를 처리하는 방법을 알아내기란 항상 쉽지 않다. 
```cpp
int area(int len, int wid){
   return len * wid;
}

int framed_area(int x, int y){
   return area(x - 2, y - 2);
}

int main(void){
   int x = -1;
   int y = 2;
   int z = 4;

   int area1 = area(x,y);
   int area2 = framed_area(1,z);
   int area3 = framed_area(y,z);
   double ratio = double(area1)/area3;

   return 0;
}
```
위의 코드를 봐라, area1과 area2는 음수가 대입이 되는데, 이 오류를 용인해야할까? 아니면 오류를 찾아내야할까? 만약에 오류를 찾아내야한다면 어디서 찾아야하는가? <br>
그리고 ratio에서의 결함을 찾아보자. area3의 값은 0이므로, 하드웨어 감지 오류가 발생하여 프로그램이 종료된다. <br>
그럼 어떻게 해결해볼까? 일단 area함수쪽 argument에 관한 오류를 고쳐보자. 
1. area함수를 호출하는 쪽에서 잘못된 인자를 처리한다.
2. area함수의 안에서 잘못된 인자를 처리한다.

그럼 1번 대안인 **호출하는 쪽(caller)에서의 오류처리**에 대해 보자. 
area()가 라이브러리안에 포함되어 있는 경우, 즉 프로그래머가 직접 수정할 수 없는 경우에는 이 대안을 선택한다<br>
```cpp
if(x<=0) {
   error("x가 양수가 아님);
}

if(y<=0) {
   error("y는 양수가 아님);
}
int area1 = area(x,y);
```
오류를 감지했을 때, error함수로 통해 처리한다. 이 함수는 std_lib_facilities.h에 포함된 함수로 기본적으로 시스템 오류 메시지와 인자로 전달된 문자열을 함께 출력하고나서 프로그램을 종료하는 방법이다. 
참고로 C++자체에서는 error함수가 **없어** error를 통한 예외처리가 불가능하니, runtime_error 클래스 같은걸 사용해야한다 (편의상 책에 있는 건 대부분 std_lib_facilities.h에 포함되어 있을거다, 그리고 C++11을 요구하니 C++26까지 나온 시점에서 다를 수 있다.) <br>
**std::exception나 try-catch를 통한 throw 키워드를 입력해서 예외처리를 해야한다. 그리고, stdexcept 클래스안에 있는 domain_error, runtime_error등.. 다양한 클래스를 통해서 예외를 처리해야한다.** (5.6항목을 참고) <br>
즉, std_lib_facilities.h에 의존하지말고, 직접 <iostream>이나 <string>, <vector>를 선언해서 포함시시키고 error가 아닌 다른걸로 예외처리 해보자. <br>
밑의 코드는  std_lib_facilities.h에 정의된 error 함수의 코드이다. 
```cpp
struct Exit : runtime_error {
	Exit(): runtime_error("Exit") {}
};
 
// error() simply disguises throws:
inline void error(const string& s)
{
	throw runtime_error(s);
}
 
inline void error(const string& s, const string& s2)
{
	error(s+s2);
}
 
inline void error(const string& s, int i)
{
	ostringstream os;
	os << s <<": " << i;
	error(os.str());
}
```


2번째 방법인 **호출되는 쪽(callee)에서의 오류 처리**에 대해 알아보자 
framed_area안에서 argument가 올바른지 확인해서 처리하는 방법이다. 
```cpp
framed_area(int x, int y){
   constexpr int fWidth = 2;
    try {
        if (x - fWidth <= 0 || y - fWidth <= 0) {
            throw runtime_error("framed_area(): invalid arguments (non-positive dimensions).");
        }
        return area(x - fWidth, y - fWidth);
    }
    catch (const runtime_error& e) {
        cerr << "Caught exception in framed_area: " << e.what() << endl;
        return -1; // 오류 상황일 때 특별한 값 반환 
    }
}
```
   이런 방법을 사용하면 framed_area호출 할 때마다 확인하는 코드를 작성할 필요가 없고, 계속 호출해야하는 경우에도 유용하다, 그리고 오류 처리 방법이 변경되더라도 저 함수 안에서 수정을 하면 되니까 좋다. <br>
이 방법은 argument 확인 코드가 한 곳에만 있기 때문에 프로그램 전체를 흝어볼 필요가 없다는거고, 인자를 확인하는데 필요한 모든 정보를 사용할 수 있다. 

근데, 함수 안에서 인자를 확인하는건 간단한 일인데도, 왜 항상 이렇게 하지 않은 이유가 뭘까?  <br>
부주의하거나 서투름이 있어서 그럴 수도 있으나, 그럴만한 이유가 있을 수 도 있기 때문이다.
1. 함수 정의를 수정할 수 없다. <br>
→ 라이브러리 안의 함수철머 함수를 변경할 수 없는 경우가 있고, 타인과 코드를 함께 사용하거나 소스 코드가 다른 사람의 소유일수도 있고 아니면 정기적으로 새로운 버전을 출시하는 라이브러리안에 함수가 포함돼 새로운 라이브러리 배포판이 나올 때 마다 변경이 필요할 수도 있기 때문이다.

2. 호출되는 함수 안에서 오류를 어떻게 처리할지 알 수 없다. <br>
→ 대부분 라이브러리가 이에 속함, 라이브러리 제작자가 오류를 감지할 수는 있지만, 오류가 발생하면 프로그래머가 무슨 일을 해야 할지 알아야하기 때문이다.
 
3. 호출되는 함수가 자신을 어디서 호출했는지 알 수 없다. <br>
→ 오류 메시지를 출력하면 뭔가 문제가 있음을 알수 있지만, 실행 중인 프로그램이 어떤 경로로 오류를 냈는지 알 수 없을 때, 이 경우에는 구체적인 오류 메시지가 필요할 수도 있다.

4. 성능 <br>
→ 작은 함수에서는 argument를 확인하는 코드의 비용이 결과를 계산하는 비용보다 클 수도 있다.
프로그램에 따라서 치명적인 문제가 될 수 있는데, 특히 여러 함수가 변하지 않는 정보를 바탕으로 서로를 호출할 때 동일한 정보를 불필요하게 확인할 수 도 있다.

특별한 이유가 없으면 함수 안에서 인자를 확인하는걸 추천한다. 

**오류 보고** <br>
일련의 인자를 확인해서, 오류를 찾아냈다면 다음은 무슨일을 해야할까? <br>
때에 따라서는 error value를 반환할 수 있다. 
```cpp
char ask_use(string question){
   string answer = "";
   cout << question << "? (yes or no)\n";
   cin >> answer;
   if(answer == "y" || answer == "yes") {
      return 'y';
   }
   if(answer == "n" || answer == "no"){
      return 'n';
   }
   return 'b'; 
}

int area(int len, int wid){
   if(len <= 0 || wid <= 0) return -1;
   return len * wid;
}
```
호출되는 쪽에서 세세하게 확인함은 물론, 호출하는 쪽의 필요에 따라 오류를 처리할 수 있다. 하지만, 이 방법을 선택할 수 없는 몇 가지 이유도 존재한다. 

- 호출되는 함수와 호출하는 쪽 모두 확인을 해야한다. 호출하는 쪽의 확인 작업은 간단하지만, 여전히 확인을 한 후 실패 시에 어떻게 할지 정해야한다.
- 호출하는 쪽에서 확인을 잊을 수도 있다. 이럴 경우 프로그램을 실행할 때 결과를 예측할 수 없다.
- 오류를 나타내는 값으로 사용할 여분의 반환 값이 없는 함수도 많다. 예를 들어 입력에서 int를 읽어, 반환하는 함수는 임의의 int 값을 반환할 수 있으므로 실패를 나타낼 용도로 쓸 수 있는 int 값이 없다.

```cpp
int f(int x, int y, int z){
   int area1 = area(x,y);
   if(area1 <=0) error("음수가 아닌 넓이") ; //error함수는 없다 다른걸로 throw통한 예외처리 할것
   int area2 = framed_area(1,z);
   int area3 = framed_area(y,z);
   double ratio = double(area1)/area3;
}
```
오류가 있을까? 없을까? <br>
확인의 부재로 인한 오류는 겉보기에는 틀린점이 없어 보이기 떄문에 찾아내기 어렵다. <br>
이제 예외에 대해 알아보자. 

----------------------------------------------------------------------------------------

## 5-6 예외(exception)
오류를 처리하는 매커니즘인 예외를 지원한다. <br>
기본적인 원리(아이디어)는 (호출되는 함수에서 수행해야 하는) 오류 감지와 (호출하는 함수쪽에서 수행해야 하는) 오류 처리를 분리함과 동시에 감지된 오류를 무시할 수 없게 하는 데에 있다. 즉, 예외을 잘 사용한다면 오류가처리가 쉬운일은 아니지만 한결 수월해진다. <br>
Exception의 기본 아이디어는 함수가 처리할 수 없는 오류가 발생하면 일반적인 return을 하는 대신 오류를 나타내는 예외를 throw한다. 문제의 함수를 직간접적으로 호출한 모든 함수에서 Exception를 catch해서 호출된 코드가 throw를 사용했을 때, 무슨 일을 할지 정할 수 있다. <br>
보통 try- catch문을 사용해서 잡는다. <br>
그리고, 호출하는 쪽 어디서도 예외를 잡지 않으면 프로그램을 종료한다. <br>
이제 잘못된 인자를 사용할 때 어찌해야할지 알아보자.

**잘못된 인자** 

예외를 이용해서 다음 코드를 수정해보자.

```cpp
class Bad_area {}; //area()에서 오류 보고에 사용할 타입.

int area(int len, int wid){
   if(len <= 0 || wid <= 0){
      throw Bad_area{};
   }
   return len * wid;
}
```
argument에 문제가 없으면 넓이로 반환할꺼고, 그렇지 않으면 어딘선가 cathc로 적절한 조치를 해주기 바라며 throw로 area()를 종료한다. 
catch에서 area()가 던진 예외임을 알수 있도록, area함수에서 유일한 무언가를 throw할 목적으로 Bad_area라는 새로운 타입을 정의했다. 
즉, 기본 값으로 bad_area 타입의 객체를 만든다라는 뜻으로, throw Bad_area()는 "Bad_area 타입의 객체를 만들어 throw"하라는 의미이다. 
이제 메인 함수 코드를 보자 

```cpp
int main(void){
try{
   int x = -1;
   int y = 2;
   int z = 4;
   int area1 = area(x,y);
   int area2 = framed_area(1,z);
   int area3 = framed_area(y,z);
   double ratio = double(area1)/area3;
} catch(Bad_area){
   cout << "area함수에 잘못된 인자 전달됨\n";   
}
   return 0;
}
```
main함수와 framed_area의 호출을 비롯한 모든 area에 대한 호출을 처리할 수 있따는 점에서 주목하자, 그리고 오류 처리와 오류 감지 부분이 얼마나 명확하게 분리 됐는지 주목하자. 메인 함수는 어떤 함수가  throw Bad_area{};를 실행했는지 모르고, area도 자신이 throw한 Bad_area 예외를 어떤 함수가 catch하는지 알지 못한다. <br>
이러한 분리는 많은 라이브러리를 이용해서 작성한 대규모 프로그램에서 매우 중요하다. 응용 프로그램과 라이브러리 양쪽의 모든 코드를 수정하고 싶지 않기 때문에, 필요한 곳마다 코드를 삽입하는 방식으로 오류를 처리할 수 없다. 

**구간 오류** 

 대부분의 실제 코드는 데이터 집합을 처리한다. 즉, 처리할 데이터 요소를 포함하는 다양한 종류의 표와 목록 등을 이용하는데, C++에서 이러한 데이터 모음을 **컨테이너(Container)** 라고 한다. vector, list, array, map... iterator등이 있다. <br>
vector는 가장 일반적이고 유용한 표준 라이브러리 컨테이너이고 이 vector를 이용해서 구간 오류에대해 알아보자. <br>
vector는 여러 개의 요소를 저장하며 vector의 size 멤버 함수를 호출해 요소의 개수를 알 수 있다. 그런데 유효한 구간인 0:v.seze() 밖의 인덱스로 요소에 접근하면 무슨일이 벌어질까? <br>
low:high는 low에서 high-1까지를 가리키는 일반적인 표기법이다. 즉 low는 포함하지만 high는 포함하지 않는 구간을 말한다. <br>
자, 0:v.seze()라는 v의 인덱스 구간을 알고 있다면, 그 안에서 인덱스를 사용하면 되지 않을까? 근데 가끔은 하기 어려운 경우가 있다. <br>
다음 코드를 보자.

```cpp
std::vector<int> v; //int자료형을 포함하는 vector v
for(int i; std::cin>>i;) v.push_back(i);
for(int i = 0; i <= v.size(); ++i){
   std:: cout << "v[" << i << "] == " << v[i] << std::endl;
}
```
일반적이진 않은 오류지만, 만들 수 있는 오류이다. 위의 코드 문제는 v\[i\]에 접근할 때, i가 항상 구간 안에 있는지 확인하려고 0과 size함수를 이용한 부분에서 찾을 수 있다. 자 여기서 for문을 보자, 루프의 종료 조건에서 i<=v.size() 대신 i<v.size()라고 수정해줘야한다. <br> 
이러지 않으면, -1까지 접근하는 것이 아닌 하나 더 접근하게 된다. 즉, 입력받은 정수는 5개인데, 여섯 번 접근을 시도하는 경우가 생겨난다. <br>
v\[5]에 접근할 때 실제로는 vector의 끝보다 하나 더 뒤에 접근하게 된다. 이러한 오류를 **하나 차이 오류(off-by-one error), 구간 오류(range error), 경계 오류(bound error)** 라고 한다. <br>
구간 for문을 루프를 표현하면 되지 않을까? 루프의 끝에서 잘못된 인덱스를 사용할 수 없으니깐, 하지만 각 요소의 값뿐만 아니라 인덱스의 값도 필요하기 때문에 구간 for에서 인덱스의 값을 얻으려면 별도의 작업이 필요하다. 
```cpp
vector<int> v(5);
int x = v[5];
```
이 코드 또한 루프에서와 동일한 구간 오류를 일으킨다. <br>
그럼 구간 오류가 발생하면 무슨일이 일어날까? vector의 첨자 연산은 vector의 크기를 알고 있으므로 인덱스가 유효한지 확인할 수 있다. 그리고 확인 결과 문제가 있다면, out_of_range 타입의 예외를 던진다. <br>
즉, 해당 예외를 잡는 프로그램에 위와 같이 하나 차이 오류를 초함한 코드가 있다면, 적어도 적당한 오류 메시지를 출력한다는 사실은 보장할 수 있다. 
```cpp
int main(){
   try{
   vector<int> v;
   for(int x; cin>>x;)
   v.push_back(x);
   for(int i = 0; i <= v.size(); ++i)
      std:: cout << "v[" << i << "] == " << v[i] << std::endl;
   } catch(out_of_range) {
   cerr << "이런! 구간 오류 발생\n";
   return 1;
   } catch(...){
      cerr<< "예외 : 뭔가 잘못됨 \n";
      return 2; 
   }
}
```
구간 오류도 잘못된 인자 오류의 매우 특별한 경우에 속한다. <br>
vector의 인덱스를 항상 확인한다는 보장이 없기에 vector의 첨자 연산에서 확인 작업을 대신해주길 바란다. <br>
vector의 첨자 연산자 (vector::operator[])에서 오류를 찾아 예외를 던진다.

**잘못된 입력**

잘못된 입력 처리방법은 10-6에서 더 자세히 알아보자. 그러나, 여기서 알아야하는 것은 잘못된 입력을 처리하는 방법도 인자 오류나 구간 오류를 처리할 때 사용한 기법과 언어의 기능을 동일하게 활용한다. 그리고 여기서, 입력 연산이 성공했을 경우에 어떻게 할지에 대해 알아보자. 
```cpp
double d = 0;
cin >> d;

if(cin){
   //모두 정상, 다음 입력 가능 
} else{
   // 마지막 입력 실패, 다른 조치 해야함 
}
```
위의 코드처럼 부동소수점 숫자를 입력 받는 경우를 생각해보자. <br>
입력 연산이 실패하는데 여러 이유가 있지만, >>가 읽을 수 있는 double이 없을 경우일 것이다. 그리고 개발 초기에는 오류를 찾았다는 사실을 알리고 싶지만, 어떤 조치를 취해야 좋을지 알 수 없는 경우가 있다. 이 때는, 오류를 보고하고 프로그램을 종료한다. 
```cpp
double some_function(){
   double d = 0;
   cin >> d;

   if(!cin){
      //에러 처리, some_function함수가 double를 읽지 못함
      //필요한 작업을 수행
   }
} 
```
위의 코드는 cin이 앞서 수행한 연산이 실패했음을 의미한다. (책에는 error 함수 처리를 통해 사용자에게 오류를 알리고 프로그램을 종료함) 
프로그램을 종료하기 전에 메시지를 읽을 수 있게 충분한 시간 동안 창을 열어 놓는 등의 부수적인 조치를 취할 수도 있다. <br>
vector가 던지는 out_of_range등의 몇 가지 예외를 정의하는데, 오류를 처리할 때 필요한 문자열(오류 메시지)을 포함한다는 점에서 우리의 필요에 적합한 runtime_error도 제공한다. <br>
혹은 error함수를 간단히 직접 정의해서 사용할 수 있다. 
```cpp
void error(string s){
   throw runtime_error(s);
}
```
 runtime_error를 처리하고 싶으면 예외를 잡으면 되고, 간단한 프로그램이라면 main에서 잡아도 된다. 

```cpp
int main(void){
   try{
   // 프로그램 코드... 작성
   return 0;
   }
   catch(runtime_error& e){
      cerr<<"runtime error : " << e.what() << '\n;
      keep_window_open();
      return 1;
   }
   return 0;
}
```
e.what()함수는 runtime_error로부터 오류 메시지를 가져온다. <br>
runtime_error& e에서의 &는 **예외를 참조로 전달하라** 의미로 8장에서 학습할 예정이다. <br>
그리고 cout대신에 cerr을 사용한다. <br>
cerr는 오류에 적합하게 최적화할 수 있고, 오류에 관련된 내용을 출력하는 사실을 문서화하는 효과도 있기에 오류 메시지에는 cerr를 사용한다. 

참고로 std_lib_facilities.h 헤더파일에 keep_window_open함수가 정의되어 있다. 
```cpp
inline void keep_window_open()
{
	cin.clear();
	cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
 
	cout << "Please enter a character to exit\n";
	char ch;
	cin >> ch;
	return;
}
 
inline void keep_window_open(string s)
{
	if (s == "") {
		keep_window_open();
		return;
	}
 
	cin.clear();
	cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
 
	for (;;) {
		cout << "Please enter " << s << " to exit\n";
		string ss;
		while (cin >> ss && ss!=s)
			cout << "Please enter " << s << " to exit\n";
		return;
	}
}
```

다시 본문으로 돌아가서, out_of_range는 runtime_error가 아니므로, runtime_error만 잡아서는 vector를 비롯한 STL 잘 못 사용했을 때 발생한 out_of_range를 처리할 수 없다. 그러나 out_of_range와 runtime_error 모두 예외에 속하기에 exception을 하면 둘 다 처리할 수 있다. 
```cpp
int main(){
   try{
   //프로그램 코드
   return 0;
   }catch(exception& e){
      cerr << "오류 : " << e.what() << "\n";
      keep_window_open();
      return 1;
   } catch(...){
      cerr<<"알수 없는 예외 \n";
      keep_window_open();
      return 2;
   }
   return 0;
}

```

catch(...)를 추가해서 다른 모든 타입의 예외를 처리했고, out_of_range와 runtime_error의 공통 기반(supertype)인 exception 타입 하나로 두 예외를 모두 처리하였다. <br>

**축소 오류** 

특정 변수에 저장하기에 너무 큰 값을 대입하면 암묵적인 절삭이 일어나는 성가신 오류를 앞에서 알아봤다. 
```cpp
int x = 2.9;
char c = 1066;
```
이러한 경우 또한, 값의 변경을 초래하는 대입이나 초기화를 확인하고 runtime_error를 던질 수 있다. 
```cpp
int x1= narrow_cast<int>(2.9); //예외 던짐
int x2= narrow_cast<int>(3.0); // ok
char c1= narrow_cast<char>(1066); //예외 던짐
char c2= narrow_cast<char>(85); //ok
```
\<...>는 값이 아닌 타입을 지정할 때 사용하는 **템플릿 인자(template argument)** 라고 한다. 값을 변환할 때 크기에 맞는다는 보장을 할 수 없는 경우 narrow_cast를 사용하는데, 이 또한 std_lib_facilities.h에 정의되어 있다. <br>
캐스트는 '타입 변환'을 의미하고, 피연산자를 변경하지 않는다. 단지 피연산자의 값에 해당하는 새로운 값을 만들어낸다 

----------------------------------------------------------------------------------------

## 5-7 논리 오류

----------------------------------------------------------------------------------------

## 5-8 평가

----------------------------------------------------------------------------------------

## 5-9 디버깅

----------------------------------------------------------------------------------------

## 5-10 사전 조건과 사후 조건
