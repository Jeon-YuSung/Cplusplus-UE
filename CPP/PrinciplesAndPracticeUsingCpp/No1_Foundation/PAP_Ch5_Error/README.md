# Ch 5 오류 (Error)

##  5.1 개요 - 오류 분류 
오류 없는 완벽한 프로그램은 없다. 오류를 완전히 피활 수 없지만, 완성된 프로그램은 오류가 전혀 없거나, 적어도 받아들일 수 없다고 치부되는 오류를 포함해서는 안된다.

오류를 분류하는 다양한 방법은 다음과 같다.
1. 컴파일 시간 오류(Compile-Time Error) : 컴파일러가 찾아낸 오류로, 컴파일 시간 오류는 해당 오류가 위반한 언어의 규칙에 따라 더 세부적으로 나눌 수 있음.
   - 문법 오류
   - 타입 오류
   
2. 링크 시간 오류(Linker Error) : 목적 파일을 실행 프로그램에 통합하는 과정에서 링커가 찾아낸 오류
3. 실행 시간 오류(Run-Time Error) : 프로그램을 실행하는 동안 확인된 오류로, 이 또한 더 세부적으로 나눌 수 있다.
   - 컴퓨터(HW or OS)가 감지한 오류
   - 라이브러리가 감지한 오류
   - 사용자 코드가 감지한 오류
4. 논리 오류(Logic Error) : 프로그래머가 잘못된 결과의 원인을 분석하는 과정에서 찾아낸 오류.

모든 오류를 제거하는 것은 불가능하다. 하지만 프로그램이 손상되어도 시스템의 어딘가에서 적절한 조치를 취해줄 수 있다. <br>
즉, 핵심은 **이 프로그램이 그런 오류를 감지해야하는가?** 라고 할 수 있고, 우리는 프로그램에 대해 다음과 같이 정의한다.
1. 모든 적법한 입력에 대해 요구받은 결과를 생성한다.
2. 모든 적법하지 않은 입력에 대해 적절한 오류 메시지를 출력한다.
3. 하드웨어의 오동작은 고려하지 않는다.
4. 시스템 소프트웨어의 오동작은 고려하지 않는다.
5. 오류를 감지한 후에는 종료해도 좋다.

3,4,5번 가정을 만족하지 않은 모든 프로그램은 진보된 프로그램이라고 생각하면 된다. 반면 1,2번 가정은 가장 기본적이고 프로그래머가 추구해야할 목표이다. <br>
그럼 **오류를 어떻게 처리해야할까?** 오류를 잘 처리하고, 기본적으로 적절한 수준의 소프트웨어를 만들기 위해서 다음과 같은 3가지 접근 방법을 항상 생각하자.
1. 소프트웨어를 조직화해서 오류를 최소화한다.
2. 우리가 만든 대부분의 오류를 테스트와 디버깅을 바탕으로 제거한다.
3. 남아있는 오류는 사소한 오류임을 확인하다.

항상 올바르게 작동하는 프로그램이 목표이기에 거기에 달성할 수 있도록 노력하자. 

--------------------------------------------------------------
## 5-2 오류의 원인 
이제 오류가 생기는 이유를 알아보자. 
1. 엉터리 명세 : 프로그램이 해야 할 일을 정확히 명시하지 않으면, 사각 지대를 제대로 확인하고, 모든 경우를 처리했는지 알기 어렵다.
2. 불완전한 프로그램 : 개발 과정에서 고려하지 않은 경우가 있을 수 있다. 이를 피할 수 없겠지만, 적어도 모든 경우를 처리했음을 확인하는 일을 목표로 삼아야한다.
3. 예상 밖의 인자(Argument) : 함수는 인자를 받아들이며, 우리가 처리하지 않은 인자가 함수에 전달되면 문제가 된다.
4. 예상 밖의 입력 : 일반적으로 프로그램은 데이터를 읽는다. 프로그램은 이러한 입력에 대해 많은 가정을 하지만, 예상 밖의 입력이 들어오면 문제가 생긴다
```cpp
int a;
cin >> a;
//근데 정수형 20 대신에 "Hello"를 넣어봐라 
```
5. 예상 밖의 상태 : 대부분의 프로그램은 시스템의 서로 다른 부분에서 사용할 데이터(상태)를 유지한다. 주소 목록, 전화번호부, 온도 측정 결과를 저장하는 Vector 등... 근데 그런 데이터가 불완전하거나 틀렸다면 어찌할까? 이건 추후에 26장에서 다룬다.
6. 논리 오류 : 코드가 의도한대로 작동하지 않은 경우를 말하고, 이런 문제는 찾아서 고칠 수 밖에 없다, 6장에서 다룬다. 
**이 목록은 실용적으로 쓸모가 있다** 즉, 프로그램을 어느정도 확인해야 하는지 알려주는 CheckList로 사용할 수 있다.

잠재적인 오류의 원인을 모두 고려하지 않으면 그 어떤 프로그램도 완벽하지 않다.

-------------------------------------------------------------------------

## 5-3 컴파일 시간 오류(Compile Time Error)
컴파일러는 목적 코드를 생성하기 전에 코드를 분석해서 문법 오류와 타입 오류를 찾아낸다. <br>
즉, 프로그램이 언어의 명세에 '완전히' 부합할 때만 다음 과정을 진행 할 수 있고, 컴파일러가 찾아내는 오류 중 대다수는 편집 미완료로 인한 **단순 실수 오류**이다. 그 외의 오류는 프로그램의 각 부분이 상호작용하는 방법을 잘못 이해하는데서 오는 결함이다. 

```cpp
int area(int length, int width){
   return length * width; 
}

int maind(void){
   int s1 = area(7; // )누락 
   int s2 = area(7) // ;누락
   Int s3 = area(7); // Int는 타입이 아님
   int s4 = area('7); //종료하지 않은 문자 '누락
return 0;
}
```
위의 코드는 모두 문법 오류가 포함 된 코드이다. 즉, C++ 문법에 부합하지 않는 코드를 컴파일러가 거부한다. <br>
또한, 문법 오류가 발생한 경우에 컴파일러가 지적한 행에서 문제를 찾을 수 없다면 프로그램의 이전 행을 살펴보자. <br>
그리고 컴파일러는 있는 프로그래머가 짠 의도를 알 수 없기 때문에, 그대로 보이는대로 오류를 잡을수 밖에 없다. 

이제 문법 오류를 제거하면 컴파일러는 타입 오류를 잡기 시작한다. <br>
즉, 프로그래머가 선언한 변수, 함수 등의 타입과 표현식, 인자 등의 타입이 일치하지 않은 경우를 보여준다.  

```cpp
   int x0 = arean(7,2); //선언하지 않은 함수
   int x1 = area(7); // 인자 혹은 매개변수의 수가 맞지 않음
   int x2 = area("seven",2); //첫번째 매개변수의 타입이 다름
```

오류가 아닌 경우가 있는데, 컴파일러가 보고하는 오류 중 일부를 오류가 아니라고 생각할 수 있다. <br> 
즉 문법적으로, 혹은 타입적으로 옳지만 논리적 오류가 발생하는 경우이다. <br>
```cpp
   int x4 = area(10,-7); // 문법적으로, 타입적으로 옳음 그러나 너비가 -70인 사각형이 있을까? 
   int x5 = area(10.7, 9.3); // int 정수형 타입으로 소수점을 버리고 10, 9를 호출
   char x6 = area(100, 9999); // 결과를 축소 변환 
```
 x4를 봐라 int는 unsigned int가 아니라면, 음수 부터 정수까지 표현 할 수 있다 (unsigned int 는 양수만 표현) 그러니 컴파일러 입장에서는 저건 틀린 문법이 아니기에 오류라고 하지 않는다. <br>
 x5는 컴파일러가 좋은거라면 10.7, 9.3이 정수 10, 9로 축소 변환한다고 경고하지만, double or float를 int로 축소 변환을 할 수 있기 때문에 이또한 오류라고 하지 않는다 <br>
 x6는 결과를 char 대입하는데, 여기서 결과로 가장 가능성이 큰 값은 축소 변환된 값 -36이고, 컴파일러는 이를 오류라고 잡아주지 않는다 <br>

 **내 프로그램이 컴파일 되었다고** 프로그램이 실행되는 것을 의미하지 않고, 실행된다고 해도 논리적 결함을 찾아내기 전에는 잘못된 결과가 나오기 마련이다. 

 -------------------------------------------------------------------------

## 5-4 링크 시간 오류 
프로그램은 변환 단위라고 일컬어지는 분리돼 컴파일된 다수의 부분으로 이뤄진다. <br>
한 프로그램 안의 모든 함수는 그 함수를 사용하는 모든 변환 단위에서 동일한 타입으로 선언되어야하며, 이를 보장하기위해 헤더 파일을 이용한다. <br>
그러나 **모든 함수는 한 프로그램 안에서 딱 한 번 정의되어야 한다.** 두 규칙중 하나라도 위반하면 링커 오류가 난다. <br>
그리고, 함수 이름에 오타가 있는 경우는 링컥 오류를 보고하지 않는다, 대신 컴파일러가 선언하지 않은 함수를 발견하는 즉시 오류를 일으킨다. <br> 
함수 링크 규칙은 변수와 타입을 비롯한 프로그램의 모든 구성 요소에도 동일하게 적용되니깐 꼭 기억하자.
1. 동일한 이름의 구성 요소는 **딱 한 번** 정의돼야 한다.
2. 선언은 여러번 할 수 있지만, 모든 선언의 타입은 정의한 타입과 **일치**해야한다.

----------------------------------------------------------------------------------------

## 5-5 실행시간 오류 
이제 컴파일 시간 오류와 링크 시간 오류에서 문제가 없다면, 프로그램을 실행할 수 있다. <br>
프로그램을 작성할 때 오류를 찾을 수 있지만, 실행 중에 감지한 오류를 처리하는 방법을 알아내기란 항상 쉽지 않다. 
```cpp
int area(int len, int wid){
   return len * wid;
}

int framed_area(int x, int y){
   return area(x - 2, y - 2);
}

int main(void){
   int x = -1;
   int y = 2;
   int z = 4;

   int area1 = area(x,y);
   int area2 = framed_area(1,z);
   int area3 = framed_area(y,z);
   double ratio = double(area1)/area3;

   return 0;
}
```
위의 코드를 봐라, area1과 area2는 음수가 대입이 되는데, 이 오류를 용인해야할까? 아니면 오류를 찾아내야할까? 만약에 오류를 찾아내야한다면 어디서 찾아야하는가? <br>
그리고 ratio에서의 결함을 찾아보자. area3의 값은 0이므로, 하드웨어 감지 오류가 발생하여 프로그램이 종료된다. <br>
그럼 어떻게 해결해볼까? 일단 area함수쪽 argument에 관한 오류를 고쳐보자. 
1. area함수를 호출하는 쪽에서 잘못된 인자를 처리한다.
2. area함수의 안에서 잘못된 인자를 처리한다.

그럼 1번 대안인 **호출하는 쪽(caller)에서의 오류처리**에 대해 보자. 
area()가 라이브러리안에 포함된 ㅎ재적인 오류의 원인을 모두 고려하지 않으면 그 어떤 프로그램도 완벽하지 않다.

-------------------------------------------------------------------------

## 5-3 컴파일 시간 오류(Compile Time Error)
컴파일러는 목적 코드를 생성하기 전에 코드를 분석해서 문법 오류와 타입 오류를 찾아낸다. <br>
즉, 프로그램이 언어의 명세에 '완전히' 부합할 때만 다음 과정을 진행 할 수 있고, 컴파일러가 찾아내는 오류 중 대다수는 편집 미완료로 인한 **단순 실수 오류**이다. 그 외의 오류는 프로그램의 각 부분이 상호작용하는 방법을 잘못 이해하는데서 오는 결함이다. 

```cpp
int area(int length, int width){
   return length * width; 
}

int maind(void){
   int s1 = area(7; // )누락 
   int s2 = area(7) // ;누락
   Int s3 = area(7); // Int는 타입이 아님
   int s4 = area('7); //종료하지 않은 문자 '누락
return 0;
}
```
위의 코드는 모두 문법 오류가 포함 된 코드이다. 즉, C++ 문법에 부합하지 않는 코드를 컴파일러가 거부한다. <br>
또한, 문법 오류가 발생한 경우에 컴파일러가 지적한 행에서 문제를 찾을 수 없다면 프로그램의 이전 행을 살펴보자. <br>
그리고 컴파일러는 있는 프로그래머가 짠 의도를 알 수 없기 때문에, 그대로 보이는대로 오류를 잡을수 밖에 없다. 

이제 문법 오류를 제거하면 컴파일러는 타입 오류를 잡기 시작한다. <br>
즉, 프로그래머가 선언한 변수, 함수 등의 타입과 표현식, 인자 등의 타입이 일치하지 않은 경우를 보여준다.  

```cpp
   int x0 = arean(7,2); //선언하지 않은 함수
   int x1 = area(7); // 인자 혹은 매개변수의 수가 맞지 않음
   int x2 = area("seven",2); //첫번째 매개변수의 타입이 다름
```

오류가 아닌 경우가 있는데, 컴파일러가 보고하는 오류 중 일부를 오류가 아니라고 생각할 수 있다. <br> 
즉 문법적으로, 혹은 타입적으로 옳지만 논리적 오류가 발생하는 경우이다. <br>
```cpp
   int x4 = area(10,-7); // 문법적으로, 타입적으로 옳음 그러나 너비가 -70인 사각형이 있을까? 
   int x5 = area(10.7, 9.3); // int 정수형 타입으로 소수점을 버리고 10, 9를 호출
   char x6 = area(100, 9999); // 결과를 축소 변환 
```
 x4를 봐라 int는 unsigned int가 아니라면, 음수 부터 정수까지 표현 할 수 있다 (unsigned int 는 양수만 표현) 그러니 컴파일러 입장에서는 저건 틀린 문법이 아니기에 오류라고 하지 않는다. <br>
 x5는 컴파일러가 좋은거라면 10.7, 9.3이 정수 10, 9로 축소 변환한다고 경고하지만, double or float를 int로 축소 변환을 할 수 있기 때문에 이또한 오류라고 하지 않는다 <br>
 x6는 결과를 char 대입하는데, 여기서 결과로 가장 가능성이 큰 값은 축소 변환된 값 -36이고, 컴파일러는 이를 오류라고 잡아주지 않는다 <br>

 **내 프로그램이 컴파일 되었다고** 프로그램이 실행되는 것을 의미하지 않고, 실행된다고 해도 논리적 결함을 찾아내기 전에는 잘못된 결과가 나오기 마련이다. 

 -------------------------------------------------------------------------

## 5-4 링크 시간 오류 
프로그램은 변환 단위라고 일컬어지는 분리돼 컴파일된 다수의 부분으로 이뤄진다. <br>
한 프로그램 안의 모든 함수는 그 함수를 사용하는 모든 변환 단위에서 동일한 타입으로 선언되어야하며, 이를 보장하기위해 헤더 파일을 이용한다. <br>
그러나 **모든 함수는 한 프로그램 안에서 딱 한 번 정의되어야 한다.** 두 규칙중 하나라도 위반하면 링커 오류가 난다. <br>
그리고, 함수 이름에 오타가 있는 경우는 링컥 오류를 보고하지 않는다, 대신 컴파일러가 선언하지 않은 함수를 발견하는 즉시 오류를 일으킨다. <br> 
함수 링크 규칙은 변수와 타입을 비롯한 프로그램의 모든 구성 요소에도 동일하게 적용되니깐 꼭 기억하자.
1. 동일한 이름의 구성 요소는 **딱 한 번** 정의돼야 한다.
2. 선언은 여러번 할 수 있지만, 모든 선언의 타입은 정의한 타입과 **일치**해야한다.

----------------------------------------------------------------------------------------

## 5-5 실행시간 오류 
이제 컴파일 시간 오류와 링크 시간 오류에서 문제가 없다면, 프로그램을 실행할 수 있다. <br>
프로그램을 작성할 때 오류를 찾을 수 있지만, 실행 중에 감지한 오류를 처리하는 방법을 알아내기란 항상 쉽지 않다. 
```cpp
int area(int len, int wid){
   return len * wid;
}

int framed_area(int x, int y){
   return area(x - 2, y - 2);
}

int main(void){
   int x = -1;
   int y = 2;
   int z = 4;

   int area1 = area(x,y);
   int area2 = framed_area(1,z);
   int area3 = framed_area(y,z);
   double ratio = double(area1)/area3;

   return 0;
}
```
위의 코드를 봐라, area1과 area2는 음수가 대입이 되는데, 이 오류를 용인해야할까? 아니면 오류를 찾아내야할까? 만약에 오류를 찾아내야한다면 어디서 찾아야하는가? <br>
그리고 ratio에서의 결함을 찾아보자. area3의 값은 0이므로, 하드웨어 감지 오류가 발생하여 프로그램이 종료된다. <br>
그럼 어떻게 해결해볼까? 일단 area함수쪽 argument에 관한 오류를 고쳐보자. 
1. area함수를 호출하는 쪽에서 잘못된 인자를 처리한다.
2. area함수의 안에서 잘못된 인자를 처리한다.

그럼 1번 대안인 **호출하는 쪽(caller)에서의 오류처리**에 대해 보자. 
area()가 라이브러리안에 포함되어 있는 경우, 즉 프로그래머가 직접 수정할 수 없는 경우에는 이 대안을 선택한다<br>
```cpp
if(x<=0) {
   error("x가 양수가 아님);
}

if(y<=0) {
   error("y는 양수가 아님);
}
int area1 = area(x,y);
```
오류를 감지했을 때, error함수로 통해 처리한다. 이 함수는 std_lib_facilities.h에 포함된 함수로 기본적으로 시스템 오류 메시지와 인자로 전달된 문자열을 함께 출력하고나서 프로그램을 종료하는 방법이다. 
참고로 C++자체에서는 error함수가 **없어** error를 통한 예외처리가 불가능하니, runtime_error 클래스 같은걸 사용해야한다 (편의상 책에 있는 건 대부분 std_lib_facilities.h에 포함되어 있을거다, 그리고 C++11을 요구하니 C++26까지 나온 시점에서 다를 수 있다.) <br>
**std::exception나 try-catch를 통한 throw 키워드를 입력해서 예외처리를 해야한다. 그리고, stdexcept 클래스안에 있는 domain_error, runtime_error등.. 다양한 클래스를 통해서 예외를 처리해야한다.** (5.6항목을 참고) <br>
즉, std_lib_facilities.h에 의존하지말고, 직접 <iostream>이나 <string>, <vector>를 선언해서 포함시시키고 error가 아닌 다른걸로 예외처리 해보자 

2번째 방법인 **호출되는 쪽(callee)에서의 오류 처리**에 대해 알아보자 
framed_area안에서 argument가 올바른지 확인해서 처리하는 방법이다. 
```cpp
framed_area(int x, int y){
   constexpr int fWidth = 2;
    try {
        if (x - fWidth <= 0 || y - fWidth <= 0) {
            throw runtime_error("framed_area(): invalid arguments (non-positive dimensions).");
        }
        return area(x - fWidth, y - fWidth);
    }
    catch (const runtime_error& e) {
        cerr << "Caught exception in framed_area: " << e.what() << endl;
        return -1; // 오류 상황일 때 특별한 값 반환 
    }
}
```
   이런 방법을 사용하면 framed_area호출 할 때마다 확인하는 코드를 작성할 필요가 없고, 계속 호출해야하는 경우에도 유용하다, 그리고 오류 처리 방법이 변경되더라도 저 함수 안에서 수정을 하면 되니까 좋다. <br>
이 방법은 argument 확인 코드가 한 곳에만 있기 때문에 프로그램 전체를 흝어볼 필요가 없다는거고, 인자를 확인하는데 필요한 모든 정보를 사용할 수 있다. 

근데, 함수 안에서 인자를 확인하는건 간단한 일인데도, 왜 항상 이렇게 하지 않은 이유가 뭘까?  <br>
부주의하거나 서투름이 있어서 그럴 수도 있으나, 그럴만한 이유가 있을 수 도 있기 때문이다.
1. 함수 정의를 수정할 수 없다. <br>
→ 라이브러리 안의 함수철머 함수를 변경할 수 없는 경우가 있고, 타인과 코드를 함께 사용하거나 소스 코드가 다른 사람의 소유일수도 있고 아니면 정기적으로 새로운 버전을 출시하는 라이브러리안에 함수가 포함돼 새로운 라이브러리 배포판이 나올 때 마다 변경이 필요할 수도 있기 때문이다.

2. 호출되는 함수 안에서 오류를 어떻게 처리할지 알 수 없다. <br>
→ 대부분 라이브러리가 이에 속함, 라이브러리 제작자가 오류를 감지할 수는 있지만, 오류가 발생하면 프로그래머가 무슨 일을 해야 할지 알아야하기 때문이다.
 
3. 호출되는 함수가 자신을 어디서 호출했는지 알 수 없다. <br>
→ 오류 메시지를 출력하면 뭔가 문제가 있음을 알수 있지만, 실행 중인 프로그램이 어떤 경로로 오류를 냈는지 알 수 없을 때, 이 경우에는 구체적인 오류 메시지가 필요할 수도 있다.

4. 성능 <br>
→ 작은 함수에서는 argument를 확인하는 코드의 비용이 결과를 계산하는 비용보다 클 수도 있다.
프로그램에 따라서 치명적인 문제가 될 수 있는데, 특히 여러 함수가 변하지 않는 정보를 바탕으로 서로를 호출할 때 동일한 정보를 불필요하게 확인할 수 도 있다.

특별한 이유가 없으면 함수 안에서 인자를 확인하는걸 추천한다. 

**오류 보고** <br>
일련의 인자를 확인해서, 오류를 찾아냈다면 다음은 무슨일을 해야할까? <br>
때에 따라서는 error value를 반환할 수 있다. 
```cpp
char ask_use(string question){
   string answer = "";
   cout << question << "? (yes or no)\n";
   cin >> answer;
   if(answer == "y" || answer == "yes") {
      return 'y';
   }
   if(answer == "n" || answer == "no"){
      return 'n';
   }
   return 'b'; 
}

int area(int len, int wid){
   if(len <= 0 || wid <= 0) return -1;
   return len * wid;
}
```
호출되는 쪽에서 세세하게 확인함은 물론, 호출하는 쪽의 필요에 따라 오류를 처리할 수 있다. 하지만, 이 방법을 선택할 수 없는 몇 가지 이유도 존재한다. 

- 호출되는 함수와 호출하는 쪽 모두 확인을 해야한다. 호출하는 쪽의 확인 작업은 간단하지만, 여전히 확인을 한 후 실패 시에 어떻게 할지 정해야한다.
- 호출하는 쪽에서 확인을 잊을 수도 있다. 이럴 경우 프로그램을 실행할 때 결과를 예측할 수 없다.
- 오류를 나타내는 값으로 사용할 여분의 반환 값이 없는 함수도 많다. 예를 들어 입력에서 int를 읽어, 반환하는 함수는 임의의 int 값을 반환할 수 있으므로 실패를 나타낼 용도로 쓸 수 있는 int 값이 없다.

```cpp
int f(int x, int y, int z){
   int area1 = area(x,y);
   if(area1 <=0) error("음수가 아닌 넓이") ; //error함수는 없다 다른걸로 throw통한 예외처리 할것
   int area2 = framed_area(1,z);
   int area3 = framed_area(y,z);
   double ratio = double(area1)/area3;
}
```
오류가 있을까? 없을까? <br>
확인의 부재로 인한 오류는 겉보기에는 틀린점이 없어 보이기 떄문에 찾아내기 어렵다. <br>
이제 예외에 대해 알아보자. 

----------------------------------------------------------------------------------------

## 5-6 예외(exception)

----------------------------------------------------------------------------------------

## 5-7 논리 오류

----------------------------------------------------------------------------------------

## 5-8 평가

----------------------------------------------------------------------------------------

## 5-9 디버깅

----------------------------------------------------------------------------------------

## 5-10 사전 조건과 사후 조건
