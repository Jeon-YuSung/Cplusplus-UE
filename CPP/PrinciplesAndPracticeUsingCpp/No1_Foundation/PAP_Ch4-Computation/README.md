# Ch-4 계산

계산(computation)의 기초에 대해 알아보는 챕터. 

-------------------------------------------------------

## Ch-4.1 계산(Computaion)
 프로그램이 하는 일은 **그저 계산**만 한다 즉, 어떤 입력을 받아 그에 대한 출력을 하는 것이다. <br>
프로그램은 일반적으로 입력을 처리하는 데 필요한 데이터를 포함 하며, 이를 일컬어 **자료구조(Data structure)나 상태(State)** 라고 한다. <br>
다양하게 입력을 하는 만큼, 출력의 목적지도 다양하다. 모니터, 파일, 네트워크, 프린터기, 다른 프로그램, 음악 신디사이저... 등등 <br>
 프로그래밍의 관점에서 가장 중요한 것은 **입출력 출처는 '다른 프로그램'과 '같은 프로그램의 다른 부분'** 이다. 프로그램을 어떻게 서로 협력하는 부분의 집합으로 표현할까?, 각 부분들 사이에서 어떻게 데이터를 공유하고 교환하는가? → 이런 질문들이 프로그래밍의 핵심이라고 할 수 있다. 

--------------------------------------------------------
## Ch-4.2 목적과 도구(Goal and Tool)
 프로그래머라는 직업의 목적은 계산 과정을 다음과 같은 방법으로 표현하는 데 있다.
 
 1. 정확하게
 2. 단순하게
 3. 효율적으로

특히, 위의 3가지의 순서가 중요하다, 프로그램이 아무리 빨라도 결과가 올바르지 않다면 아무런 의미가 없는거고, 혹은 정확하고 효율적인 프로그램이라도 너무 복잡하다면 새로운 버전으로 출시할 때, 전체적인 수정이 필요할 수 도 있다. 유용한 프로그램일수록 새로운 요구 사항과 하드웨어 등을 고려한 수정이 필요하다는 사실을 기억하자.

전문가가 되기 위해선... 누군가가 사용할 코드를 정확하고 단순하게 그리고 효율적으로 만들고 그걸 유지하고 보수해야한다. 실용적인 관점에서 그냥 돌아가는 코드를 아무렇게나 휘갈겨 만들 수 없지만, 모순적이게도 **구조를 생각하고, 코드의 품질을 고려하는 일**이 작업을 빠르게 끝내는 방법이다. <br>
추후에, 가장 힘든 과정인 **디버깅을 최소화**할 수 있기 때문이다.

프로그램을 잘 조직화하고, 프로그램으로 작성할 프로그래머의 생각을 정리하고자할 때, 사용할 수 있는 방법이 **큰 계산을 작은 다수의 과정으로 나누는 방법**이고, 이 과정에는 2가지 개념이 포함된다. 

1. **추상화 (Abstraction)** <br>
   → 직접 사용할 필요가 없는 상세한 내부 동작(상세 구현)은 편리하고 일반적인 인터페이스 뒤에 숨긴다. 예를들어 무언가를 정렬할 때 직접 구현하지 않고도 C++표쥰 라이브러리의 sort 알고리즘을 호출하여 사용하는 것 처럼 또는 컴퓨터 메모리를 사용하는 방식을 할 때, 메모리에 직접 접근하지 않고도 vector나 map등을 사용하는 것처럼
   
2. **분할 정복(Divide and Conquer)** <br>
   → 덩치 큰 문제는 더 작은 문제 여러 개로 나눌 수 있다. 예를 들어 사전을 만드는 작업은 데이터를 읽고, 읽은 데이터를 정렬하고, 정렬한 데이터를 출력하는 3가지 작업으로 나눌 수 있고, 이 3가지 작업은 원래의 거대한 하나의 작업보다 훨씬 작다.

 이러한 접근법이 도움이 되는 이유는 단순하다. 사람은 덩치큰 문제를 한방에 풀수 없기에, 그리고 프로그램을 큰 하나의 덩어리로 관리하고, 유지보수할 수 없기 때문이다. <br>
프로그램을 분할 할 때는 어떤 도구를 사용해서 분할된 각 부분 사이에서의 통신을 표현할 수 있을지를 항상 고민하면서 프로그램을 설계하는 것이 바람직하다. <br>
**구조와 조직화**를 강조한 이유는 단순하다. 긴 코드(or 하드 코딩)을 하는 것은 바람직하지도 않고, 좋은 코드(클린 코드)를 만들 수 없기 때문이다. 그렇기 때문에, SW개발에 있어 추상적이고 개념적인 부분을 중요하게 여겨야하고, 구조에 대한 고려가 좋은 소프트웨어의 핵심이고 구조를 무시하면 엄청난 큰 한 덩어리의 프로그램이 만들어지기 때문에 유지보수하기에 어렵다.

---------------------------------------------------------------------

## Ch-4.3 표현식(Expression)
 표현식(Expression)은 프로그램의 가장 기본적인 구성 요소로서, 피연산자의 값으로 부터 결과 값을 계산하는 것이다. 10, 'a', 3.141592, "Vidan" 등의 단순한 리터럴 값들도 표현식에 속하고, 변수의 이름도 표현식이며 변수는 해당 이름으로 명명된 객체이다. 

```cpp
int length = 20; //정수 리터럴을 이용해서 변수 length를 초기화 했다. 
int width = 40; // width라는 이름의 객체에 값 40으로 저장한다.
int area;

area = length * width;
cout << "넓이 = " << area << endl; 
```

이제 length의 값을 바꿔보자 

```cpp
length = 99;
```
이러면 length 값에 20이 아니라 90이 저장 될 것이다.  <br>
또 다른 코드를 보자 

```cpp
int length = 30; //정수 리터럴을 이용해서 변수 length를 초기화 했다. 
int width = 30;

int perimeter1 = (lenthg+width) * 2;
름의 상수를 사용하는 걸 권장한다. 코드에서 사용된 명확하지 않은 리터럴은 마법의 상수(Magic Constants)라고 부르기도 한다. <br>
참고로 constexpr로 정의하는 기호 상수는 **반드시 컴파일 시점에 값을 알 수 있어야 한다** 컴파일 시점에 값을 미리 알 수 없는 변수로 초기화되지만, 초기화 이후로는 값을 변경할 수 없게 하고 싶다면 const를 사용하자

```cpp
constexpr int max = 100;
void use(int n){
 constexpr int c1 = max + 7; // c1은 107
 const int c2 = n + 7;  // 가능 그러나 c2의 값을 바꿀 수 없다

 c2 = 7; // 오류 c2는 const이기에 
}
```
const는 C++98에서 혹은 상수 표현식이 아니지만(컴파일 시점에 값을 알 수 없지만), 초기화 이후로는 값을 변경할 수 없는 변수가 필요한 경우에 사용한다. 

**constexpr와 const차이점** 

 앞서 말해듯이 constexpr는 compile-time에 모든 값들이 확정되어 있어야하고 그 값들은 변하지 않는다. 하지만 const는 compile-time에는 값이 정해져 있지 않아도 되지만, 할당 후에는 값이 변해서는 안된다. <br>
둘의 공통점은 **할당된 후 값을 변경하면 안됨** 이고, 차이점은 할당시기에 있다.  constexpr는 compile-time시기에 확정되어야하고, 
const의 할당은 compile-time, run-time이든 아무 때나 해도 되지만, 코드에는 어떤 값이 할당 되도록 코드가 쓰여야한다. 

**변환**

한 표현식에서 여러 타입을 함께 사용할 수 있다. 예를 들어 double이나 float에서 int로 값을 나누면 int는 소수점을 버리기 때문에 정수 값만 나오고, 부동소수점 나눗셈에서의 나눗셈은 소수점이 표현된다. <br> 

 type(value)와 type{value}는 "타입이 type인 변수를 value의 값으로 초기화할 때처럼 value를 type으로 변환하라는 의미이다. <br>
 즉, 필요하다면 int 피연산자를 double로, char 연산자를 int로 변환(확장)하라는 의미 있다. <br>
 type{value}는 축소 변환을 방지할 수 있지만 type(value)는 축소 변환을 방지 하지 않는다. <br>
 그렇기 때문에, 결과를 계산 한 후에는 초기 값이나 대입문의 우측에 사용하기위해 다시 변환을 수행한다. 다음 코드를 보자 
 
```cpp
doulbe d = 2.5;
int i = 2;

double d2 = d/i; // d2 == 1.25
int i2 = d/i; // i2 == 1
int i3 {d/i}; // Error : double → int는 축소 변환
```

그리고 부동소수점 피연산자를 포함한 표현식에서도 정수 나눗셈이 일어날 수 있다. 섭씨를 화씨로 바꾸는 f = 9/5 * c + 32를 구현한 다음 코드를 보자 

```cpp
double dc;
cin >> dc;

double df;
df = 9 / 5 * dc + 32; // 주의
```
위의 코드는 정확한 온도 단위 변환을 수행하지 않는다. df = 9 / 5 * dc + 32; 에서  9/5의 결과가 1.8이 아니라 1로 나오기 때문이다. 수학적으로 정확히 표현하려면 9나 5(혹은 모두)를 double로 바꿔야한다. 

```cpp
df = 9.0 / 5 * dc + 32; //개선된 코드  
```

-------------------------------------------------------------------

## Ch-4.4 구문(Statement)

 구문(Statement)은 크게 2개 가지 구문으로 나눌 수 있다. <br>
 1. **표현식 구문** <br>
    → 말 그대로 세미콜론으로 끝나는 식을 뜻한다.
```cpp
a = b;
++b;
c++;
```
=가 대입연산자로 a = b 자체로 표현식이지만, **Statement**가 될려면 **;(세미콜론)**을 꼭 붙여야한다. 그럼 왜 세미콜론이 필요할까? <br>
답은 단순한데, 컴파일러가 프로그래머의 의도를 알 수 없기 때문이다. <br>
그리고 여러 구문이 연달아 있으면 컴퓨터는 작성된 순서대로 구문을 실행한다.
```cpp
int a = 7;
cout << a << endl; 
```
초기화를 포함한 선언문이 출력 표현식 구문보다 먼저 실행된다. <br>
이제 다음 코드를 보자
```cpp
1+2;
a*b;
```
위의 코드는 논리 오류로, 효과 없는 구문으로 컴퍼일러는 경고를 남긴다. <br>
즉, 표현식 구문은 대체적으로 I/O 구문, 함수 호출문 중 하나이다. 

 2. **빈 구문(Empty Statement)** <br>
```cpp
if (x == 5);
{ y = 3; }
```
위의 코드는 오류처럼 보이지만, **합법**이다. 즉, C++에서 이 코드는 적법하다. 이러한 구문을 빈 구문이라고하며, 아무일도 하지 않는다. <br>
드물게 빈 구문이 유용한 경우도 있지만 진짜 거의 드물다.

**조건문** <br>
책에서는 **선택문** 이라고 나와있으니, 선택문이라고도 알고있자, 영어 그대로 문법 단어를 알면 좋고 한국어로 알거면 **같은 뜻, 같은 의미, 다른 단어** 가 있다는 것도 알아두자, 대표적으로 클래스에서의 부모클래스, 자식클래스인데, 부모클래스는 슈퍼, 베이스수는 코드의 가독성 유지에 도움이된다. 그리고 코드의 어디서든 리터럴 사용은 피해야하고, 그 대신 설명적인 읾의 상수를 사용하는 걸 권장한다. 코드에서 사용된 명확하지 않은 리터럴은 마법의 상수(Magic Constants)라고 부르기도 한다. <br>
참고로 constexpr로 정의하는 기호 상수는 **반드시 컴파일 시점에 값을 알 수 있어야 한다** 컴파일 시점에 값을 미리 알 수 없는 변수로 초기화되지만, 초기화 이후로는 값을 변경할 수 없게 하고 싶다면 const를 사용하자

```cpp
constexpr int max = 100;
void use(int n){
 constexpr int c1 = max + 7; // c1은 107
 const int c2 = n + 7;  // 가능 그러나 c2의 값을 바꿀 수 없다

 c2 = 7; // 오류 c2는 const이기에 
}
```
const는 C++98에서 혹은 상수 표현식이 아니지만(컴파일 시점에 값을 알 수 없지만), 초기화 이후로는 값을 변경할 수 없는 변수가 필요한 경우에 사용한다. 

**constexpr와 const차이점** 

 앞서 말해듯이 constexpr는 compile-time에 모든 값들이 확정되어 있어야하고 그 값들은 변하지 않는다. 하지만 const는 compile-time에는 값이 정해져 있지 않아도 되지만, 할당 후에는 값이 변해서는 안된다. <br>
둘의 공통점은 **할당된 후 값을 변경하면 안됨** 이고, 차이점은 할당시기에 있다.  constexpr는 compile-time시기에 확정되어야하고, 
const의 할당은 compile-time, run-time이든 아무 때나 해도 되지만, 코드에는 어떤 값이 할당 되도록 코드가 쓰여야한다. 

**변환**

한 표현식에서 여러 타입을 함께 사용할 수 있다. 예를 들어 double이나 float에서 int로 값을 나누면 int는 소수점을 버리기 때문에 정수 값만 나오고, 부동소수점 나눗셈에서의 나눗셈은 소수점이 표현된다. <br> 

 type(value)와 type{value}는 "타입이 type인 변수를 value의 값으로 초기화할 때처럼 value를 type으로 변환하라는 의미이다. <br>
 즉, 필요하다면 int 피연산자를 double로, char 연산자를 int로 변환(확장)하라는 의미 있다. <br>
 type{value}는 축소 변환을 방지할 수 있지만 type(value)는 축소 변환을 방지 하지 않는다. <br>
 그렇기 때문에, 결과를 계산 한 후에는 초기 값이나 대입문의 우측에 사용하기위해 다시 변환을 수행한다. 다음 코드를 보자 
 
```cpp
doulbe d = 2.5;
int i = 2;

double d2 = d/i; // d2 == 1.25
int i2 = d/i; // i2 == 1
int i3 {d/i}; // Error : double → int는 축소 변환
```

그리고 부동소수점 피연산자를 포함한 표현식에서도 정수 나눗셈이 일어날 수 있다. 섭씨를 화씨로 바꾸는 f = 9/5 * c + 32를 구현한 다음 코드를 보자 

```cpp
double dc;
cin >> dc;

double df;
df = 9 / 5 * dc + 32; // 주의
```
위의 코드는 정확한 온도 단위 변환을 수행하지 않는다. df = 9 / 5 * dc + 32; 에서  9/5의 결과가 1.8이 아니라 1로 나오기 때문이다. 수학적으로 정확히 표현하려면 9나 5(혹은 모두)를 double로 바꿔야한다. 

```cpp
df = 9.0 / 5 * dc + 32; //개선된 코드  
```

-------------------------------------------------------------------

## Ch-4.4 구문(Statement)

 구문(Statement)은 크게 2개 가지 구문으로 나눌 수 있다. <br>
 1. **표현식 구문** <br>
    → 말 그대로 세미콜론으로 끝나는 식을 뜻한다.
```cpp
a = b;
++b;
c++;
```
=가 대입연산자로 a = b 자체로 표현식이지만, **Statement**가 될려면 **;(세미콜론)**을 꼭 붙여야한다. 그럼 왜 세미콜론이 필요할까? <br>
답은 단순한데, 컴파일러가 프로그래머의 의도를 알 수 없기 때문이다. <br>
그리고 여러 구문이 연달아 있으면 컴퓨터는 작성된 순서대로 구문을 실행한다.
```cpp
int a = 7;
cout << a << endl; 
```
초기화를 포함한 선언문이 출력 표현식 구문보다 먼저 실행된다. <br>
이제 다음 코드를 보자
```cpp
1+2;
a*b;
```
위의 코드는 논리 오류로, 효과 없는 구문으로 컴퍼일러는 경고를 남긴다. <br>
즉, 표현식 구문은 대체적으로 I/O 구문, 함수 호출문 중 하나이다. 

 2. **빈 구문(Empty Statement)** <br>
```cpp
if (x == 5);
{ y = 3; }
```
위의 코드는 오류처럼 보이지만, **합법**이다. 즉, C++에서 이 코드는 적법하다. 이러한 구문을 빈 구문이라고하며, 아무일도 하지 않는다. <br>
드물게 빈 구문이 유용한 경우도 있지만 진짜 거의 드물다.

**조건문** <br>
책에서는 **선택문** 이라고 나와있으니, 선택문이라고도 알고있자, 영어 그대로 문법 단어를 알면 좋고 한국어로 알거면 **같은 뜻, 같은 의미, 다른 단어** 가 있다는 것도 알아두자, 대표적으로 클래스에서의 부모클래스, 자식클래스인데, 부모클래스는 슈퍼, 베이스(상위) 클래스라고도 하며, 자식클래스는 서브, 파생 클래스라고도 한다. 다시 본론으로 돌아가서 조건문에 대해 알아보자. 

1. **IF문**
```cpp
int a = 0;
int b = 0;
cout << "정수 2개를 입력 : ";
cin >> a >> b;

if (a < b) { 
 cout << "b가 a보다 큽니다 \n";
 cout << "b의 값 : " << b << " a의 값 : " << a <<enl;
} else{
 cout << "a의 값이 더 큽니다 \n";
 cout << "a의 값 : " << a << " b의 값 : " << b <<Endl;
}
```
→ if문은 조건이 맞으면 {}중괄호 안에 있는 코드를 실행한다, 만약에 {}가 앞으면 구문 하나 즉, ;나오는 부분까지 실행한다. <br>
위의 코드는 if-else문을 사용해서 구현한 코드인데, if문의 조건이 참(true)면 첫 번째 대안을 실행하고, 그렇지 않으면 else 다음인 두 번째 대안을 실행한다. 그리고 if-elseif-else문으로 구현이 가능해서 1번 조건이 아니면 다음 조건을 체크하고 2번 조건이 아니라면 다음 조건이나 else문으로가 실행한다. 이런식이면 복잡한 검사를 당연히 할 수 있지만, 코드는 복잡함이 아닌 단순함이 중요하다. 

2. **Switch문** <br>
```cpp
int a;
cin >> a 
switch(a){
 case 1:
 break;
 case 2:
 case 3:
 break;

 default:
 break;
}
```
switch문은 입력된 값에 따라 여러 분기(조건) 중 하나를 선택하여 실행하는 문법인데, break;를 넣어 분기 실행을 끝낼수 있다. <br>
만약 break;가 없으면, 다음 case로 흘러 내려가다가fall-through) break;를 만나면 분기를 빠져나간다. <br>
default은 case에 맞는 조건이 없으면 실행되는 곳이다. 
또한 같은 동작을 해야한다면 
```cpp
switch(a){
 case 1:
 case 2:
 case 3:
 break;

 default:
 break;
}
```
이런식으로 case을 한동작으로 지정해줄 수 있다. 

[if문과 switch문 코드와 설명 참고](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter4)

**반복(repetition or iteration)** <br>
어떤 일을 여러번 수행하는 동작 → 반복(repetition) <br>
자료구조에 포함된 일련의 요소(element)에 대해 같은 작업을 되풀이하는 일 → 반복(iteration) <br>
repetition과 iteration는 약간의 다른 의미를 가지고 있는데, repetition는 모든 반복 작업을 통칭하고, iteration는 주어진 자료 구조의 데이터를 하나씩 탐색하며, 각 데이터를 Argument로 연산을 수행하는 의미임. 

[반복문 코드 참고](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter5)

-------------------------------------------------------------------------

## Ch-4.5 함수(Function)

함수란 → 이름을 붙인 일련의 구문으로, 함수는 그 결과를 반환할 수 있음. <br>
함수 정의는 어디에나 올 수 있고, #include를 이용해서 함수 선언을 포함시킬 수 도 있음<br>

[함수 코드 참고](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter6)

-------------------------------------------------------------------------

## Ch-4.6 벡터(Vector)

가장 간단하고 논쟁의 여지가 없는 가장 유용한 데이터 저장 방식인 Vector는 Index로 접근할 수 있는 element의 sequence이다. 
STL의 일부이며 자주 쓰인다 

[STL 코드 참고](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter19)

-------------------------------------------------------------------------
