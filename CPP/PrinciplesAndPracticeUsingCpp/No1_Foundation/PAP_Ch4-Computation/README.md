# Ch-4 계산

계산(computation)의 기초에 대해 알아보는 챕터. 

-------------------------------------------------------

## Ch-4.1 계산(Computaion)
 프로그램이 하는 일은 **그저 계산**만 한다 즉, 어떤 입력을 받아 그에 대한 출력을 하는 것이다. <br>
프로그램은 일반적으로 입력을 처리하는 데 필요한 데이터를 포함 하며, 이를 일컬어 **자료구조(Data structure)나 상태(State)** 라고 한다. <br>
다양하게 입력을 하는 만큼, 출력의 목적지도 다양하다. 모니터, 파일, 네트워크, 프린터기, 다른 프로그램, 음악 신디사이저... 등등 <br>
 프로그래밍의 관점에서 가장 중요한 것은 **입출력 출처는 '다른 프로그램'과 '같은 프로그램의 다른 부분'** 이다. 프로그램을 어떻게 서로 협력하는 부분의 집합으로 표현할까?, 각 부분들 사이에서 어떻게 데이터를 공유하고 교환하는가? → 이런 질문들이 프로그래밍의 핵심이라고 할 수 있다. 

--------------------------------------------------------
## Ch-4.2 목적과 도구(Goal and Tool)
 프로그래머라는 직업의 목적은 계산 과정을 다음과 같은 방법으로 표현하는 데 있다.
 
 1. 정확하게
 2. 단순하게
 3. 효율적으로

특히, 위의 3가지의 순서가 중요하다, 프로그램이 아무리 빨라도 결과가 올바르지 않다면 아무런 의미가 없는거고, 혹은 정확하고 효율적인 프로그램이라도 너무 복잡하다면 새로운 버전으로 출시할 때, 전체적인 수정이 필요할 수 도 있다. 유용한 프로그램일수록 새로운 요구 사항과 하드웨어 등을 고려한 수정이 필요하다는 사실을 기억하자.

전문가가 되기 위해선... 누군가가 사용할 코드를 정확하고 단순하게 그리고 효율적으로 만들고 그걸 유지하고 보수해야한다. 실용적인 관점에서 그냥 돌아가는 코드를 아무렇게나 휘갈겨 만들 수 없지만, 모순적이게도 **구조를 생각하고, 코드의 품질을 고려하는 일**이 작업을 빠르게 끝내는 방법이다. <br>
추후에, 가장 힘든 과정인 **디버깅을 최소화**할 수 있기 때문이다.

프로그램을 잘 조직화하고, 프로그램으로 작성할 프로그래머의 생각을 정리하고자할 때, 사용할 수 있는 방법이 **큰 계산을 작은 다수의 과정으로 나누는 방법**이고, 이 과정에는 2가지 개념이 포함된다. 

1. **추상화 (Abstraction)**
   → 직접 사용할 필요가 없는 상세한 내부 동작(상세 구현)은 편리하고 일반적인 인터페이스 뒤에 숨긴다. 예를들어 무언가를 정렬할 때 직접 구현하지 않고도 C++표쥰 라이브러리의 sort 알고리즘을 호출하여 사용하는 것 처럼 또는 컴퓨터 메모리를 사용하는 방식을 할 때, 메모리에 직접 접근하지 않고도 vector나 map등을 사용하는 것처럼
   
2. **분할 정복(Divide and Conquer)**
   → 덩치 큰 문제는 더 작은 문제 여러 개로 나눌 수 있다. 예를 들어 사전을 만드는 작업은 데이터를 읽고, 읽은 데이터를 정렬하고, 정렬한 데이터를 출력하는 3가지 작업으로 나눌 수 있고, 이 3가지 작업은 원래의 거대한 하나의 작업보다 훨씬 작다.

 이러한 접근법이 도움이 되는 이유는 단순하다. 사람은 덩치큰 문제를 한방에 풀수 없기에, 그리고 프로그램을 큰 하나의 덩어리로 관리하고, 유지보수할 수 없기 때문이다. <br>
프로그램을 분할 할 때는 어떤 도구를 사용해서 분할된 각 부분 사이에서의 통신을 표현할 수 있을지를 항상 고민하면서 프로그램을 설계하는 것이 바람직하다. <br>
**구조와 조직화**를 강조한 이유는 단순하다. 긴 코드(or 하드 코딩)을 하는 것은 바람직하지도 않고, 좋은 코드(클린 코드)를 만들 수 없기 때문이다. 그렇기 때문에, SW개발에 있어 추상적이고 개념적인 부분을 중요하게 여겨야하고, 구조에 대한 고려가 좋은 소프트웨어의 핵심이고 구조를 무시하면 엄청난 큰 한 덩어리의 프로그램이 만들어지기 때문에 유지보수하기에 어렵다.

---------------------------------------------------------------------

## Ch-4.3 표현식(Expression)
 표현식(Expression)은 프로그램의 가장 기본적인 구성 요소로서, 피연산자의 값으로 부터 결과 값을 계산하는 것이다. 10, 'a', 3.141592, "Vidan" 등의 단순한 리터럴 값들도 표현식에 속하고, 변수의 이름도 표현식이며 변수는 해당 이름으로 명명된 객체이다. 

```cpp
int length = 20; //정수 리터럴을 이용해서 변수 length를 초기화 했다. 
int width = 40; // width라는 이름의 객체에 값 40으로 저장한다.
int area;

area = length * width;
cout << "넓이 = " << area << endl; 
```

이제 length의 값을 바꿔보자 

```cpp
length = 99;
```
이러면 length 값에 20이 아니라 90이 저장 될 것이다.  <br>
또 다른 코드를 보자 

```cpp
int length = 30; //정수 리터럴을 이용해서 변수 length를 초기화 했다. 
int width = 30;

int perimeter1 = (lenthg+width) * 2;
int perimeter2 = lenthg * 2 + width * 2;
int perimeter3 = lenthg + width * 2;
```
perimeter1,2,3를 봐라, 문법적으로 틀린 부분은 없다. 하지만 이는 논리적 오류인데 컴파일러는 찾을 수 없다. <br>
컴파일러 입장에서는 perimeter1,2,3은 유효한 표현식으로 초기화된 변수일 뿐이다. 프로그래머는 perimeter의 수학적 의미를 알 수 있지만, 컴파일러는 모르기 때문이다.

 괄호를 사용할 때 제 1원칙은 **의심스럽다면 괄호를 써라**이지만, 과도하게 괄호을 남용할 경우 가독성이 떨어질 수 있다. <br>
가독성은 중요하다, 나혼자 작성하고 혼자 다할거면, int a;, int b;.... 이렇게 변수명을 짓든 말든 상관없지만, 나중에 다시 코드를 보거나 다른 사람이 나의 코드를 읽을 때, 지저분한 코드는 읽고 이해하기 어렵기 때문이고, 오류를 포함하고 있을 가능성이 크고 고치기도 어렵기 때문이다. 그렇기 때문에 복잡한 표현식을 피하고, 의미 있는 이름을 선택 해야한다. 

```cpp
a * b + c / d * (e - f / g) / h + 7; //너무 복잡한 표현식이다. 
```

<img src = "https://github.com/Jeon-YuSung/Jeon-YuSung.github.io/blob/main/_img/operatorRankgpt.png" width = 900 hight = 900\>

::나 -> . [] ++ -- dynamic_cast, sizeof... 등의 연산자 순위도 있는데, 일단은 기본(단순 연산자)순위만 알아도 충분하다고 생각한다. 

**상수 표현식**

 프로그램에서 일반적으로 상수(Constant)를 많이 사용한다. 예를 들어 pi는 3.141592, 단위 변환할 때 인치(inch) → 센치미터(Centimeter) 변환시 2.54 비율로 변환. 여기서 알 수 있는 점은 상수에 의미 있는 이름을 붙이기 원하고, 상수를 변경하지 못하도록 하고 싶을거다. C++에서는 초기화를 수행한 후에는 새로운 값을 대입할 수 없는 객체인 기호 상수(Symbolic Constant)를 제공해준다. 

```cpp
int r;
cin >> r;
constexpr doulbe pi = 3.141592;
pi = 7; // 변할수 없는 상수에 대입을 시도함 오류 발생
double c;
c = 2 * pi * r; // pi의 값을 읽을 뿐이지 값을 변경시키지 않음 
```

상수는 코드의 가독성 유지에 도움이된다. 그리고 코드의 어디서든 리터럴 사용은 피해야하고, 그 대신 설명적인 읾의 상수를 사용하는 걸 권장한다. 코드에서 사용된 명확하지 않은 리터럴은 마법의 상수(Magic Constants)라고 부르기도 한다. <br>
참고로 constexpr로 정의하는 기호 상수는 **반드시 컴파일 시점에 값을 알 수 있어야 한다** 컴파일 시점에 값을 미리 알 수 없는 변수로 초기화되지만, 초기화 이후로는 값을 변경할 수 없게 하고 싶다면 const를 사용하자

```cpp
constexpr int max = 100;
void use(int n){
 constexpr int c1 = max + 7; // c1은 107
 const int c2 = n + 7;  // 가능 그러나 c2의 값을 바꿀 수 없다

 c2 = 7; // 오류 c2는 const이기에 
}
```
const는 C++98에서 혹은 상수 표현식이 아니지만(컴파일 시점에 값을 알 수 없지만), 초기화 이후로는 값을 변경할 수 없는 변수가 필요한 경우에 사용한다. 

**constexpr와 const차이점** 

 앞서 말해듯이 constexpr는 compile-time에 모든 값들이 확정되어 있어야하고 그 값들은 변하지 않는다. 하지만 const는 compile-time에는 값이 정해져 있지 않아도 되지만, 할당 후에는 값이 변해서는 안된다. <br>
둘의 공통점은 **할당된 후 값을 변경하면 안됨** 이고, 차이점은 할당시기에 있다.  constexpr는 compile-time시기에 확정되어야하고, 
const의 할당은 compile-time, run-time이든 아무 때나 해도 되지만, 코드에는 어떤 값이 할당 되도록 코드가 쓰여야한다. 

**변환**

한 표현식에서 여러 타입을 함께 사용할 수 있다. 예를 들어 double이나 float에서 int로 값을 나누면 int는 소수점을 버리기 때문에 정수 값만 나오고, 부동소수점 나눗셈에서의 나눗셈은 소수점이 표현된다. <br> 

 type(value)와 type{value}는 "타입이 type인 변수를 value의 값으로 초기화할 때처럼 value를 type으로 변환하라는 의미이다. <br>
 즉, 필요하다면 int 피연산자를 double로, char 연산자를 int로 변환(확장)하라는 의미 있다. <br>
 type{value}는 축소 변환을 방지할 수 있지만 type(value)는 축소 변환을 방지 하지 않는다. <br>
 그렇기 때문에, 결과를 계산 한 후에는 초기 값이나 대입문의 우측에 사용하기위해 다시 변환을 수행한다. 다음 코드를 보자 
 
```cpp
doulbe d = 2.5;
int i = 2;

double d2 = d/i; // d2 == 1.25
int i2 = d/i; // i2 == 1
int i3 {d/i}; // Error : double → int는 축소 변환
```

그리고 부동소수점 피연산자를 포함한 표현식에서도 정수 나눗셈이 일어날 수 있다. 섭씨를 화씨로 바꾸는 f = 9/5 * c + 32를 구현한 다음 코드를 보자 

```cpp
double dc;
cin >> dc;

double df;
df = 9 / 5 * dc + 32; // 주의
```
위의 코드는 정확한 온도 단위 변환을 수행하지 않는다. df = 9 / 5 * dc + 32; 에서  9/5의 결과가 1.8이 아니라 1로 나오기 때문이다. 수학적으로 정확히 표현하려면 9나 5(혹은 모두)를 double로 바꿔야한다. 

```cpp
df = 9.0 / 5 * dc + 32; //개선된 코드  
```

-------------------------------------------------------------------
## Ch-4.4 구문(Statement)
## Ch-4.5 함수(Function)
## Ch-4.6 벡터(Vector)
## Ch-4.7 언어 기능, 4장 정리
