# 7장 프로그램 완성
## 7-1 소개
6장에서 만든 계산기가 어느정도 '합리적으로' 작동한다면 절반정도 왔다. 즉, '기본적인' 동작을 수행하기 때문이다. <br>
이제 7장에서는 6장에서 만든 계산가리를 개선할만 사항을 소개한다. <br>
요구 사항과 제약 사항을 바탕으로 점점 현실의 프로그램에, 코드를 점진적으로 개선해나가는 과정이다. <br>

-------------------------------------------------------------------------
## 7-2 입출력
6장에서 프롬프트로 사용자에게 <br>
표현식 : <br>
결과 : <br>
이런식으로 하기로 했다. 

프로그램을 실행시켜보면 이런 요구 사항을 다 잊어버릴 수 있지만... 뭐 항상 늘 있는 닐이다. 사람은 모든걸 기억할 수 없기 때문에... <br>
아무튼 프로그래밍 작업에 따라서는 초기 요구 사항을 수정할 수 없는 경우도 있지만, 이는 너무 엄격한 정책으로 프로그램이 해결해야 할 문제의 관점에서 봤을 때 엉터리 프로그램으로 귀결될 수밖에 없다 <br>
프로그램이 해야 할 일을 생각함에 있어서 프로그램의 정확한 요구 사항을 변경할 수 있다고 가정하고, 위에 있는 프롬프트처럼 나오길 원하는가?를 고민해보자. 그리고 직접 시도하는 것이 좋다. <br>
사람마다 어떤 스타일을 선호할지 다르지만 간단한 계산기에 하나로 정하는 것이 좋다. <br>
실제 표현식과 계산 결과에 방해를 주면 안되고, 어떻게든 사용자 입력과 컴퓨터의 출력을 구분하지 않으면 혼란스러울 수 있으니, 디버깅 초반에 결과를 나타내는 지시자(Indicator)로 \=를 사용했지만, 프로그럼 입력을 필요하다고 하는 의미의 지시자를 추가해보자. 자주 사용하는건 \> 이다.

```
수정전
표현식 : 2+3; 5+7; 2+9;
결과 : 5
표현식 : 결과 : 35
표현식 : 결과 : 11
표현식 :

수정 후 
> 2+3;
= 5
> 5*7;
= 35
```

깔끔해보인다. 이제 메인을 다시 수정해보자 
```cpp
double val = 0;
while(cin){
  cout <<"> "; //프롬프트 출력 
  Token t = ts.get();
  if(t.kind == 'q') {
    break;
  }
  if(t.kind == ';'){ 
    cout << "= " << val << endl; //결과 출력 
  }
  else{
  ts.putback(t);
  }
  val = expression();
}
```
실행해보면 처음보단 괜찮아졌지만 아직도 수정해야할 부분이 있다. <br>
일단 이정도로만 만족하자. 

------------------------------------------------------------------------------
## 7-3 오류처리
가능한 많은 오류를 찾아 고쳐라, 테스팅을 하는 과정은 SW개발에 있어서 매우 중요하기 때문에, 올바른 입력과 잘못된 입력을 넣어 계속 테스팅하는 것이 좋다 <br>
또한, 모든 프로그램에 들어맞는 답은 없다. 그러나 진지하게 테스팅을 한다면 더 많은 프로그램에서 더 나은 테스트를 할 수 있다 이런 방법 중 하나가 테스트 케이스를 체계적으로 만드는 방법이다. <br>
만약에 테스트를 했는데도, 부족한 경우에는 '비합리적' 테스팅을 수행해보자. <br>
이상적인 프로그램은 **합리적인 오류**는 물론이고,  **비정상적인 오류**를 포함한 모든 오류를 찾아낼 수 있어야한다. <br>

```
+1;
()
!+2
```

위의 내용을 입력하면 창이 즉시 닫힌다. 즉, 오류 메시지를 출력한 후에 프로그램이 바로 종료한다. <br>
하지만, 창을 열려있게 하는 수단으로 사용자의 입력을 요구하지만, 위의 경우에는 모든 문자를 다 읽기 전에 프로그램에 오류가 발생한다. <br>
"창을 닫으려면 문자를 입력하세요"라는 프롬프트에 대한 응답으로 받아들여야 할 문자가 이미 입력 스트림에 남아 있기 때문에 창이 바로 닫히게 된다. 그럼 다시 메인 부분을 수정해보자. <br>

```cpp
catch(runtime_error& e) {
  cerr << e.what() << endl;
  cout << "창을 닫으려면 문자 ~를 입력하세요 \n";
  for(char ch; cin>>ch;){
    if(ch == '~') return 1;
    }
  return 1;
}
```

만약 오류가 발생한 후 문자 중에 '~'가 있으면 문제가 발생하겠지만, 그럴 가능성이 적다. 만약 이 또한 문제를 수정하고 싶다면? 

```cpp
catch(runtime_error& e) {
  cerr << e.what() << endl;
  keep_window_open("~~");
  return 1;
}
```

위와 같이 간단한 문자열을 argument로 받아 이 문자열과 동일한 입력이 있을 때만 종료하도록 keep_window_open()를 수정할 수 있다. <br>
그럼 ~~를 입력할 때 까지 종료하지 않는다. <br>
이렇게 키보드에서 입력을 받기 때문에, 테스팅 작업이 지루하다 수 많은 테스트 케이스를 입력해야하기 때문에, 그럼 테스트 케이스를 어딘가에 저장하고 명령어 한 번으로 실행할 수 있는 방법이 있을까? <br>
유닉스같은 일부 운영체제에서는 프로그램을 고치지 않고도 cin이 파일을 읽게 할 수 있고, cout이 파일로 출력하게 할 수 있다. 아니면 프로그램이 파일스트림을 읽어 파일을 이용하도록 수정하면 된다. 

```cpp
1+2; q
1+2 q
```

위의 코드처럼 입력하면 어찌 될까? 1 + 2 q는 기대대로 작동하지만 <br>
1 + 2; q는 **Primary가 와야 함**이라는 오류가 발생한다. 그럼 오류를 파악해야하는데 ;과 q는 main함수에서 처리할 수 있기 때문에 메인을 보면된다. <br>
;와 q는 6장에서 출력과 종료를 하게하여 계산기가 동작하려고 하도록 추가 한 것이다. 그럼 이제 오류 부분을 고쳐보자 <br>

```cpp
double val = 0;
while(cin){
  cout << ">";
  Token t = ts.get();
    if(t.kind == 'q') break;
      if(t.kind == ';') cout << "= " << val << endl;
      else ts.putback(t); //이 else는 가까운 if문이랑 묶는다. 
    val = experession();
}
```

위의 코드에서는 세미콜론을 찾은 후에 q를 확인하지 않고, expression()을 바로 호출한다. <br>
즉, expression()은 곧바로 term()을 호출하고, term은 바로 primary를 호출하는데 결국 문자 q를 찾는다. 하지만 문자 q는 primary가 아니기에 오류가 발생한다. <br>
그럼 이제 논리를 단순화 해보자. 

```cpp
int main(void) {
  try{
    while(cin){
      cout << ">";
      Token t = ts.get();
      while(t.kind==';') t = ts.get();
      if(t.kind == 'q'){
        keep_window_open();
        return 0;
      }
    ts.putback(t);
    cout << "= " << expression() << endl;
    }
  keep_window_open();
  return 0;  
  }
  catch(exception& e){
    cerr << e.what() << endl;
    keep_window_open("~~");
    return 1;
  }
  catch(...){
    cerr << "예외 \n";
    keep_window_open();
    return 2;
  }
  return 0;
}
```

이정도면, 비교적 견고한 오류처리라고 할 수 있다. 이제 계산기를 어찌 처리할지 고민해보자. 

------------------------------------------------------------------------------
## 7-4 음수 
음수는 어찌 처리해야하지? 
```
-1/2
(0-1)/2
```
위를 보면 -1/2를 오류 없이 처리하려면 (0-1)/2로 처리해야한다. 귀찮고 어렵다 <br>
이렇게 디버깅과 테스팅 후반에 문제를 찾아내는 경우가 있다. <br>
즉, 프로그래머의 설계가 실제로 어떻게 동작하는지 확인하고, 아이디어를 정제하는 데 필요한 피드백을 얻을 수 있다. 따라서 프로젝트를 계획할 때는 최대한 효율적이고, 이득을 취할 수 있게 유연성을 발휘하고 시간을 배분해야한다. <br>
그래야 스케줄이 너무 빡빡하거나 경직된 프로젝트 관리 전략으로 인해, 프로젝트 후반에 명세를 변경할 수 없어서 필요한 요구 사항이 빠지는 채로 출시하는 경우가 많기 때문이다. 특히 프로젝트 후반에 기능을 추가하는 일은 금기시되지만, 항상 계획대로 되지 않는다... <br> 
즉, 간단한 기능은 괜찮지만 출시까지 부족할 수도 있다. 그래도 피드백을 통해 수정하고 개선할 수 있다. <br>
다시 본론으로 돌아와서 이 음수를 처리하는 문제를 해결하려면, 기본적으로 문법이 단항 마이너스를 지원하게 변경해야 하는데, 이는 Primary를 바꾸는 것이 가장 간단한 방법이다. 

```cpp
// 수정 전 Primary
Primary:
  Number
  "(" Expression ")"

// 수정 후
Primary:
  Number
  "(" Expression ")"
  "-" Primary
  "+" Primary
```

단항 플러스도 같이 추가 했는데, 이는 단항 마이너스를 하면 단항 플러스도 하는 사람도 있기 때문이다. 그리고 필요없는 설명을 하는 것보다 그냥 구현을 하는것이 더 쉽다. 이제 이를 바탕으로 구현한 Primary의 코드는 다음과 같다. 

```cpp
double Primary(){
  Token t = ts.get();
  switch(t.kind){
  case '(':   // '(' expression ')' 처리
    double d = expresstion();
    t = ts.get();
    if(t.kind != ')') error(" ')'가 나와야함");
    return d;
  case '8': //'8'은 숫자를 나타내어 여기서는 숫자 값을 반환한다.
    return t.value;
  case '-':
    return - primary();
  case '+':
    return + primary();
  default :
    error("Primary가 나와야한다.");
  }
}
```

이렇게 변경하면된다. 

------------------------------------------------------------------------------
## 7-5 나머지 : %

나머지도 구해야 계산기이지 않을까...? 그럼 나머지를 구해보자 <br>
%가 부동소수점 숫자에서 정의가 되지 않아서 고민이 되는데, 어찌 처리할지 생각을 해보자. <br>
해답은 다음과 같이 간단히 할 수 있다. 
1. %를 Token으로 추가한다
2. %의 의미를 정의한다.
     피연산자가 정수인 경우, %의 의미가 명확하다.
```
> 2 % 3;
= 2
> 3 % 2;
= 1
> 5 % 3;
= 2
```

그러나 피연산자가 정수(int)가 아닌 float이나 double형이라면? 

```
> 6.7 % 3.3;
```

위의 표현식의 값은 뭘까? 기술적으로 완벽한 해답은 없지만 부동소수점 피연산자에 나머지 연산을 정의하는 경우도 있다 <br>
특히 x % y는 주로 x - y = x - y * int(x/y)로 정의하므로 6.7 % 3.3 == 6.7 - 3.3 * int(6.7/3.3)로 0.1이 나온다. <br>
그러나 헤더 파일의 cmath나 math.h를 추가해서 fmod()함수를 통해 쉽게 할 수 있다. <br>
이제 term()에 추가 해보자

```cpp
case '%' :
  double d = primary();
  if(d == 0) error("0으로 나눔");
  left = fmod(left, d);
  t = ts.get();
  break;
```

또한 cmath, math.h에는 sqrt(x의 제곱근), abs(x의 절대값), log(x의 자연로그), pow(x,e) (x의 e승)등 여러 표준 수학 함수를 찾을 수 있다. <br>
다른 방법으로 인자가 부동소수점이면, %를 사용할 수 없게 만들 수 있다. 이럴 경우 부동소수점 피연산자에 분수 부분이 포함되는지 확인하고, 그런 경우에 오류 메시지를 출력해야 한다. 이와 달리 %의 피연산자를 int로 제한하는 문제를 앞서 3장 후반부와 5장 후반부를 생각 해보면 narrow_cast로 문제를 해결 할수 도 있으니 편한 방법을 선택하면 된다 <br>

```cpp
case '%' :
  int i1 = narrow_cast<int>(left);
  int i2 = narrow_cast<int>(primary());
  if (i2 == 0) error("% : 0으로 나눔");
  left = i1 % i2;
  t = ts.get();
  break;
```

------------------------------------------------------------------------------
## 7-6 코드 정리
