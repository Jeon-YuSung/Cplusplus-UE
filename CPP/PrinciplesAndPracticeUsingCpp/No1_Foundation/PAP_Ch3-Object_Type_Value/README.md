# Ch3- 객체, 타입, 값

## 3.1 입력(input)
앞에서 본 Hello, World! 프로그램은 화면에 쓰기만 한다. 즉, 출력을 생성할 뿐 아무것도 읽지 않고, 사용자의 입력을 받지 않음. <br>
실제 프로그램은 실행할 때마다 동일한 출력을 내보내지 않으며, 주어진 입력에 따라 다른 결과가 나옴. <br>
뭔가를 읽으려면, 어딘가 읽을 곳이 필요하다 → 읽을 내용을 컴퓨터 메모리의 어딘가에 저장해야 함. 그런 '장소'를 객체(object)라고 함. 

  - 객체
    저장하는 정보의 종류를 가리키는 **타입**과 연계된 메모리의 한 영역
    
  - 변수
    명명된 객체를 뜻 함, 문자열은 string 변수에, 정수는 int 변수에 저장

객체는 특정 타입의 객체를 저장하는 '상자'에 비유 가능.

<img src = https://github.com/Jeon-YuSung/Jeon-YuSung.github.io/blob/main/_img/intBoxGpt.png width = "300" height = "400"/>

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(void){
  string firstName;
  cout << "firstName Input and Enter \n";
  cin >> firstName;
  cout << "hello, " << firstName << endl;
  return 0;
}

```

위의 코드에서 "firstName Input and Enter"는 사용자가 행동을 취하게 조언하는 의미로 프롬프트(prompt)라고 함 <br>
string 객체의 변수 firstName를 정의 → 메모리에 문자열을 저장할 메모리 영역을 할당 <br>
프로그램에서 새로운 이름을 선언하고, 변수를 저장할 메모리 영역을 할당하는 구문을 **정의문(Definition)** 이라고 함.<br>
cin은 cout 처럼 character input의 줄임말로, 표준 라이브러리에 정의된 표준 입력 스트림(standard input stream)을 가르키고, >> 연산자의 두 번째 피연산자(operand)는 입력을 받을 곳을 가리킴. <br>
참고로, 문자열 리터럴는 큰따옴표를 사용하고, 큰따옴표를 사용하지 않으면 그 이름이 가리키는 값을 참조하겠다는 의미임 <br>

-------------------------------------------------------------------------

## 3.2 변수(Variable)
입력 문자열을 저장하는 것처럼, 컴퓨터는 메모리에 데이터를 저장하지 않고는 일을 할 수 없음. <br>
데이터를 저장하는 장소는 객체(Object)라고 하고, 그 객체에 접근하려면 이름이 필요함 <br> 
이름이 있는(명명된) 객체를 변수(Variable)이고, 변수는 해당 객체에 넣을 수 있는 정보의 종류와 적용 가능한 연산의 종류를 지정하는 타입을 지님<br>
(int type에 123을, string type에 "Hello"를, 아니면 *로 곱셈을 하거나 <=을 적용해서 문자열을 비교) <br>
변수에 저장하는 데이터를 값(Value)라고 하고, 변수를 정의하는 구문은 말 그대로 **정의문**이라고 하고 정의문에서 초기 값을 지정할 수 있다 → (정의문에서 초기값을 지정 안해도 되는데, 지정하는게 권장 사항)

```cpp
string name = "Annemarie";
int number_of_steps = 42;
```
<img src = https://github.com/Jeon-YuSung/Jeon-YuSung.github.io/blob/main/_img/OutPutBoxWithGPT.png width = "600" height = "600"/>

이제 다음 코드를 보자

```cpp
string name = 42; // Error, 39는 문자열(string)아니다, 대신 "38", "4212321"같은 숫자를 문자형으로 바꾸는건 가능   
int number_of_steps = "Annemarie"; // Annemarie는 정수 int가 아니라 문자라 에러가 발생함
```

컴파일러는 각 변수의 타입을 기억해뒀다가, 변수 정의에서 지정한 타입을 사용하는지 확인함 <br>
C++에서 많은 종류의 타입을 제공하지만, 주로 다음 코드에 있는 타입들을 많이 사용.

```cpp
int num = 0; // int num (0);, int num; num 10; 이런식으로 초기화 가능, 4바이트
float realNum = 4.231; // float은 실수 표현 단정도 부동 소수점이라고도 함 4바이트
char singleChar = 'A' // 개별문자를 저장, 크기는 1바이트  'A'는 아스키 코드로 65
double realNum2 = 6.1232135; // double은 배정도 부동소수점, 크기는 8바이트
string name = "Vidan"; // 문자열을 저장하는 string, 크기는 객체가 차지하는 크기를 따라감
bool tapOn = true; // 논리 변수를 저장함 크기는 1바이트 
```
이외에도 unsigned char, unsigned int, short, long, long long... 등 다양한 기본 자료 타입들이 제공됨. 

-----------------------------------

## 3.3 입력과 타입(Input and Type)
입력 연산자 >>는 타입에 예민한 연산자로, 입력을 저장할 변수의 타입에 맞게 값을 읽어 들임. <br>
```cpp
string name;
int age;

cout << "이름과 나이 입력 : \n";
cin>> name >> age;
cout << " 이름 : " << name << endl;
cout << " 나이 : " << age << endl;
```

이 프로그램을 실행하여 vidan 27를 입력하면 >> 연산자는 name에 vidan, age에 27을 읽어들인다. <br>
띄어쓰기, 개행문자, 탭 문자 등의 공백 문자(whitespace)를 만나면 문자열 입력을 종료하고, 그외에는 >>연산자가 공백 문자를 무시한다. <br>
참고로, 자료형에 타입에 맞지 않은 값을 입력하게되면, 초기화(혹은 초기값)을 주지 않았기 때문에, 값을 읽어오지 못하고 메모리의 해당 영역에 남아있던 garbage value가 출력된다.  

-----------------------------------------------------------------

## 3.4 연산자과 연산자 

```cpp
string name;
int count;
float fcount;

cin >> name;
cin >> count;
cin >> fcount;

int c2 = count + 2;
string s2 = name + "Jr";

int c3 = count - 2;
string s3 = name - "Jr"; // Error -는 문자열에 대해 정의되어 있지 않다.  
```

위의 코드를 보면 string s3 = name - "Jr";는 오류가 발생하는데, 이는 -가 문자열을 뺄 수 없기 때문이다 <br>
컴파일러는 각 변수에 대하여 어떤 연산을 적용할 수 있는지 정확히 알 수 있지만, 어떤 값에 합당한 연산자가 무엇인지는 알지 못하기 때문에, 아무리 터무니 없는 것이라도 문법적으로, 합법적인 연산이면 오류로 취급하지 않는다. 

모든 연산을 연산자로 제공하지 않지만, 함수 형태로 제공하는 경우가 있는데 이 경우는 주로 표준 라이브러리에서 제공을 해준다. <br>
대표적으로 #include \<cmath\>는 수학 관련된 연산을 제공해주는 표준 라이브러리이다. 

string같은 문자열에서 +는 **연결(Concatenation)**을 의미하고, ==를 사용해 비교를 할 수 있다. <br>
대입 연산자인 =과 비교 연산자인 ==는 꼭 구분하자

-----------------------------------------------------------------

## 3.5 연산자과 연산자 

대입 연산자는 =로 표현하고, 같다는 의미가 아니다 즉, **equl**이 아니다 <br>
대입은 변수에 새로운 값을 저장하는 연산이다. <br>

```cpp
int a = 0 ; // a는 0으로 초기화
int b = 3;
a = b + 10; // a는 b(3) + 10으로 대입
cout << a; // 13이 나온다. 
```

초기화와 대입은 논리적으로 다르지만, 같은 표현식인 =를 사용한다<br>
초기화에서는 타입 지정(int, string, long...)이 앞에 나오지만 대입에는 타입 지정이 없다는 점에서 구별할 수 있고, 원칙적으로 초기화를 수행할 때 변수는 비어있지만, 대입을 수행할 때는 변수에 원래 남아있던 값을 먼저 지워야 한다.

---------------------------------------------------------------------------

## 3.6 복합 대입 연산자

```cpp
int counter = 0; 
++counter; //전위 연산자 먼저 1를 증가 시킨다
counter++; //후위 연산자 1를 후에 증가시킨다 
counter = counter + 1; // ++의미는 counter + 1과 같다

int a = 10;
a += 7; // a(10) + 7

int b = 20;
b -= 5;

int c;
c *= 2; // c*2를 의미
```

일반적으로 oper가 이항 연산자(binary operator)라면 a oper = b는 a = a oper b를 의미한다. <br>
이를 바탕으로 복합 연산자를 사용하자 <br> 
그리고 많은 응용 분야에서 *=와 /=를 스케일링(scalling>이라고 한다. <br>
(스케일이링이란 어떤 수나 벡터에 실수를 곱해서 그 크기를 조절(확장 또는 축소)하는 일을 뜻함)

---------------------------------------------------------------------------

## 3.7 이름
이름(변수명)을 작성할 때는 **알파벳 문자로 시작하고, 이름 전체에 알파벳 문자와 숫자, 밑줄만 포함할 수 있다**를 기억하자. 

```cpp
x;
number_of_elemets;
FourierTransform;
z2;
Polygon
```

위의 단어들은 변수명을 짓을 때 사용가능하다. 

```cpp
2x; //이름은 알파벳으로 시작해야하며, 숫자로 시작할 수 없다
int int; //예약어 또한 사용할 수 없다
time$to$market; //$같은 특수 문자는 사용 불가
Start menu; //띄어쓰기는 불가능하니 _나 -로 띄어씌기를 표현하자 
```

가끔 _foo처럼 언더바로 시작하는 이름이 있지만, 지양하자 이또한, 구현체나 시스템 개체용으로 예약된 언어 이름이기 때문이다.
그리고 대소문자도 구별한다.

```cpp
int Main(){
  STRING s = "이 코드는 에러 입니다";
  cOut << S << endl;
}
```

위의 코드에서 틀린 문법이 총 4가지이다. 하나씩 알아보자 <br>
1. Main → 프로그램 시작(Entry Point)은 반드시 main()함수이어야 한다. 대소문자 구분하기 때문에 Main은 인식되지 않는다
2. STRING → std::string타입을 사용하는데 STRING은 정의된 타입이 아니라서 오류이다.
3. cOut → std::cout객체를 사용하기 때문에 대소문자를 구분함으로 출력문 또한 오류이다
4. S → 변수명은 대소문자 구분하여 대문자 S는 정의되지 않은 식별자로 오류가 발생한다.

앞서 말해듯이 예약어는 사용 불가하고, 표준 라이브러리에서 제공하는 기능을 이름으로 쓸 수 있지만, 문제가 발생할수 있으니 지양하자.<br>
그리고 코딩스타일에 따라 다양한 표기방식으로 표현할 수 있다. 주로 사용하는 표기법을 알아보자. <br>
1. 스네이크 표기법 → 단어 사이에_로 띄어쓰기를 표현, 예시 : element_count
2. 카멜 표기법 → 첫단어는 소문자, 그 다음 단어는 대문자로 표기, 예시 : elementCount
3. 파스칼 → 모든 단어의 첫 글자를 대문자로 표기 예시 : ElementCount
4. 헝가리안 표기법 → 변수명만 봐도 자료형을 유추할 수 있게한다. 예시 : strName, szName, pName등

매크로에서 모두 대문자로 이름을 짓는데 이는 관례적으로 해왔기 때문에, 변수명으로 모두 대문자로 짓을 수 있으나, 하지 않는걸 추천한다. <br> 
그리고 타입을 정의할 때 Squre나 Graph처럼 첫 글자를 대문자로 표기한다. 

--------------------------------------------------------------

## 3.8 타입과 객체 

타입의 개념에 대해 더 알아보자 
1. 타입은 (해당 객체의) 가능한 값과 적용할 수 있는 연산의 집합을 정의한다.
2. 객체는 주어진 타입의 값을 저장하는 메모리 공간이다.
3. 값은 주어진 타입으로 해석되는 메모리상의 비트의 집합이다.
4. 변수는 명명된 객체이다.
5. 선언은 객체의 이름을 지정하는 구문이다.
6. 정의는 객체의 메모리 공간을 할당하는 선언의 일종이다.

비공식적으로 객체를 주어진 타입의 값을 저장하는 상자로 생각할 수 있다.  <br> 
그리고 string은 저장하는 문자의 개수도 함께 저장하기 때문에 int보다 메모리 표현이 더 복잡하고, double과 float는 숫자를 저장한다 <br>
모두 int는 크기가 같아, 컴파일러가 고정된 크기의 메모리 영역을 각 int에 할당 해준다 그리고 bool, double들도 고정된 크기를 제공해주만 int와 크기가 다르다 <br>
**서로 다른 타입을 차지하는 공간의 크기가 다르다**

<img src = "https://github.com/Jeon-YuSung/Jeon-YuSung.github.io/blob/main/_img/TypesSize2Gpt.png" width = "800" height = "1500"/>

메모리상의 비트들의 의미는, 이에 접근할 때 사용하는 타입에 전적으로 의지한다. 왜냐 컴퓨터는 타입에 모르고, 비트들은 단지 메모리 공간일 뿐 이기에, 메모리상의 비트는 비트를 해석하는 방법을 지정해야지 그 의미를 얻기 때문이다.

<img src = "https://github.com/Jeon-YuSung/Jeon-YuSung.github.io/blob/main/_img/dataSizeunitGpt.png" width = "800" height = "1500"/>

bit부터 시작하여... byte... Tb등 단위 크기를 아는건 중요하기 때문에, 알아두자.

---------------------------------------------------------------------------

## 3.9 타입 안정성
모든 객체는 정의하는 시점부터 정해진 타입이 있다. <br>
프로그램 전체나 일부에서 그 타입의 규칙를 사용하면 이를 **타입 안전성(Type-safe)이 있다**고한다. <br>
타입 안정성을 어기면서 연산할 수 있는 방법이 있는데, 예를 들어 초기화하지 않은 변수를 하는 경우에는 타입 안전성이 없다.

```cpp
int main(void){
  double x; //초기화 x
  double y = x; // y 값도 정의되지 않았음. 
  double z = 2.0 + x; // +의 의미도 정의되지 않았기 때문에 z의 값도 알 수없다.

  return 0;
}
```

위의 코드처럼 x를 초기화하지 않고, 사용하면 구현체에서 하드웨어 오류를 내는 일까지도 허용되니깐, 꼭 변수를 **항상 초기화**하는 습관을 가지자. 물론 바로 cin 사용하는 입력 연산의 대상이 될 변수를 비롯한 예외적인 케이스도 존재한다. <br>
C++ 컴파일러는 완벽한 타입 안정성을 보장하지 않기 때문에, 좋은 코딩 습관과 실행 시간 검사(Run-time check)를 병행하면 타입 안전성 위반을 피할 수 있다. <br> 
컴파일러가 안전성을 보장하지 않은 언어 기능을 사용하지 않는 방법, 즉 정적 타입 안정성을 준수하는 방법이 이상적이지만... 그런건 너무 많은 제약이 있어 제한적이다. 또한 암무적으로 코드를 생성해서 타입 안전성을 위반하는 경우를 모두 잡아내는 대안도 있지만, 이 또한 추천하지 않는다. 그러므로 타입 안정성을 위반하는 무언가를 할 때는 스스로 적당한 검사를 해야하고, 따로 명시해주면 좋다. 

**안전한 타입 변환**

기본 자료형에서 타입이 다르면 직접 비교할 수 없지만, 간접적으로 비교할 수 있는 방법이 있다 
char에 int를 더하거나 반대로 하거나, double과 int를 비교하거나... 다음 코드를 보자 
```cpp
char c = 'x';
int i1 = c;
int i2 = 'x';
//i1과 i2는 에러가 날것 같지만 에러가 나지않는다 즉, 합법적인 선언이다. 
```
i1과 i2의 값은 8비트 문자 집합 ASCII에서 정의하는 문자 'x'의 값인 120으로. 이런식으로 간단하고 안정한 방법으로 문자를 숫자로 표현할 수 있다. **char-to-int**변환은 손실된 정보기 없기 때문에 안전하다. <br>
이런식으로 원래 값과 동일한 값이나 최적 근사치로 변환되는 경우는 안전한 변환이라고 할 수 있다. 

bool → char <br>
bool → int <br>
bool → double <br>
char → int <br>
char → double <br>
int → double 

특히, int → double로 변환하면 다음 코드처럼 int와 double를 혼용할 수 있어 유용하다.
```cpp
double d1 = 2.3;
double d2 = d1+2; //덧셈하기 전에 2.0으로 변환
if(d1<0) cout << "d1은 음수\n";  //비교하기전에 0을 0.0으로 변환
```

int의 값이 매우 클 경우 double로 변환하는 과정에서 정밀도 손실이 발생할수도 있으니 주의하자.

**안전하지 않은 타입 변환**

암묵적이고 안전하지 않은 타입 변환도 허용해주니 이에 대해 알아보자 <br>
즉, 변환 과정에서 원래 값이 아닌 다른 값으로 바낄 수 있다. 

```cpp
int a = 20000;
char c = a; //큰 int를 작은 char에 넣을려고 시도
int b = c;

if (a != b){
  cout << "이런! : " << a << "!=" << b << endl;
} else{
  cout <<"문자가 엄청 크네요! \n";
}
```

어떤 값을 저장하기에는 너무 좁은(narrow) 객체에 대입하는 경우를 축소 변환(Narrow Conversion)이라고 한다. <br>
char를 int로 안전하지 않게 초기화하는 경우 경고를 발생시키는 컴파일러는 많지 않다. <br>
타입 관점에서 int는 char보다 매우 크그 때문에, char로 표현할 수 없는 int 값을 가질 수 있다. <br>

```cpp
double d = 0;
cout << "숫자를 입력 하세요 : " ;
while(cin>>d){
  int i = d;
  char c =i;
  int i2 = c;
cout << "d == " << d << endl;
cout << " i == " << i << " i2 == " << i2 << endl;
cout << " char (" << c << ")\n";
}

```

실행해보면, 큰 값이나 너무 작은 값을 입력하면 이상한 값을 출력한다. <br>
dobule → int <br>
double → char //단, 아스키 코드 범위에 있는 값이면 제대로 변환 해줌. <br>  
double → bool <br>
int → char //단, 아스키 코드 범위에 있는 값이면 제대로 변환 해줌.<br>
int → bool <br>
char → bool <br>
컴파일러는 이 모든 변환을 허용해준다. 다만 원래 저장한 값과 대입되는 값이 다를 수 있는 안전하지 않은 변환으로... 이러한 일이 발생하는 이유는 안전하지 않은 변환를 수행한다는 사실조차 모를 때가 많기 때문이다 

```cpp
double x = 3.72;
int y = x; // y 값은 3이다.
```
y를 정의할 때, x가 double이거나 double → int 변환시 관례적인 반올림을 하지 않고 소수점 이하를 버린다는 사실을 잊었을 수 도 있다. <br>
int y = x;라는 코드만으로 정보(0.72)가 버려진다는 사실을 알 수 없다. 

int와 char는 모두 소수점 이하를 표현할수 없어서 소수점의 버림 문제가 발생하지 않지만 char는 크기가 작아 매우 작은 정수만 저장할 수 있다. 위의 표를 본것 처럼 char의 사이즈는 1 byte, int의 사이즈는 4 byte이다.  <br>

축소 변환은 허용한 이유는 C로부터 축소 변환을 받아 왔기 때문이다. 그리고 구간 안의 값인 경우에는 축소 변환 때문에 문제가 발생하지 않는다. <br>
추가적으로 c++11에서 축소 변환를 방지하는 초기화 기법을 제공해준다. 

```cpp
double x(2.7);
int y{x}; //오류 double를 int로 축소
int a{1000};
char b{a}; // 오류 int를 char로 축소
char c1 {1000}; //오류 축소 변환 char를 1byte, 8bit로 가정
char c2 {65}; //가능 
```
참고로 = 대신 ()나 {}로 초기화해줄 수 있다.<br>
초기화 인자가 정수 리터럴이면 실제 값이 축소 변환을 수반하지 않은 구간에 있는지 검사를 해준다. <br>
{}초기화 수행자로 타입 변환으로 틀린 값이 나올 소지를 미리 방지하고, 축소 변환이 필요한 경우 값을 검사하자. <br>
{}을 이용한 초기화를 **범용 균등 초기화(Universal and Uniform Initialization)**이라고 한다. 

**=, (), {}의 초기화 차이**

```cpp
int x = 10;       // 복사 초기화
std::string s = "hi";

int y(10);         // 직접 초기화
std::string y("hi");

int z{10};          // 균등 초기화
std::string z{"hi"};
```

=로 초기화하는 방식은 **복사 초기화(Copy Initialization)** 라고 하며, 기존 값을 복사(copy)해서 초기화하는 문법이다. <br>
그리고 int x = 10;은 int x(10);과 같은 동작을 한다. 

()로 초기화하는 방식은 **직접 초기화(Direct Initialization)** 라고 하며, 생성자(constructor)를 직접 호출하는 방식이다. <br>
객체지향에서 std::string y("hi");는 string의 생성자를 직접 부르는 것과 같다. 

{}로 초기화하는 방식은 **범용 균등 초기화(Universal and Uniform Initialization / Uniform Initialization / List Initialization)** 로, C++11에서 도입된 방식이다. <br>
모든 타입에 동일한 문법 적용 가능하고, 좁은 변환(narrowing conversion) 방지 기능 있다.
```cpp
int x{3.14};  // 컴파일 에러! (double → int 손실 방지)
```
