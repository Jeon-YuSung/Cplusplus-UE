# 8장 언어적 세부 사항 - 함수 등

8장과 9장은 '프로그래밍' 자체보단 C++언어 그 자체에 초점이 맞춰서 서술되어 있다. 

-----------------------------------------------------------------
## 8.1 언어의 기술적 세부 사항
7장 까지는 프로그래밍 언어의 기능보다는 프로그래밍 자체에 집중되었다. 즉, 아이디어를 표현하는 도구인 프로그래밍 언어보다는 아이디어를 어떻게 코드로 표현하는지를 주로 알아봤다 그러니 이젠 **언어의 개별적인 기능**에 대해 알아보자. 

1. 주요 학습 주제는 프로그래밍이다.
2. 최종 산출물은 항상 프로그램 or 시스템이어야 한다.
3. 프로그래밍 언어는 **그저** 도구일 뿐이다.

언어의 문법과 의미에 대한 부차적인 세부 사항에 신경 쓰려고 하는데.. 이는 프로그래밍 언어에서 사용하던 방법이 유일한 진리라고 오해하기 때문이다. C++는 좋은 언어는 맞으나 그렇다고 완벽한 언어가 아니다 물론 다른 언어들도 마찬가지다 (C#, JAVA, Python 등...) <br>
대부분의 설계와 프로그래밍 관련 개념은 범용적이기 때문에, 기본적인 아이디어와 기법은 여러 언어에서 유효하다. 즉, 모든 프로그래밍 언어에 적용할 수 있다 하지만, 기술적 세부 사항은 각각의 언어마다 다르다. 
물론 아예 처음부터 창조하지 않기 때문에 개념 대부분은 각 언어와 비교하면 명확하게 대응이 가능하다. C++, C, C#, JAVA 등은 일부 기술적 세부사항은 공유한다. 

--------------------------------------------------------------
## 핵심 정리

여기서부터는 주요 부분만 정리하겠다.

### 헤더파일 
모든 선언은 동일해야하며, 실제로 수만 개 아니 수십 만개의 선언을 할수 있다. 그리고 일반적으로, 대부분의 정의는 직접하지 않아도 된다. 예를 들어 cout, sqrt, string...등은 오래전에 구현된 것이고, 그걸 사용할 뿐이다. 이처럼 C++에서 **어딘가에** 정의된 기능의 선언을 관리하는 핵심이 바로 **헤더**이다. 헤더는 주로 #include를 통해 포함시킨다. 라이브러리에서 제공해주는 것도 있고 cmath, string, list, iostream... 아니면 사용자가 직접 구현할 수도 있다. <br>
컴파일러는 다른 작업을 하기전에 #include를 우선처리 하여 전처리기(preprocessing)의 일부라고 할 수 있다. 일관성을 보장하려면 해당 선언을 사용하는 소스 파일과, 해당 선언을 정의하는 소스 파일 모두가 헤더를 include해야한다. <br>
또한 일반적으로 여러 소스 파일에 포함되므로, 헤더 파일에는 여러 파일에 중복될 수 있는 선언만 존재하는 것이 좋다 <br>
(함수  선언과 클래스 정의, 혹은 숫자 상수 정의 등...) 

### Pass by Value/ Reference/ Pointer
  return by ~와 비슷하지만 다르다. pass by ~는 전달 해주겠다는 의미고 return by ~는 반환 해주겠다는 의미이다. <br>
  C++에서는 **Call by reference**와 **Pass by reference**는 구분하여 사용하지 않고, 둘 다 **참조에 의한 호출**로 사용한다 <br>
  그리고 parameter 앞에 &기호를 붙여 사용한다. <br>
  반면에 C#에서는 이 둘 용어를 구분하여 사용하는데, Call by referenece는 참조에 의한 호출, Pass by reference는 참조에 의한 전달로 구분한 다. 
  
#### Pass by Value
함수에 인자를 전달하는 가장 간단한 방법은 인자로 지정한 값의 사본을 함수에 전달하는 방법이다. 
```cpp
int f(int x){
  x = x + 1; // 지역변수 x에 새로운 값 대입 
  return x;
}

int main(void){
  int xx = 0;
  cout << f(xx) << endl; // 결과 : 1 나옴
  cout << xx << endl; // 결과 0, xx의 값이 변하지 않기 때문에

  int yy = 7;
  cout << f(yy) << endl; // 결과 : 8
  cout << yy << endl; // 결과 7 yy의 값이 변하지 않음 
}
```
함수에 전달하는 값은 **사본**이기에 f함수 안의 x = x+1은 함수를 호출할 때 마다 인자로 지정한 xx와 yy를 변경하지 않는다. 
이러한 방식은 쉽고 직관적이지만, **값을 복사하는 만큼의 비용(cost)** 이 소모된다

#### Pass by const Reference
 값에 의한 전달은 간단하고 직관적이기 때문에, 작은 값을 전달할 때에는 효율적이다. <br>
 하지만 이미지나 매우 큰 값을 저장하는 테이블 혹은 매우 긴 문자열을 전달하는 경우라면? 가능은 할 것이다. 하지만 그만큼 복사하는 비용이 발생한다. 물론 비용에 집착할 필요는 없지만, 불필요한 작업을 한다는 것은 아이디어를 직접 표현하지 못하고 있다는 것과 같다. 

```cpp

// 값에 의한 전달이 적당한 방식인가?
void print(vector<double> v){
  cout << " { ";
  for(int i = 0; i < v.size(); ++i) {
    cout << v[i];
    if(i != v.size() -1) {
      cout << ",";
    }
  cout << "}" << endl;
  }
}

void f(int x){
  vector<double> vd1(10);
  vector<double> vd2(1000000);
  vector<double> vd3(x);

  print(vd1);
  print(vd2);
  print(vd3); 
}

```

vd2는 100만개 를, vd3에서는 크기를 알 수 없는 즉, 얼마나 많은지 모르는 값을 복사해야 한다. <br> 
그럼 복사를 하지 않지 않은 방법이 있을까? <br>
당연히 있다. **사본**(애초에 원본 값을 넘기는게 아니라 복사해서 넘기기 때문) 넘겨주는 방식 대신에 **주소**를 넘겨주면 되는데, 이를 참조(reference)라고 한다. <br>
방법은 간단하다 &를 추가해주면 된다. 그럼 다음 코드를 보자. 

```cpp
// 상수 참조에 의한 전달
void print(const vector<double>& v){
  cout << " { ";
  for(int i = 0; i < v.size(); ++i) {
    cout << v[i];
    if(i != v.size() -1) {
      cout << ",";
    }
  cout << "}" << endl;
  }
}

// print 함수는 똑같음
```

const로 실수로 argument가 수정되는 실수를 막아준다. 즉, 전달된 객체를 실수로 수정하지 못하게 막아준다. 그리고 또 하나 다른점이 있는데, print 함수에서, 값을 복사하는 대신 참조를 바탕으로 원래 argument를 **역참조(refer-back)** 한다. <br>
argument를 역참조한다는 것은 **다른 곳에서 정의한 객체를 참조한다**는 의미에서 참조와 같은 의미이다.

#### Pass by Reference

함수 안에서 argument를 수정해야하는 경우가 생기면? 다음 코드를 한번 보자. 

```cpp
//참조에 의한 전달 
void init(vector<double>& v){
  for (int i = 0; i <v.size(); i++) {
    v[i] = i;
  }
}

void g(int x){
  vector<double> vd1(10);
  vector<double> vd2(1000000);
  vector<double> vd3(x);

  init(vd1);
  init(vd2);
  init(vd3);
}
```

init함수 argument vector를 수정해야 하기 때문에 const를 사용하지 않았다. 즉, vector가 가르키는 **참조 그대로**를 전달 했다. <br>
Swapping을 사용하는 경우 자주 쓰는데, 다음 예시를 보자. 

```cpp
void swap(int& d1, int& d2){
  int temp = d1;
  d1 = d2;
  d2 = temp; 
}

int main(void){
  int x = 1, y = 2;

  cout << "x = " << x << ", y = " << y << endl; //스왑 전으로 x = 1, y =2
  swap(x,y);
  cout << "x = " << x << ", y = " << y << endl; //스왑 후 x = 2, y = 1
  return 0;
}

```

이렇듯 **참조에 의한 전달**은 함수가 넘겨 받은 어떤 객체든 직접 조작할 수 있는 강력한 방법이다. <br>
또한 C++ 표준 라이브러리에서 복사 가능한 모든 타입의 값에 대해 swap()함수를 제공해준다.

### 값에 의한 전달(Call by Value)과 참조에 의한 전달(Call by Reference)의 사용 
어떻게 사용해야 적재적소에 맞는 사용법일까? <br>
값에 의한 전달, 참조에 의한 전달, 상수 참조에 의한 전달은 어떻게하면 알맞게 사용하는 것일까? 

```cpp
void f(int a, int& r, const int& cr){
  ++a;  // 지역변수 a 변경
  ++r; // r이 가리키는 객체 변경
  ++cr; // const로 error
}
```

전달 받은 객체의 값을 변경하려면 const가 아닌 참조를 사용하면 되고, call by value는 **사본**만 전달하고 pass by const reference는 **전달 받은 객체의 값을 변경할 수 없도록 막는다.**

```cpp
void g(int a, int& r, const int& cr){
  ++a;  // 지역변수 a 변경
  ++r; // r이 가리키는 객체 변경
  int x = cr; //cr이 가리키는 객체를 읽기 
}

int main(void){
  int x = 0, y = 0, z = 0;

  g(x, y, z); // x = 0, y = 1, z = 0
  g(1, 2, 3); // Error, 참조 인자 r에는 참조 가능한 변수를 지정해야한다.
  g(1, y, 3); // cr은 const로 리터럴을 전달 할수 있다.

  return 0;
}
```
참조로 전달 받은 객체의 값을 고칠려면 당연히 객체를 전달해야한다. <br>
그리고, 정수 리터럴 2는 값을 저장한 객체가 이나리 **그냥 값(value)** 이다. 하지만 g함수의 argument인 r은 lvalue여야한다. 하지만 const 참조는 꼭 lvalue일 필요가 없다. <br>
초기화나 값에 의한 전달에서 변환을 수행할 수 있기 때문이다.

```cpp
 g(1, y, 3); // int __compiler_generated = 3;으로 g(1, y, __compiler_generated);와 같다. 
```
컴파일러가 생성한 객체를 **임시 객체(Temporary object)** 라고 하며, 일반적으로 다음과 같은 규칙을 따른다.

1. 매우 작은 객체에는 call by value를 사용한다. 
2. 수정할 필요가 없는 큰 객체를 전달 할 때 pass by const reference를 사용한다.
3. 참조 인자를 전달받은 객체를 수정하기 보다 값을 반환한다.
4. 꼭 필요한 때만 call by reference를 사용한다.

const가 아닌 참조를 인자로 받는 함수가 있다면, 그 함수 안에서 인자 수정해야한다고 가정 해야 한다.  <br>
3번 규칙은 함수에서 변수의 값을 변경할 때 몇 가지 선택권이 존재한다.

```cpp
int incr1(int a) { return a + 1;} // 새로운 값을 결과로 반환
void incr2(int &a) { ++a; } // 참조로 넘겨 받은 결과를 수정

int x = 7;
x = incr1(x); //명확한 코드
incr2(x); //모호한 코드
```
그럼 const가 아닌 참조 인자는 왜 사용할까? 다음과 같은 경우는 const가 아닌 참조가 필수적이기 때문이다. 

1. 컨테이너를 비롯한 큰 객체를 조작할 때
2. 함수 안에서 여러 객체를 변경할 때 (반면에 반환 값은 하나)

```cpp
// 두 벡터의 상응하는 위치 요소 중 큰 값은 v1, 작은 값은 v2로 넣는다.
void larger(vector<int>& v1, vector<int>& v2){
  if(v1.size() != v2.size()) {
    return 0; // 값이 다르면 그냥 종료, 책에는 error로 잡아준다. 
  }
  for(int i = 0; i < v1.size(); ++i){
    if(v1[i] < v2[i]) {
      swap(v1[i], v2[i]);
    }
  }
}

void f(){
  vector<int> vx;
  vector<int> vy;
  larger(vx, vy);
}
```
larger함수는 인자를 참조로 전달받는 방법이 합리적이다. <br>
일반적으로 여러 객체를 수정하는 함수는 피하는게 좋은데, 여러 값을 포함하는 클래스의 객체를 반환하는 등의 대안이 항상 있기 마련이고, 하나 이상의 인자를 수정하는 함수로 구성되는 프로그램은 많기 때문이다. <br>
특히, 포트란에서는 모든 인자를 참조로 전달한다. 이런 경우에는 참조에 의한 전달이나 상수 참조에 의한 전달을 사용하는게 좋다. <br>
**단지 복사를 피하려고 한다면** 상수 참조에 의한 전달을 사용하면 된다. <br>
상수가 아닌 참조 인자를 사용하는 함수를 만나면 그 함수가 인자를 변경한다고 가정해야 하기 때문에, 그 함수의 유일한 목적이 인자를 변경하는 일이므로, 함수를 호출할 때 그 함수가 원래의 목적을 제대로 수행하는지를 살펴보자 

### constexpr 함수
함수는 계산 과정을 표현한다. 컴파일 시점에 이 계산을 수행해야 할 때도 있는데, 이렇게 컴파일러가 계산을 하면 실행 시점에 동일한 계산을 계속 반복하는 일을 막을 수 있다. <br>
계산을 이해하기 쉽게 하고자 함수를 사용하고 싶을 경우가 있는데, 이럴 경우 함수를 상수 표현식으로 만들 때 가 있다. 컴파일러가 함수를 계산하게 하려면 constexpr 함수를 선언하면 된다. 주로 함수 인자로 상수 표현식을 취하는 경우 컴파일러가 constexpr 함수를 계산 할 수 있다. <br>
상수가 필요한 곳에서 사용하는 경우가 아니면 constexpr 함수는 보통 함수와 동일하게 동작하고, 상수 표현식에서 constexpr 함수를 호출하면 인자가 상수 표현식인 경우 컴파일러가 함수를 계산하고, 인자가 상수 표현식이 아니라면 오류가 발생한다. 하지만 컴파일러가 계산할 수 있을 정도로 **간단해야한다.** <br>
C++11에서는 constexpr가 하나의 return 구문으로만 이뤄져야 하고 C++14에서는 간단한 루프도 가능하다. 그리고 constexpr 함수는 부작용이 없어야 한다. 즉, 함수의 반환 값을 대입하거나, 이를 이용해 초기화하는 변수를 제외한 함수 몸체 외부의 변수를 변경하면 안된다.  다음 예시를 보자. 

```cpp
int glob = 9;
//밑의 함수는 오류로, 반환 값이 없다.
constexpr void bad(int& arg){
  ++arg; // 인자를 바탕으로 호출하는 쪽의 상태를 변경하기 때문에 오류 
  glob = 7; // 비지역 변수를 변경하기 때문에 오류  
}
```

위의 코드는 규칙을 위반하는 함수이다. 그리고 컴파일러가 constexpr 함수가 충분히 간단한지 판단할 수 없으면, 그 함수는 오류로 간주한다. 

### 네임스페이스
함수 안의 코드를 조직하는 데 블록을 사용하고, 함수와 데이터, 타입을 한 타입으로 조직화할 때 클래스를 사용한다. <br>
함수와 클래스 모두 다음과 같은 역할을 한다.

1. 프로그램 안에서 이름 충돌을 걱정하지 않고, 구성 요소를 정의할 수 있게 해준다.
2. 정의한 무언가를 가리키는 이름을 제공한다. 

아직, 타입을 정의하지 않고, 클래스와 함수, 데이터 타입을 조직화 하는 방법을 배우지 않았지만, 이와 같이 선언을 그룹핑하는 언어적 매커니즘을 namespace라고 한다.  <br>
그리고 네임스페이스 이름 또는 클래스 이름과 멤버의 이림을 ::으로 결합한 이름을 **완전 한정 이름(FQN, Fully Qualified Name)** 이라고 한다.

### using 선언과 using 지시자
완전 한정 이름을 사용하기 귀찮을 때가 있다, 그럴 때 사용하면 된다
```cpp
using std::string;
using std::cout;

using namespace std;
```

그럼 std::를 붙이지 않고도 cout, string등을 사용할 수있다 참고로 벡터도 std::vector라고 해야하는데 vector만 사용할 수 있다. <br>
하지만 보통은 std처럼 응용 분야에서 잘 알려진 네임스페이스가 아니라면, using 지시자를 사용하는건 지양해야한다. 남용을 하면 어떤 이름이 어디서 왔는지 추적하기 어려워지고, 이름간의 충돌이 발생할 수 있기 때문이다. 
대신 네임스페이스 이름을 이용한 명시적 한정과 using 선언을 이용하면 이런 문제에서 벗어날 수 있지만, 헤더 파일에 using 지시자를 넣는건 나쁜 습관이다.  
그리고 개인적으로 꼭 std::를 붙인걸 추천한다. 
