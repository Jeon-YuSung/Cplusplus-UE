# 6장 프로그램 작성(Programming)

## 6-1 문제
 프로그래밍의 시작은 **문제(Problem)** 로부터 시작한다. 즉, 프로그램을 바탕으로 해결에 도움을 줄 수 있는 문제가 필요하다. 그리고 이러한 문제를 이해하는 일이 좋은 프로그램을 만드는 지름길 이다. <br>
 그럼 현재, 지금 단계에서 필요한 프로그램은 무엇일까? <br>

1. 설계 기법과 프로그래밍 기법을 잘 반영하는 프로그램
2. 프로그래머가 해야 할 의사 결정과 그에 필요한 고려사항을 잘 보여주는 프로그램
3. 새로운 프로그래밍 언어 기능을 너무 많이 요구하지 않는 프로그램
4. 설계에 대해 고민해볼 여지가 있을 정도로 복잡한 프로그램
5. 문제 해결 방법에 있어 다양한 시도가 가능한 프로그램
6. 쉽게 이해할 수 있는 문제를 다루는 프로그램
7. 가치가 있는 문제를 해결하는 프로그램
8. 완벽한 예시가 될 수 있고, 이해할 수 있을 정도로 작은 해답을 지닌 프로그램
 이런 기준에서, 만들려고 선택한 프로그램은 '입력 받은 표현식에 포함된 일반적인 산술 연산을 컴퓨터로 처리하는 프로그램'이다. 즉, 간단한 계산기이다.

--------------------------------------------------------------

## 6-2 문제 고찰 
 계산기를 만들려면 어찌해야할까? 일단, 문제를 분석해보고 어떻게 해결할지 생각해보자. <br>
우선 프로그램이 무슨 일을 해야 할까? 프로그램과 유저가 어떻게 상호작용을 해야할까? 이런 고민을 해야 프로그램이 어떻게 원하는 일을 할지 생각할 수 있다. <br>
 그리고, 종이에 적거나, 동료과 토론을 해서 아이디어나 아이디어의 허점을 찾아내는 데도 좋다. <br> 
 그리고 모든 문제에 적용할 수 있는 일반적인 문제 해결 전략은 없기 때문에, 새로운 문제가 발생하면 또 고민해보자. <br>
 그리고 6장과 7장에서 배우는 문제에 대한 부분적인 해답과 아이디어, 실수를 바탕으로 프로그램의 최종 버전에 다다르는 방식이 최종 버전이 매우 **중요**하고, 이러한 과정은 항상 접하는 언어의 기술적 세부 사항보다 중요하기 때문이다. 

**프로그램 개발 단계**

본격적으로 개발하기 전에, 개발 단계의 용어들을 알아보자. 주어진 문제를 해결하다 보면 결국 다음과 같은 단계를 반복하기 때문이다. 
1. **분석(Analysis)** → 해야할 일을 명확히 하고, 그에 대해 현재 시점에서 이해한 바를 설명하는 문서를 남긴다. 이를 요구사항 or 명세라고 한다. 참고로, 해결할 문제의 규모가 커질수록 요구사항 파악은 매우 중요하다.
2. **설계(Design)** → 시스템의 전체적인 구조를 정하고, 구현에 어떤 부분이 포함돼야 하며, 각 부분은 어떻게 상호작용하는지 정한다. 라이브러리를 비롯한 어떤 도구가 프로그램을 구조화하는 데 도움이 될지 결정하는 일도 설계 고려사항의 일부이다. 
3. **구현(Implementation)** → 코드를 작성하고, 디버깅하고, 의도대로 동작하는지 테스트한다. 

 **전략**

프로그래밍 프로젝트에 도움이 될만한 몇 가지 전략을 제시한다. 

1. 풀어야 할 문제가 무엇인가? 우선 무엇을 달성해야 하는지 구체화해야 한다. 문제에 대한 설명을 기술하거나, 그 설명이 진짜 의미하는 바를 이해해야 한다. 이 때 **사용자의 관점**에서 문제를 바라보자, 즉 프로그램이 어떻게 작업을 수행하는지가 아니라, 무엇을 해야하는지를 알아야한 한다. **이 프로그램이 나에게 어떤일을 해줄까?** 혹은 **이 프로그램과 어떻게 상호작용 하는가**를 질문하자. 프로그래머 이전에 대부분은 컴퓨터 사용자로서 많은 경험을 가지고 있음을 기억하자. → User experience 중시하자 
2. 문제의 정의가 명확한가? 현실의 문제는 그렇지 않다. 그러니 더욱 문제를 정확하게, 명확히 하려고 노력해야한다. 그리고 너무 많은 요구를 하는 일도 주의하자. 원하는 바를 밝혀내다 보면 너무 욕심을 내거나 야심에 차기 쉽기 때문이다. 요구 사항을 간단하게 해야 프로그램을 구체화하고, 이해하고, 사용하고, 구현하기 쉽다. 이러한 경험을 바탕으로 기존 프로그램보다 발전된 Ver2.0도 만들 수 있기 때문이다. → 지속적으로 업데이트 해주자
3. 주어진 시간과 기술, 도구를 감안 했을 때 해결이 가능한 문제인가? 완성할 수 없는 프로젝트를 시작하는 일은 아무 의미가 없다. 모든 요구 사항을 구현과 테스트할 수 있는 충분한 시간이 없다면 아예 시작하지 않는 쪽이 현명하다. 아니면, 더 많은 자원을 요청하거나, 작업을 단순화할 수 있도록 요구 사항을 수정해야 한다. → 견적을 잘 짜라 견적을 짜는 것도 실력이다.
4. 프로그램을 다루게 쉽게 작은 부분으로 나눈다, 현실의 문제를 해결하는 가장 작은 프로그램이라도 프로그램을 분할 하기엔 충분히 크다 → **분할과 정복**
5. 도움이 될만한 도구나 라이브러리등을 알고 있는가? 단순히 STL 말고도 그래픽, GUI, 행렬 라이브럴리등... 라이브러리를 잘 사용하면 시간을 절약할 수 있고, 그 시간 만큼 다른 곳에 투자가 가능하다 → 필요하면 직접 만들 수 있지만 남이 잘 만들어논 것을 잘 가져다 쓰자.
6. 주어진 문제에 대한 해법에서 분리해서 설명할 수 있는 일부를 찾아보자.
7. 문제의 핵심을 다루는 간단한 버전의 프로그램을 만들어보자. 처음 시작할 때는 문제를 잘 파악하지 못 하기에, 문제를 잘 알고 있다고 생각할 수 있어도 그렇지 않을 수 있다. 그러니 문제에 대한 고민, 분석, 설계, 구현을 하는 것이 좋은 프로그램을 작성하는 데 필요한 문제에 대한 확고한 이해를 얻을 수 있다. → 작은거라도 프로토타입버전으로 만들어보자.
8. 문제를 이해 및 아이디어와 도구 적용
9. 문제를 해결하기 위해 문제 정의의 세부 사항을 변경해야 하는지 알아보자. 처음에 문제를 분석하고 설계할 때부터 모든 사항을 예측할 수 없다 그러니 테스트를 하면서 피드백을 얻어야 한다. → 모든 사항을 예측 할 수 있으면 그건 완벽한 프로그램이다, 하지만 그런건 존재하지 않는다.
10. 프로토타입 버전의 부분들을 이용해 전체 솔루션을 만들자. 모든 코드를 한 방에 작성하기 보다 잘 동작하는 부분을 하나씩 작업해서 프로그램을 완성해나가는 방법이 이상적이다. → **이 또한 분할과 정복**

----------------------------------------------------------------

## 6-3 계산기로 복귀 

계산기를 만들어보자 GUI는 아직이니 콘솔로 이용해서 만들어야한다. <br>
2 + 2 = 4 <br>
2 * 4 + 2 = 10 <br>
2 + 3 - 25 / 5 = 0 <br>
여기서 2+2, 2*4+3 같은 표현식을 제외한 나머지 부분은 프로그램이 만들어낸 출력이고, 표현식: 이라는 프롬프트를 사용자에게 출력하는데, 표현식을 입력하고 개행 문자를 누르세요라고 할 수 있지만 길다 하지만 반대로 > 표현은 너무 짧고 무슨 의미 인지 모른다. 이런식으로 미리 사용 예를 만들어보는 것이 중요하다. 즉, 프로그램이 해야 하는 최소한의 작업이 무엇인지 실용적으로 정의할 수 있다. 설계 및 분석 과정에서 이를 유스케이스(Use Case)라고 한다. <br>
혹은 명확하게 논리적으로 적어보는 방법도 있는데, 이를 **의사 코드(Pseudo Code)** 라고 한다. <br>
read a line <br>
cacluate <br>
write result <br>
식으로 코드를 작성해야 할지 정확히 알 수 없는 설계 초기에 이런 방법을 자주 사용한다. <br>

계산한다? 함수를 호출할까? 그럼 parameter는? 혹은 argument는?  이런 것들을 고민하면서 설계하도록 하자. 

**토큰(Token)** 

Token이란 숫자나 연산자라를 비릇한 우리가 **한 단위(Unit)** 으로 생각하는 무언가를 나타내는 문자열이다. <br>

```cpp
x = 10 + 20;
```
위의 예시 코드에서 <br>
x → 식별자(Identifier) <br>
\= → 연산자(Operator) <br>
10 → 숫자(Number literal) <br>
\+ → 연산자(Operator) <br>
20 → 숫자(Number literal) <br>
\; → 구분자(Delimiter) <br>
이런식으로 나눌 수 있다. <br>
토큰화는 대부분의 텍스트 분석에서 기초가 된다. <br>
그럼 토큰을 어떻게 표현해야할까? 각 토큰의 시작과 끝 위치를 기억할 수 있고, 숫자를 문자열로 저장하면 나중에 그 값을 알아내야 하고.... 이런식이면 너무 지저분해지거나 복잡해지기에, 관례적으로 토큰을(kind, value)의 쌍으로 표현한다. (STL의 MAP, std::pair와 비슷 → 하나의 데이터 단위를 (이름, 값) 형태로 묶어서 관리하는 원리이기 때문) kind는 토큰이 숫자인지, 연산자인지, 괄호인지 알려주고 숫자 토큰의 경우 value에 숫자 값을 저장한다. 

토큰을 구현할 때, 구조체나 연산자로 구현이 가능하다. 

```cpp
class Token1{
public: //클래스는 기본이 private이기에 외부에서 접근할려면 public 선언이 필요
 char kind;
 double value;
};

struct ToKen2{
public: //구조체는 기본이 퍼블릭이지만 명시적으로 함
 char kind;
 double value; 
};
```

책에 class키워드를 **사용자 정의 타입**이라고 나와있는데, 일단 그전에 구조체와 클래스의 차이에 대해 알아보자. 
class와 struct는 거의 비슷한 문법 구조이지만, **기본 접근 제어자(default access modifier)와 상속 시 접근 제어**에서 차이가 있다. 즉, struct는 기본 멤버 접근 제어자나 기본 상속 형태가 **public**이지만, class는 반대로 **private**이다.  <br>
또한 struct는 데이터들의 집합, 혹은 데이터를 담기 위한 단순한 컨테이너이기에 **값을 여러 개 모아 하나의 묶음으로 관리**하기 때문에 함수 기능이 거의 없고 데이터만 노출되고, 외부에서 쉽게 접근이 가능하다. <br>

```cpp
struct Point {
    double x;
    double y;
};

int main() {
    Point p;
    p.x = 3.5;   // 직접 접근 가능
    p.y = 4.2;
}
```

반대로 class는 객체(데이터 + 기능)이 중심인데 **데이터를 숨기고, 행동(메서드 혹은 함수)을 통해 접근하도록 설계하는 관점**이다. 그래서 클래스를 설계할 때, 데이터 + 동작을 하나의 단위로 묶기 때문에 데이터는 private로 숨기고 public 함수로 통해서만 동작하도록 설계하기 때문에 외부 코드가 내부 상태를 **직접 변경**할 수 없어서 잘못된 동작을 방지한다. (캡슐화)

```cpp
class Point {
private:
    double x, y;   // 외부에서 직접 접근 불가

public:
    void set(double a, double b) { x = a; y = b; }
    inline void print() const { cout << "(" << x << ", " << y << ")\n"; }
};

int main() {
    Point p;
    p.set(3.5, 4.2);   // 허용
    p.print();         // 허용
    // p.x = 10; 접근 불가
}
```

이제 왜 class가 **사용자 정의 타입**인지를 알아보자. <br>
일단 C++에서 type이 뭘까? → 데이터의 형식과 동작을 정의한 것 <br> 
그리고 예약어로 int, doulbe, char 등이 C++표쥰이 미리 정의한 기본 타입(Built-in type)이다. <br>

```cpp
class Point {
public:
    int x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
};
```

위의 class Point는 사용자가 정의한 새로운 **데이터 타입**이다. 

```cpp
int main(void){
 Point p1;      // Point 타입의 변수 선언
 p1.x = 10;
 p1.y = 20;
 p1.move(5, 5);
 return 0;
}
```
이처럼 포인터를 int나 double처럼 사용할 수 있고, 또한 calss안에 함수를 선언할 수 있다 <br> 
그렇기 때문에 calss는 단순한 데이터뿐만 아니라 행동(메서드,함수)도 함께 묶어서 하나의 **추상적인 타입**을 만드는 도구이다. (이 책의 초반(4장)을 봐라, 강조하는 2가지가 있다. 추상화와 분할 정복) <br>
또한, class는 데이터, 행동(함수, 메서드),  접근 제어, 상속 및 다형성까지 포함할 수 있으며, 프로그래머가 직접 설계하고, 변수 선언 시 새로운 데이터 형식처럼 쓸 수 있기 때문에 **가장 강력한 사용자 정의 타입**으로 볼 수 있다. 

이렇게 된김에, 사용자 정의 타입에는 무엇이 있을까? <br>
User-defined type, UDT에는 다음과 같은 애들이 있다 

| 종류                  | 예시                             | 설명                                |
| ------------------- | ---------------------------------- | ------------------------------------|
| `struct`            | `struct Point { int x, y; };`      | 단순 데이터 구조                     |
| `class`             | `class Circle { double r; };`      | 데이터 + 기능 캡슐화                 |
| `enum`              | `enum Color { Red, Green, Blue };` | 한정된 상수 집합                     |
| `union`             | `union Data { int i; float f; };`  | 여러 타입을 같은 메모리 공간에서 공유  |
| `typedef` / `using` | `using MyInt = int;`               | 기존 타입에 별칭 부여                 |

그리고 C++ 사용자 정의 타입은 크게 **공개 인터페이스(public:) 와 상세 구현(private:)** 두 부분으로 이루어지기 때문에, 이를 바탕으로 사용자가 해당 타입을 편리하게 사용하는데 필요한 내용과 타입을 구현 하는 곳과 사용자에게는 쓸모가 없는 세부 사항이 있는 부분으로 구분할 수 있다. 또한 분리를 하면 코드를 **구조화**하는데 큰 도움이 된다. <br>
즉, public 부분은 사용자가 필요한 내용만 포함되며 주로 함수로 구성되고, private부분은 public 함수를 구현하는 데 필요한 내용위주로, 사용자가 알 필요 없고, 직접 사용할 수도 없는 지저분한 세부 사항에 관련된 데이터와 함수를 포함한다 

아무튼 계산기를 만들 때 어떻게 만들지 고민해보도록 하자 <br> 
main함수에만 다 넣지 말고도 여러 방법을 통해 더 상세히 만들 수 있다. <br>
자 다시 돌아와서, 계산기를 만들 때 표현식 1개만 만들고 끝나는 프로그램은 지루하고 심심하지 않은가? <br>
그럼 1번 실행해서 여러 표현식을 계산하는 걸로 만들면되지 않을까? <br>
의사코드를 수정해보자. 

while(프로그램 실행되는 동안){ <br>
 read a line // 한 줄 입력 <br> 
 calculate // 계산 <br>
 write result // 결과 출력 <br>
 stop // 프로그램을 멈추는 기능을 넣어보자 (책에는 안 나와 있음) <br>
} <br>

 뭐... 사용자가 계산을 여러 번 할 때마다 프로그램도 여러 번 실행하는 방법도 있지만, 이는 OS를 공부하면 알겠지만... 현대 OS에서 느린 일이기에 그런 식으로 할 수는 없다. <br>
보면서 생각난건데, 만약에 변수도 허용하는 계산기면? <br>

v = 7 <br>
m = 9 <br>
v + m <br>

귀찮아진다.. 물론 필요하다면 만들 수 있겠지 PI = 3.14처럼 변수로 표현로 할 경우가 필요할 수 도 있으니깐, 암튼 일단 초기 프로젝트이기 때문에, 만약에 변수를 허용하는거라면 프로젝으틔 규모가 더 커질 수 있다. 이처럼 프로젝트 초기에 **기능의 함정**을 피하는 것도 중요하다. 대신 **가장 필수적인 기능은 반드시 간단한 버전부터 구현하자**

----------------------------------------------------------------------
## 6-4 문법

여기서부터는 프로그래밍 언어구조론, 컴파일러 개념 혹은 다른 CS지식이 필요할 수 있다. 그러니 최대한 간단하게 설명하고 넘어 가도록하겠다. <br> 
아마 구문 트리(혹은 트리 구조), 파서 종류, BNF 문법등등...을 알아야할 수도 있기 때문이다. 

문법에 따라 Token stream을 읽는 과정을 Parsing이라고 하며, 파싱을 수행하는 프로그램을 parser나 구분 분석기(syntax analyzer)라고 한다. 이걸 하나씩 뜯어서 분석해보자 <br>

1. Token Stream <br>
말 그대로 **토큰들의 흐름(연속된 나열)** Lexical Analysis(어휘 분석) 단계를 거쳐 만들어진 결과물이다. <br>

```cpp
x = 10 + 20; 
```
위의 코드를 어휘 분석기(lexer)가 다음과 같은 토큰 스트림(Token Stream) 으로 변환할 수 있다. 

```
{ ("identifier", "x"), ("operator", "="),
  ("number", 10), ("operator", "+"),
  ("number", 20), ("delimiter", ";") }
```

2. Parsing, Syntax Analysis
Token Stream이 문법(Grammar)에 맞는지 검사하고, 그 구조를 트리(Tree) 형태로 만드는 과정이다. <br>
즉, 이 문장이 프로그래밍 언어의 문법 규칙에 맞는가? <br>
그 문장은 어떤 구조(식, 문장, 함수 호출 등)를 가지는가?를 분석하는 단계이다. <br>

3. Parser의 역할 
파서는 문법 규칙(Grammar)을 기준으로 Token Stream을 해석하고, 문법 구조를 트리로 표현(Syntax Tree 또는 Parse Tree)하고, 오류 탐지를 해서 문법에 어긋나는 코드(if (x 5) {...} 등)가 있으면 “Syntax error”로 잡아냅니다.

```
   (=)
  /   \
 x    (+)
     /   \
   10     20
```

파서가  x에 (10 + 20)을 대입하는 문장을 이해하는 것이다. <br>
정리하자면, 파싱은 **문법적으로 올바른 구조인지 확인하는 과정**이고, 파서는 **그 과정을 수행하는 도구**이다. 

**문법 작성**

문법 규칙을 정할 때는 프로그래머가 경험과 직관을 통해서 정한다. <br>
간단한 문법 정도는 매우 직관적으로 작성할 수 있으나, 다음과 같은 사항은 컴파일러 문법 설계의 핵심이기에 알아두자. 
1. 규칙과 토근의 차이점을 이해한다.
2. 한 규칙 다음에 다른 규칙을 배열하는 방법을 안다 - 나열(Sequencing)
3. 선택적인 패턴을 표현하는 방법을 안다 - 선택(Alternation)
4. 반복되는 패턴을 표현할 줄 안다 - 반복(Repetition)
5. 어떤 문법 규칙부터 시작해야 하는지 이해한다.

그리고 여러 교재와 다양한 파서 시스템에서는 서로 다른 표기법 관례와 용어를 사용한다. <br>
예를 들어 <br>
토큰(Token) → 터미널(Terminal) <br> 
규칙 → 비터미널(Non-terminal)이나 프로덕션(Production)이라고도 한다. 

----------------------------------------------------------------------

6-5부터는 생략 <br>
책으로 더 상세한 내용이 나와 있어 보는걸 추천한다. 
