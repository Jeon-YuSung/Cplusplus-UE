# Ch8 - 동적 계획법1 (Dynamic Programming1)
  
  - **<목표>** 
    + Dynamic Programming을 적용할 수 있는지 분석 가능
    + Memoization과 Tabulation 기법을 서로 비교 및 분석 가능
    + Memoization을 위한 적절한 캐시 사용 방법을 적용 가능
    + 직관적인 전수 조사 방법을 통해 주어진 문제를 분석 가능
    + 점진적으로 최적화 알고리즘을 구현하면서 Dynamic Programming을 가능

---------------------------------------------------------------

### <개요>
  - 동적 계획법 (Dynamic Programming)이란? → 분할 정복 패러다임 개념을 확장하여, 특정 분류의 문제에 사용함.
  - 주로, 재귀적으로 표현할 수 있는 문제는 아마 다이나믹 프로그래밍이 가장 적합 할 수 있음.
  - 다이나믹 프로그래밍이 사용되는 몇 가지 예시
    1. 조합(특정 기준을 만족하는 시퀀스의 조합 또는 순열의 개수 구하기)
    2. 문자열과 시퀀스(편집 거리 - Edit Distance), 최장 공통 부분 시퀀스(Longest Common Subsequence),  최장 증가 부분 시퀀스(Longest Increasing Subsequence)
    3. 그래프의 최단 경로 문제
    4. 머신 러닝 (음성/얼굴 인식)
등 다양한 문제에 적용할 수 있음.

피보나치 수열과 같은 재귀적인 관계를 가진 문제가 있으며, 피보나치 수열 문제는 보통 **하향식 해법(Top-down Solution)** 이라고 함.  <br>
전체 해결 방법을 트리 형태로 구성한 재귀 트리(Recursion Tree)의 맨 꼭대기에서 시작하여 기저 조건에 닿을 때 까지 아래 쪽 가지(Branch)로 이동하기 때문임  <br>
최종 해답을 찾기 위해 여러 개의 부분 문제(Subproblem)또는 중간 단계 문제를 풀어야 한다는 점을 알 수 있음.  <br>
또한 피보나치 수열은 **중복되는 부분 문제(Overlapping Subproblem)** 라는 특징을 가지고 있음  <br>
 → 이 점이 분할 정복 문제와 가장 큰 차이 인데, 분할 정복 문제는 전체 문제가 독립적인 부분 문제로 나뉘는 경향이 있지만, 다이나믹 프로그래밍은 같은 부분 문제가 반복적으로 나타나고, 여러 부분 문제가 서로 완전히 동일하는 것이 특징임  <br>
 즉, **최적 부분 구조(Optimal Substructure)** 라고 부르며, 전체 문제에 대한 최적해가 부분 문제의 최적해의 조합으로 표현할 수 있을 때를 최적 부분 구조라고 함. <br>
 다이나믹 프로그래밍에서는 중복되는 부분 문제와 최적 부분 구조라는 이 두 속성을 만족해야 함. <br>
 문제의 복잡도가 입력이 증가함에 따라 기하급수적으로 증가하는 경향이 있지만, 최적 부분 구조를 통해 복잡도를 크게 줄일 수 있음. <br>
 동적 계획법에서는 본질적으로 **반복 계산을 피하기 위해** 이전ㅇ에 해결한 부분 문제의 해답을 캐시(Cache)에 정하는 방식을 사용함. <br>

 --------------------------------------------------------------------------------------------------

 ### Memoization - Topdown Solution
  - 메모제이션은 암기를 뜻 Ch8 - 동적 계획법1 (Dynamic Programming1)
  
  - **<목표>** 
    + Dynamic Programming을 적용할 수 있는지 분석 가능
    + Memoization과 Tabulation 기법을 서로 비교 및 분석 가능
    + Memoization을 위한 적절한 캐시 사용 방법을 적용 가능
    + 직관적인 전수 조사 방법을 통해 주어진 문제를 분석 가능
    + 점진적으로 최적화 알고리즘을 구현하면서 Dynamic Programming을 가능

---------------------------------------------------------------

### <개요>
  - 동적 계획법 (Dynamic Programming)이란? → 분할 정복 패러다임 개념을 확장하여, 특정 분류의 문제에 사용함.
  - 주로, 재귀적으로 표현할 수 있는 문제는 아마 다이나믹 프로그래밍이 가장 적합 할 수 있음.
  - 다이나믹 프로그래밍이 사용되는 몇 가지 예시
    1. 조합(특정 기준을 만족하는 시퀀스의 조합 또는 순열의 개수 구하기)
    2. 문자열과 시퀀스(편집 거리 - Edit Distance), 최장 공통 부분 시퀀스(Longest Common Subsequence),  최장 증가 부분 시퀀스(Longest Increasing Subsequence)
    3. 그래프의 최단 경로 문제
    4. 머신 러닝 (음성/얼굴 인식)
등 다양한 문제에 적용할 수 있음.

피보나치 수열과 같은 재귀적인 관계를 가진 문제가 있으며, 피보나치 수열 문제는 보통 **하향식 해법(Top-down Solution)** 이라고 함.  <br>
전체 해결 방법을 트리 형태로 구성한 재귀 트리(Recursion Tree)의 맨 꼭대기에서 시작하여 기저 조건에 닿을 때 까지 아래 쪽 가지(Branch)로 이동하기 때문임  <br>
최종 해답을 찾기 위해 여러 개의 부분 문제(Subproblem)또는 중간 단계 문제를 풀어야 한다는 점을 알 수 있음.  <br>
또한 피보나치 수열은 **중복되는 부분 문제(Overlapping Subproblem)** 라는 특징을 가지고 있음  <br>
 → 이 점이 분할 정복 문제와 가장 큰 차이 인데, 분할 정복 문제는 전체 문제가 독립적인 부분 문제로 나뉘는 경향이 있지만, 다이나믹 프로그래밍은 같은 부분 문제가 반복적으로 나타나고, 여러 부분 문제가 서로 완전히 동일하는 것이 특징임  <br>
 즉, **최적 부분 구조(Optimal Substructure)** 라고 부르며, 전체 문제에 대한 최적해가 부분 문제의 최적해의 조합으로 표현할 수 있을 때를 최적 부분 구조라고 함. <br>
 다이나믹 프로그래밍에서는 중복되는 부분 문제와 최적 부분 구조라는 이 두 속성을 만족해야 함. <br>
 문제의 복잡도가 입력이 증가함에 따라 기하급수적으로 증가하는 경향이 있지만, 최적 부분 구조를 통해 복잡도를 크게 줄일 수 있음. <br>
 동적 계획법에서는 본질적으로 **반복 계산을 피하기 위해** 이전ㅇ에 해결한 부분 문제의 해답을 캐시(Cache)에 정하는 방식을 사용함. <br>

 --------------------------------------------------------------------------------------------------

 ### Memoization - Topdown Solution
암기를 뜻 하는 **메모리제이션(Memorization)** 과 헷갈리지 않도록 주의, **메모이제이션(Memoization)** 은 메모를 한다는 의미. <br>
메모이제이션을 사용하면 최적 부분 구조 특성을 갖는 피보나치 수열에 대해 탑다운 해법으로 재구성이 가능. <br>
즉, 피보나치 수열 문제에서 상당히 많은 중복 작업을 제거하고, 부분 문제의 해를 캐시에 넣어 사용하는 기술로 모든 다이나믹 프로그래밍에 적용 가능함, 대신 다음과 조건을 필요함.

1. 고유한 특성은 유지하면서, 서로 다른 상태의 유사성을 활용하는 캐시 사용 방식을 고안할 수 있어야 함.
2. 사용 가능한 스택 공간을 초과하기 전에 필요한 모든 부분 문제의 해답을 누적할 수 있음.

첫 번째 조건은 부분 문제 해법을 캐시에 인덱싱하여 저장하는 방법이 효율적이고 유용해야 한다는 점을 의미 함  <br>
즉, 같은 의미의 부분 문제 햅법을 정확하게 일치시켜 저장해야 함. 또한 너무 특정 상태에만 치우치게 동작하면 안 됨.  <br>
두 번째 조건은 스택 오버플로(Stack overflow)가 발생할 가능성에 관한 것으로, 너무 많은 재귀 함수 호출을 필요로 하는 하향식 접근 방법에서 근본적으로 발생하는 문제. <br>
즉, 프로그램이 정해진 호출 스택 메모리 보다 많은 메모리를 사용할 때 발생 함으로, 주어진 문제가 재귀 호출을 너무 많이 필요한 경우에는 메모이제이션을 사용하지 못 할 수 있음.  <br>
그렇기에 어떤 방법을 사용할지 선택하기 엪아 주어진 문제의 잠재적인 복잡도를 평가하는 작업은 매우 유용함.

-----------------------------------------------------------------------------------------------

### Tabulation - Bottom-up Soltuon
 
