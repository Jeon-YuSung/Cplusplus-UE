# Ch1. 리스트, 스택, 큐

### 개요
  * 자료구조에는 선형구조와 비선형 구조가 존재.
  * 선형 구조는 정적 자료구조인 Array와 동적 자료구조인 연결 리스트, 스택, 큐가 존재.
  * 비선형 구조에는 트리와 그래프가 존재함

-----------------------------------------------

 * **연속된 자료 구조와 연결된 자료구조**
   - 효율적인 데이터 구조를 선택하기 위한 지표로 알고리즘 복잡도 또는 **시간 복잡도**를 선택함.
   - 시간 복잡도는 특정 작업을 수행하는데 걸리는 시간을 데이터 크기에 대한 수식으로 표현하는 방법.
  
 * **연속된 자료 구조(Contiguous data structures)**
   - 모든 원소를 단일 메모리 청크(chunk)에 저장.
   - 모든 원소는 같은 크기의 메모리를 사용하고 sizeof(type)으로 표시.
   - 첫 번째 원소의 메모리 주소를 시작 주소(BA, base Address)라고 하고, 모든 원소는 같은 타입이기에 두 번째 원소는 BA + sizeof(type) 세 번째 주소는 BA + 2 * sizeof(type)이 됨 즉, i번째 주소에 접근하려면 BA + i * sizeof(type)을 사용함.
   - 또한 접근 시간이 항상 일정하기 때문에 **O(1)** 로 표기 함.
   - 배열의 유형은 정적 배열(static array), 동적 배열(dynamic array)로 나눌 수 있는데, 정적 배열은 선언된 블록이 끝나면 소멸되는 반면, 동적 배열은 프로그래머가 생성할 시점과 해제 시점을 자유롭게 정할 수 있음. 그리고 두 가지 유형은 다양한 연산에서 동일한 성능을 보임.
   - int arr[size];  → 정적 배열
   - int* arr = (int*)malloc(size * sizeof(int));  → C에서의 동적 배열 선언
   - int* arr = new int[size];  → C++에서의 동적 배열 선
   - 정적 배열은 스택 메모리에 할당되어 함수가 벗어날 때 자동으로 해제되지만, 동적 배열은 힙 영역에 할당되기 때문에 사용자가 직접 해제하기 전 까지 유지가 됨.
   - 배열은 캐시 지역성(cache locality)이 좋은데, 이는 각 원소가 서로 인접하기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시를 가져오고, 다시 주변 원소에 접근할 때 해당 원소를 캐시에서 가져오게 됨. 시간 복잡도에는 영향을 주지 않지만, 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 장점이 있음.
  
   - 정리하자면, 모든 데이터가 메모리에 연속적으로 저장되고, 임의의 원소에 즉각적인 접근이 가능함.
   - 또한 데이터가 연속적으로 저정되어 있기 때문에, 캐시 지역성 효과를 볼 수 있어 모든 데이터를 순회하는게 매우 빠름
   - 데이터를 저장하기 위해 정확하게 데이터 크기만큼의 메모리를 사용함. 
     
 * **연결된 자료 구조 (Linked data structures)**
   - 노드(node)라는 여러 개의 메모리 청크에 데이터를 저장.
   - 서로 다른 메모리 위치에 저장됨.
   - 연결 리스트에서의 각각의 노드는 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가지고 있음.
   - 맨 마지막 노드에서는 다음 노드의 포인터 대신에 끝을 나타내는 NULL를 가짐
   - 특정 원소에 접근하려면 리스트의 시작 부분 헤드(head) 부분부터시 시작해서 원하는 원소에 도착할 때 까지 next 포인터를 따라 이동해야 함. 즉, i 번째 요소에 접근하라면 연결 리스트의 내부를 i번 이동하는 작업이 필요함
   - 원소의 접근 시간은 노드 개수에 비례하기 때문에, 시간 복잡도는 O(*n*) 표현.
   - 포인터를 사용하기 떄문에 원소의 삽입이나 삭제를 빠르게 수행할 수 있음.
   - 삽입하는 방법은 1. 노드를 생성, 2. 각 노드의 포인터(next)를 수정(기존의 포인터를 삭제하고 새로운 노드에 연결)하여 삽입 할 수 있음.
   - 삭제 또한 삽입과 마찬가지로 삭제할 원소가 더 이상 연결리스트에 연결되어 있지 않도록 포인터를 수정하면 됨.
   - 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할 수 없음.
  
   - 정리하자면, 데이터는 노드에 저장되지만, 노드는 메모리 곳곳에 흩어져 있고, 임의의 원소에 접근하는 것은 헤더부터 접근하기 때문에 선형 시간 복잡도를 가져 느린 편임.
   - 캐시 지역성 효과가 없어 모든 데이터를 순회하는 것도 느리지만, 각 노드에서 포인터 저장을 위해 여분의 메모리를 사용함.
  
   - 참고로 C언어에서는 구현을 직접 동적 자료구조인 연결 리스트, 스택, 큐가 존재.
  * 비선형 구조에는 트리와 그래프가 존재함

-----------------------------------------------

 * **연속된 자료 구조와 연결된 자료구조**
   - 효율적인 데이터 구조를 선택하기 위한 지표로 알고리즘 복잡도 또는 **시간 복잡도**를 선택함.
   - 시간 복잡도는 특정 작업을 수행하는데 걸리는 시간을 데이터 크기에 대한 수식으로 표현하는 방법.
  
 * **연속된 자료 구조(Contiguous data structures)**
   - 모든 원소를 단일 메모리 청크(chunk)에 저장.
   - 모든 원소는 같은 크기의 메모리를 사용하고 sizeof(type)으로 표시.
   - 첫 번째 원소의 메모리 주소를 시작 주소(BA, base Address)라고 하고, 모든 원소는 같은 타입이기에 두 번째 원소는 BA + sizeof(type) 세 번째 주소는 BA + 2 * sizeof(type)이 됨 즉, i번째 주소에 접근하려면 BA + i * sizeof(type)을 사용함.
   - 또한 접근 시간이 항상 일정하기 때문에 **O(1)** 로 표기 함.
   - 배열의 유형은 정적 배열(static array), 동적 배열(dynamic array)로 나눌 수 있는데, 정적 배열은 선언된 블록이 끝나면 소멸되는 반면, 동적 배열은 프로그래머가 생성할 시점과 해제 시점을 자유롭게 정할 수 있음. 그리고 두 가지 유형은 다양한 연산에서 동일한 성능을 보임.
   - int arr[size];  → 정적 배열
   - int* arr = (int*)malloc(size * sizeof(int));  → C에서의 동적 배열 선언
   - int* arr = new int[size];  → C++에서의 동적 배열 선
   - 정적 배열은 스택 메모리에 할당되어 함수가 벗어날 때 자동으로 해제되지만, 동적 배열은 힙 영역에 할당되기 때문에 사용자가 직접 해제하기 전 까지 유지가 됨.
   - 배열은 캐시 지역성(cache locality)이 좋은데, 이는 각 원소가 서로 인접하기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시를 가져오고, 다시 주변 원소에 접근할 때 해당 원소를 캐시에서 가져오게 됨. 시간 복잡도에는 영향을 주지 않지만, 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 장점이 있음.
  
   - 정리하자면, 모든 데이터가 메모리에 연속적으로 저장되고, 임의의 원소에 즉각적인 접근이 가능함.
   - 또한 데이터가 연속적으로 저정되어 있기 때문에, 캐시 지역성 효과를 볼 수 있어 모든 데이터를 순회하는게 매우 빠름
   - 데이터를 저장하기 위해 정확하게 데이터 크기만큼의 메모리를 사용함. 
     
 * **연결된 자료 구조 (Linked data structures)**
   - 노드(node)라는 여러 개의 메모리 청크에 데이터를 저장.
   - 서로 다른 메모리 위치에 저장됨.
   - 연결 리스트에서의 각각의 노드는 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가지고 있음.
   - 맨 마지막 노드에서는 다음 노드의 포인터 대신에 끝을 나타내는 NULL를 가짐
   - 특정 원소에 접근하려면 리스트의 시작 부분 헤드(head) 부분부터시 시작해서 원하는 원소에 도착할 때 까지 next 포인터를 따라 이동해야 함. 즉, i 번째 요소에 접근하라면 연결 리스트의 내부를 i번 이동하는 작업이 필요함
   - 원소의 접근 시간은 노드 개수에 비례하기 때문에, 시간 복잡도는 O(*n*) 표현.
   - 포인터를 사용하기 떄문에 원소의 삽입이나 삭제를 빠르게 수행할 수 있음.
   - 삽입하는 방법은 1. 노드를 생성, 2. 각 노드의 포인터(next)를 수정(기존의 포인터를 삭제하고 새로운 노드에 연결)하여 삽입 할 수 있음.
   - 삭제 또한 삽입과 마찬가지로 삭제할 원소가 더 이상 연결리스트에 연결되어 있지 않도록 포인터를 수정하면 됨.
   - 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할 수 없음.
  
   - 정리하자면, 데이터는 노드에 저장되지만, 노드는 메모리 곳곳에 흩어져 있고, 임의의 원소에 접근하는 것은 헤더부터 접근하기 때문에 선형 시간 복잡도를 가져 느린 편임.
   - 캐시 지역성 효과가 없어 모든 데이터를 순회하는 것도 느리지만, 각 노드에서 포인터 저장을 위해 여분의 메모리를 사용함.
  
   - 참고로 C언어에서는 구현을 직접해야 하지만, C++ 에서는 array, vector, list등을 다양한 자료 구조 클래스를 제공하기 때문에 직접 구현할 필요가 없음.  

--------------------------------------------------
 
 * **std::Array**
   - C에서의 배열은 몇가지 제약 사항을 가지고 있어 단점이 있음.
   - 1. 메모리 할당과 해제를 수동으로 처리해야 함  → 메모리를 해제하지 못하면 메모리 누수가 발생하여 해당 메모리 영역을 사용할 수 없음.
     2. [] 연산자에서 배열 크그보다 큰 원소를 참조하는 것을 검사하지 못 함  → 이는 세그멘테이션 결함(Segmentation Fault) 또는 메모리 손상으로 이어질 수 있음.
     3. 배열을 중첩해서 사용할 시, 코드가 복잡해짐  → 가독성이 떨어짐.
     4. deep copy가 기본으로 동작하지 않아 수동으로 구현 해야함.

     이러한 단점 때문에 C++에서는 C의 배열을 대체하는 std::array를 제공함.

   - std::array는 메모리를 자동 할당 및 해제, 원소의 타입과 배열 크기를 매개 변수(parameter)로 사용하는 클래스 템플릿임

   - std::array는 배열 원소에 접근할 수 있는 []연산자를 제공하는데, []연산자에 접근하고자 하는 배열 원소 인덱스(index)를 지정할 경우, 빠른 동작을 위해 전달된 인덱스 값이 배열의 크기보다 작은지 검사하지 않음. 대신 at(index)함수를 제공하는데, at함수는 인자(Argument)로 전달된 index 값이 유효하지 않으면 std::out_of_range 예외를 발생 시킴.
   - 참고로 at 함수는 []연산자보다 조금 느리지만, 잘 사용하면 예외를 적절하기 처리할 수 있음  → 배열 인덱스를 사용자 입력으로 받던가, 어떠한 이유로 인해 유효하지 않은 인덱스에 접근할 수 있는 상황에 적절함.
   - 객체를 다른 함수에 전달하는 방식은 기본 데이터 타입을 전달하는 것과 유사 한데, 값(value) 또는 참조(reference)로 전달할 수 있고, const를 함께 사용할 수 있음.
   - C언어의 배열을 함수에 전달할 때 처럼, 포인터 연산을 사용하거나 참조 또는 역참조 연산을 하지 않아도 됨 그리고 다차원 배열을 전달하는 경우에도 유용함
   - 함수에 std::array객체를 전달할 경우, 기본적으로 새로운 배열에 모든 원소가 복사됨, 즉 자동으로 deep copy가 되기 때문에, 이러한 동작을 피하고 싶으면 참조 또는 const 참조를 사용할 수 있음.
   - std::array의 원소 접근함수 정리
   - 1. front 함수  → 배열의 첫 번째 원소에 대한 참조를 반환
     2. back 함수  → 배열의 마지막 원소에 대한 참조를 반환
     3. data 함수  → 배열 객체 내부에서 실제 데이터 메모리 버퍼를 가리키는 포인터를 반환. 반환된 포인터를 이용하여 다양한 포인터 연산이 가능.

    - 참고로 관계 연산자를 사용할 경우에 두 배열의 크기가 같아야 함. 그 이유는 std::array로 생성한 배열 객체는 배열의 크기가 데이터 타입 일부로 동작하기 때문에, 크기가 다른 배열은 서로 다른 타입으로 인식되어 비교할 수 없음.
  
 --------------------------------------
 * **std::vector**
   - array의 단점
     1. array의 크기는 컴파일 시간에 결정되는 상수이어야 함 → 즉, 프로그램 실행 중에는 변경 불가
     2. 크기가 고정되어 있어 원소를 추가 및 삭제 불가
     3. 메모리 할당 방식을 변경할 수 없음 → 항상 스택 메모리를 사용

   - 대부분 실제 응용 프로그램에서의 데이터는 동적이고 고정 크기가 아님. 그렇기에 array를 사용하는 것이 항상 좋은 선택지가 아니기 때문에 가변 크기의 데이터를 처리할 수 있는 컨테이너가 필요함.

   - vector는 array의 단점인 고정 크기를 해결 해줌 → 벡터는 데이터 초기화 과정에 데이터 크기를 제공하지 않아도 됨.
   - vector의 시간복잡도는 맨뒤에 원소를 삽입할 때, 뒤쪽에 남아 있는 공간이 있다면 O(1), 공간이 충분하지 않아 모든 원소를 복사/이동을 해야한다면 O(*n*)의 시간이 걸림.
  
   - vector의 주요 함수
     1. push_back → 벡터의 맨 마지막에 새로운 원소를 추가하는 함수, 매우 빠르게 동작됨.
     2. insert → 삽일할 위치를 나타내는 반복자를 첫 번째 argument로 받음으로써 원하는 위치에 원소를 추가 가능
     3. emplack_back, emplace → push_back, insert 함수의 단점을 개선하기 위한 함수로, emplace_back 함수는 맨 뒤에 원소를 추가하는데 argument를 받아 벡터 안에서 직접 생성하고, emplace는 임의의 위치에 원소를 삽입하는데, 지정한 위치에 직접 생성 할 수 있음.
     4. pop_back, erase →  원소를 제거하는 함수로, pop_bakc는 벡터에서 맨 마지막 원소를 제거하고 벡터 크기를 1만큼 줄여줌, erase 함수는 2가지 형태로 오버로딩되어 있는데 반복자 하나를 argument로 받아 해당 위치 원소를 제거하거나 범위 시작과 끝을 나타내는 반복자를 받아 시작부터 끝 바로 앞 원소까지 제거(시작 위치 원소는 제거되지면 끝 위치 원소는 제거 x)
     5. clear → 모든 원소를 제거하여 완전히 비어 있는 벡터로 만듬.
     6. reserve(capacity) →  벡터에서 사용할 용량을 지정, parameter로 지정한 값이 현재 용량보다 크면 메모리를 parameter크기 만큼 재할당하고, 현재 용량보다 같거나 작으면 아무런 동작을 하지 않음, 그리고 벡터의 크기를 변경하지 않음.
     7. shrink_to_fit() →  여분의 메모리 공간을 해제하는 용도로 사용, 호출시 벡터의 용량이 벡터 크그와 같게 설정되고, 벡터 크기가 더 이상 변경되지 않을 때 사용하면 유용함.
    
  - vector 할당자
    템플릿 매개개변수에서 데이터 타입 다음에 할당자(allocator)를 전달할 수 있음. 그렇기에 allocate, deallocate, construct, destroy 함수를 제공함. 할당자는 메모리 할당과 해제, 여타 동작에서 데이터를 손상시키지 않도록 주의 해야함. 일반적인 힙 메모리 대신 자체적인 메모리 풀 또는 자동 메모리 관리가 필요한 경우에 사용하면 유용함.

----------------------------------------------------
 * **std::forward_list**
   - array, vector같은 연속된 자료구조에서 데이터 중간에 자료를 추가허가나 삭제하는 작업은 매우 비효율적이라 연결 리스트 같은 형태의 자료구조가 있음.
   - 기본적으로 연결 리스트를 구현하라면 포인터를 하나 가지고 있어야 하고, new와 delete 연산자를 이용해서 메모리 할당 및 해제를 해야함.
   - C++에서는 기본적인 연결 리스트에 대한 래퍼 클래스인 forward_list 클래스를 제공함.
   - forward_list는 전체 리스트의 크기를 반환하거나 또는 첫 번째 원소를 제외한 나머지 원소에 직접 접근하는 기능을 제공하지 않음 → fornt 함수로 맨 처음 원소에 접근할 수 있지만, back와 같은 반대 방향의 원소로 이동하는 함수는 제공하지 않는다.
   - 삽입, 삭제, 순서 뒤집기, 분할을 위한 기능은 제공함

--------------------------------------------
 * **std::iterator**
   - 반복자는 포인터와 비슷하지만, STL 컨테이너에 대해 공통의 인터페이스를 제공
   - 특정 위치의 원소에 곧 바로 접근하는 반복자를 **임의 접근 반복자(Random Access Iterator)**
   - 역방향으로 이동하지 않고, 만약에 이전 노드로 이동하려면 맨 처음 노드부터 시작해서 찾아가는 반복자는 **순방향 반복자(Forward Iterator)**
   - 이외에도 입출력 반복자, 양방향 반복자가 있음.

 ------------------------------------------------
 * **std::list**
   - forward_list는 리스트 끝에 원소 추가, 역방향 이동, 리스트 크기 반환등의 기능을 제공하지 않는데 이는 메모리를 적게 사용하고 빠른 성능을 유지하기 위해서임.
   - 이러한 단점을 보완하고, 컨테이너의 크기를 얻어오거나, 자료 구조 맨뒤에서 새로운 데이터를 추가하는 등의 기능을 제공하는 list가 있음.
   - list는 양쪽 방향으로 연결된 리스트, 즉 **이중 연결 리스트** 구조임
   - 원소 이동을 역방향으로 진행 가능, 원소 삽입을 위해 특정 원소의 이전 원소 반복자를 제공하지 않아도 되지만, 정확하게 새로운 원소가 삽입될 위치를 가리키는 반복자를 함수 인자로 전달함.
  
   - **양방향 반복자**는 역방향으로 이동할 수 있음 즉, 어느 방향으로도 원하는 만큼 이동이 가능하지만 임의 접근 반복자 처럼 특정 위치로 한 번에 이동하는 것은 불가능 함.
   - **반복자 무효화** 반복자는 메모리 주소를 가리키는 포인터를 이용하여 구현 됨  →  컨테이너가 변경될 경우 제대로 동작하지 않을 수 있음 컨테이너가 변경되어 특정 노드나 원소의 메모리 주소가 바뀌면 사용하던 반복자가 무효화 될 수 있고, 예측할 수 없는 동작이 발생할 수 있음.

------------------------------------------------------
 * **std::deque**
   - deque은 배열과 연결 리스트의 기반 컨테이너 방식이 섞여 있는 상태로, 각각의 장점을 혼합한 것
   - 벡터는 가변 길이 배열이고, push_front, pop_fornt등의 함수는 비용이 많이 드는 작업이지만, deque을 사용하면 이런 단점을 극복할 수 있음
   - deque는 Dobule-ended queue의 약자.

   - deque의 동작에 있어서 다음과 같은 조건이 만족해야 함.
     1. push_front(), pop_fornt(), push_back(), pop_back() 동작이 O(1)로 동작해야 함
     2. 모든 원소에 대해 임의 접근 동작이 O(1)로 동작해야 함.
     3. deque 중간에서 원소 삽입 또는 삭제는 O(*n*)으로 동작해야 하며, 실제로는 최대 *n*/2단계로 동작함, *n*은 deque의 크기임.
    
   - deque은 **양방향으로 매우 빠르게 확장할 수 있고, 모든 원소에 임의 접근을 제공** 함.
   - 단일 메모리 청크를 사용하지 않은 대신에 크기가 같은 여러 개의 메모리 청크를 사용하여 데이터를 저장 함. → 청크의 인덱스 및 크기(또는 하나의 청크에 저장된 원소 개수)를 이용하여 특정 위치의 원소가 어느 청크에 저장되어 있는지를 알 수 있음. 또한 모든 메모리 청크 주소를 연속적인 메모리 구조에 저장해놓고 사용하면 O(1)의 시간복잡도로 원소의 임의 접근이 가능해짐.
   - 데이터 맨 뒤 뿐만 아니라 맨 앞에서도 원소를 매우 빠르게 삽입하거나 삭제 가능
   - 사용자 정의 할당자를 지정 가능 → 하지만, 할당자가 객체의 일부가 아니라 타입의 일부라, 서로 다른 할당자를 사용하는 두 개의 벡터나 두 개의 덱 객체를 서로 비교할 수 없고 서로 다른 할당자를 사용하기 떄문에 객체에 대해 할당이나 복사 생성자를 사용할 수 없음.
  

 ------------------------------------------------------
 * **Container Adapter**
 * **BenchMarking**
   
