# Ch1. 리스트, 스택, 큐

### 개요
  * 자료구조에는 선형구조와 비선형 구조가 존재.
  * 선형 구조는 정적 자료구조인 Array와 동적 자료구조인 연결 리스트, 스택, 큐가 존재.
  * 비선형 구조에는 트리와 그래프가 존재함

-----------------------------------------------

 * **연속된 자료 구조와 연결된 자료구조**
   - 효율적인 데이터 구조를 선택하기 위한 지표로 알고리즘 복잡도 또는 **시간 복잡도**를 선택함.
   - 시간 복잡도는 특정 작업을 수행하는데 걸리는 시간을 데이터 크기에 대한 수식으로 표현하는 방법.
  
 * **연속된 자료 구조(Contiguous data structures)**
   - 모든 원소를 단일 메모리 청크(chunk)에 저장.
   - 모든 원소는 같은 크기의 메모리를 사용하고 sizeof(type)으로 표시.
   - 첫 번째 원소의 메모리 주소를 시작 주소(BA, base Address)라고 하고, 모든 원소는 같은 타입이기에 두 번째 원소는 BA + sizeof(type) 세 번째 주소는 BA + 2 * sizeof(type)이 됨 즉, i번째 주소에 접근하려면 BA + i * sizeof(type)을 사용함.
   - 또한 접근 시간이 항상 일정하기 때문에 **O(1)** 로 표기 함.
   - 배열의 유형은 정적 배열(static array), 동적 배열(dynamic array)로 나눌 수 있는데, 정적 배열은 선언된 블록이 끝나면 소멸되는 반면, 동적 배열은 프로그래머가 생성할 시점과 해제 시점을 자유롭게 정할 수 있음. 그리고 두 가지 유형은 다양한 연산에서 동일한 성능을 보임.
   - int arr[size];  → 정적 배열
   - int* arr = (int*)malloc(size * sizeof(int));  → C에서의 동적 배열 선언
   - int* arr = new int[size];  → C++에서의 동적 배열 선
   - 정적 배열은 스택 메모리에 할당되어 함수가 벗어날 때 자동으로 해제되지만, 동적 배열은 힙 영역에 할당되기 때문에 사용자가 직접 해제하기 전 까지 유지가 됨.
   - 배열은 캐시 지역성(cache locality)이 좋은데, 이는 각 원소가 서로 인접하기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시를 가져오고, 다시 주변 원소에 접근할 때 해당 원소를 캐시에서 가져오게 됨. 시간 복잡도에는 영향을 주지 않지만, 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 장점이 있음.
  
   - 정리하자면, 모든 데이터가 메모리에 연속적으로 저장되고, 임의의 원소에 즉각적인 접근이 가능함.
   - 또한 데이터가 연속적으로 저정되어 있기 때문에, 캐시 지역성 효과를 볼 수 있어 모든 데이터를 순회하는게 매우 빠름
   - 데이터를 저장하기 위해 정확하게 데이터 크기만큼의 메모리를 사용함. 
     
 * **연결된 자료 구조 (Linked data structures)**
   - 노드(node)라는 여러 개의 메모리 청크에 데이터를 저장.
   - 서로 다른 메모리 위치에 저장됨.
   - 연결 리스트에서의 각각의 노드는 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가지고 있음.
   - 맨 마지막 노드에서는 다음 노드의 포인터 대신에 끝을 나타내는 NULL를 가짐
   - 특정 원소에 접근하려면 리스트의 시작 부분 헤드(head) 부분부터시 시작해서 원하는 원소에 도착할 때 까지 next 포인터를 따라 이동해야 함. 즉, i 번째 요소에 접근하라면 연결 리스트의 내부를 i번 이동하는 작업이 필요함
   - 원소의 접근 시간은 노드 개수에 비례하기 때문에, 시간 복잡도는 O(**n*) 표현.
   - 포인터를 사용하기 떄문에 원소의 삽입이나 삭제를 빠르게 수행할 수 있음.
   - 삽입하는 방법은 1. 노드를 생성, 2. 각 노드의 포인터(next)를 수정(기존의 포인터를 삭제하고 새로운 노드에 연결)하여 삽입 할 수 있음.
   - 삭제 또한 삽입과 마찬가지로 삭제할 원소가 더 이상 연결리스트에 연결되어 있지 않도록 포인터를 수정하면 됨.
   - 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할 수 없음.
  
   - 정리하자면, 데이터는 노드에 저장되지만, 노드는 메모리 곳곳에 흩어져 있고, 임의의 원소에 접근하는 것은 헤더부터 접근하기 때문에 선형 시간 복잡도를 가져 느린 편임.
   - 캐시 지역성 효과가 없어 모든 데이터를 순회하는 것도 느리지만, 각 노드에서 포인터 저장을 위해 여분의 메모리를 사용함.
  
   - 참고로 C언어에서는 구현을 직접 동적 자료구조인 연결 리스트, 스택, 큐가 존재.
  * 비선형 구조에는 트리와 그래프가 존재함

-----------------------------------------------

 * **연속된 자료 구조와 연결된 자료구조**
   - 효율적인 데이터 구조를 선택하기 위한 지표로 알고리즘 복잡도 또는 **시간 복잡도**를 선택함.
   - 시간 복잡도는 특정 작업을 수행하는데 걸리는 시간을 데이터 크기에 대한 수식으로 표현하는 방법.
  
 * **연속된 자료 구조(Contiguous data structures)**
   - 모든 원소를 단일 메모리 청크(chunk)에 저장.
   - 모든 원소는 같은 크기의 메모리를 사용하고 sizeof(type)으로 표시.
   - 첫 번째 원소의 메모리 주소를 시작 주소(BA, base Address)라고 하고, 모든 원소는 같은 타입이기에 두 번째 원소는 BA + sizeof(type) 세 번째 주소는 BA + 2 * sizeof(type)이 됨 즉, i번째 주소에 접근하려면 BA + i * sizeof(type)을 사용함.
   - 또한 접근 시간이 항상 일정하기 때문에 **O(1)** 로 표기 함.
   - 배열의 유형은 정적 배열(static array), 동적 배열(dynamic array)로 나눌 수 있는데, 정적 배열은 선언된 블록이 끝나면 소멸되는 반면, 동적 배열은 프로그래머가 생성할 시점과 해제 시점을 자유롭게 정할 수 있음. 그리고 두 가지 유형은 다양한 연산에서 동일한 성능을 보임.
   - int arr[size];  → 정적 배열
   - int* arr = (int*)malloc(size * sizeof(int));  → C에서의 동적 배열 선언
   - int* arr = new int[size];  → C++에서의 동적 배열 선
   - 정적 배열은 스택 메모리에 할당되어 함수가 벗어날 때 자동으로 해제되지만, 동적 배열은 힙 영역에 할당되기 때문에 사용자가 직접 해제하기 전 까지 유지가 됨.
   - 배열은 캐시 지역성(cache locality)이 좋은데, 이는 각 원소가 서로 인접하기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시를 가져오고, 다시 주변 원소에 접근할 때 해당 원소를 캐시에서 가져오게 됨. 시간 복잡도에는 영향을 주지 않지만, 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 장점이 있음.
  
   - 정리하자면, 모든 데이터가 메모리에 연속적으로 저장되고, 임의의 원소에 즉각적인 접근이 가능함.
   - 또한 데이터가 연속적으로 저정되어 있기 때문에, 캐시 지역성 효과를 볼 수 있어 모든 데이터를 순회하는게 매우 빠름
   - 데이터를 저장하기 위해 정확하게 데이터 크기만큼의 메모리를 사용함. 
     
 * **연결된 자료 구조 (Linked data structures)**
   - 노드(node)라는 여러 개의 메모리 청크에 데이터를 저장.
   - 서로 다른 메모리 위치에 저장됨.
   - 연결 리스트에서의 각각의 노드는 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가지고 있음.
   - 맨 마지막 노드에서는 다음 노드의 포인터 대신에 끝을 나타내는 NULL를 가짐
   - 특정 원소에 접근하려면 리스트의 시작 부분 헤드(head) 부분부터시 시작해서 원하는 원소에 도착할 때 까지 next 포인터를 따라 이동해야 함. 즉, i 번째 요소에 접근하라면 연결 리스트의 내부를 i번 이동하는 작업이 필요함
   - 원소의 접근 시간은 노드 개수에 비례하기 때문에, 시간 복잡도는 O(**n*) 표현.
   - 포인터를 사용하기 떄문에 원소의 삽입이나 삭제를 빠르게 수행할 수 있음.
   - 삽입하는 방법은 1. 노드를 생성, 2. 각 노드의 포인터(next)를 수정(기존의 포인터를 삭제하고 새로운 노드에 연결)하여 삽입 할 수 있음.
   - 삭제 또한 삽입과 마찬가지로 삭제할 원소가 더 이상 연결리스트에 연결되어 있지 않도록 포인터를 수정하면 됨.
   - 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할 수 없음.
  
   - 정리하자면, 데이터는 노드에 저장되지만, 노드는 메모리 곳곳에 흩어져 있고, 임의의 원소에 접근하는 것은 헤더부터 접근하기 때문에 선형 시간 복잡도를 가져 느린 편임.
   - 캐시 지역성 효과가 없어 모든 데이터를 순회하는 것도 느리지만, 각 노드에서 포인터 저장을 위해 여분의 메모리를 사용함.
  
   - 참고로 C언어에서는 구현을 직접해야 하지만, C++ 에서는 array, vector, list등을 다양한 자료 구조 클래스를 제공하기 때문에 직접 구현할 필요가 없음.  

--------------------------------------------------
 
 * **std::Array**
   - C에서의 배열은 몇가지 제약 사항을 가지고 있어 단점이 있음.
   - 1. 메모리 할당과 해제를 수동으로 처리해야 함  → 메모리를 해제하지 못하면 메모리 누수가 발생하여 해당 메모리 영역을 사용할 수 없음.
     2. [] 연산자에서 배열 크그보다 큰 원소를 참조하는 것을 검사하지 못 함  → 이는 세그멘테이션 결함(Segmentation Fault) 또는 메모리 손상으로 이어질 수 있음.
     3. 배열을 중첩해서 사용할 시, 코드가 복잡해짐  → 가독성이 떨어짐.
     4. deep copy가 기본으로 동작하지 않아 수동으로 구현 해야함.

     이러한 단점 때문에 C++에서는 C의 배열을 대체하는 std::array를 제공함.

   - std::array는 메모리를 자동 할당 및 해제, 원소의 타입과 배열 크기를 매개 변수(parameter)로 사용하는 클래스 템플릿임

     [1-1. stdArray 예제 코드]()

   - std::array는 배열 원소에 접근할 수 있는 []연산자를 제공하는데, []연산자에 접근하고자 하는 배열 원소 인덱스(index)를 지정할 경우, 빠른 동작을 위해 전달된 인덱스 값이 배열의 크기보다 작은지 검사하지 않음. 대신 at(index)함수를 제공하는데, at함수는 인자(Argument)로 전달된 index 값이 유효하지 않으면 std::out_of_range 예외를 발생 시킴.
   - 참고로 at 함수는 []연산자보다 조금 느리지만, 잘 사용하면 예외를 적절하기 처리할 수 있음  → 배열 인덱스를 사용자 입력으로 받던가, 어떠한 이유로 인해 유효하지 않은 인덱스에 접근할 수 있는 상황에 적절함.
   - 객체를 다른 함수에 전달하는 방식은 기본 데이터 타입을 전달하는 것과 유사 한데, 값(value) 또는 참조(reference)로 전달할 수 있고, const를 함께 사용할 수 있음.
   - C언어의 배열을 함수에 전달할 때 처럼, 포인터 연산을 사용하거나 참조 또는 역참조 연산을 하지 않아도 됨 그리고 다차원 배열을 전달하는 경우에도 유용함
   - 함수에 std::array객체를 전달할 경우, 기본적으로 새로운 배열에 모든 원소가 복사됨, 즉 자동으로 deep copy가 되기 때문에, 이러한 동작을 피하고 싶으면 참조 또는 const 참조를 사용할 수 있음.
   - std::array의 원소 접근함수 정리
   - 1. front 함수  → 배열의 첫 번째 원소에 대한 참조를 반환
     2. back 함수  → 배열의 마지막 원소에 대한 참조를 반환
     3. data 함수  → 배열 객체 내부에서 실제 데이터 메모리 버퍼를 가리키는 포인터를 반환. 반환된 포인터를 이용하여 다양한 포인터 연산이 가능.

    - 참고로 관계 연산자를 사용할 경우에 두 배열의 크기가 같아야 함. 그 이유는 std::array로 생성한 배열 객체는 배열의 크기가 데이터 타입 일부로 동작하기 때문에, 크기가 다른 배열은 서로 다른 타입으로 인식되어 비교할 수 없음.
  
      [1-2. 동적 크기 배열 구현하기]
      
      [1-3. 빠르고 범용적인 데이터 저장 컨테이너 만들기]

 --------------------------------------
 * **std::vector**
 * **std::forward_list**
 * **std::iteraotr**
 * **std::list**
 * **std::deque**
 * **Container Adapter**
 * **BenchMarking**
   
