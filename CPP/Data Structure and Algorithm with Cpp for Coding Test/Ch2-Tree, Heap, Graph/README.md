# Ch2. 트리, 힙, 그래프

  1. 언제 비선형 자료구조를 사용해야 하는가?
  2. 데이터 표현과 문제 해결을 위해서 트리 구조를 구현 가능
  3. 다양한 방법으로 트리 순회 가능
  4. 데이터 표현과 문제 해결을 위해 그래프 구조를 구현 가능
  5. 다양한 방법으로 그래프를 표현 가능

선형 구조에서는 최대 2가지 방향(순방향, 역방향)으로 자료를 순회할 수 있음. 하지만 구조가 매우 제한적이라 복잡한 문제에는 적용이 어려움 <br>
그렇기 때때문에 비선형 구조인 트리와 그래프에 대하여 알아보는 것임.

-----------------------------------
  * **비선형 문제**
    - 선형 구조에서는 **계층적 문제(Hierarchical Problem)과 순환 종속성(Cyclic Dependency)** 를 표현할 수 없음.
    - 계층적 문제는 트리로, 순환 종속성 문제는 그래프로 표현 가능.
    -  참고로, 트리와 그래프에서 데이터가 저장된 부분을 Node 또는 Vertex(정점), 노드와 노드 사이를 잇는 선을 Edge(간선)이라고 함. 
      
-------------------------------------
  * **트리: 상하 반전된 형태**
    - 트리는 노드와 엣지를 이용해서 계층적으로 표현하는 자료 구조로 트리의 중심이 되는 노드를 **Root node**라고 하며 가장 맨위로 나타냄. 트리 구조를 그림으로 나타날 때는 실제 나무와 반대로 뿌리가 맨 위로 나타나는 상하 반전되는 형태로 표현
    - **사이클이 없이 반드시 모든 노드를 연결해야하며, 노드의 개수가 V개면 엣지의 개수는 V-1개** 임.
    - 반대로 노드의 개수가 V개면 엣지의 개수는 V-1개로 구성되어있지만 모든 노드가 연결이 되어 있지 않으면 트리라고 할 수 없음.
    - 트리는 다양한 방법으로 순회하여 원하는 노드에 접근 할 수 있음.
      1. **전위 순회(Pre-order Traversal)** → 현재 노드를 먼저 방문하고, 그 다음은 현재 노드의 왼쪽 자식 노드를, 마지막으로는 현재 노드의 오른쪽 지식 노드를 재귀적인 방식으로 방문하는 원리임. 즉, 전위(pre) 뜻은 상위 노드를 하위 노드보다 먼저 방문한다는 뜻 임 (뿌왼오)
      2. **중위 순회(In-order Traversal)** → 왼쪽 노드를 먼저 방문하고, 그 다음에는 현재 노드, 마지막으로 오른쪽 노드를 방문하는 방식 (왼뿌오)
      3. **후위 순회(Post-order Traversal)** → 두 자식 노드를 먼저 방문후 현재 노드를 방문하는 방식으로 현재 노드의 왼쪽 자식 노드, 오른쪽 자식 노드, 현재 노드로 방문 (왼오뿌)
      4. 레벨 순서 순회(Level order Traversal) → 트리의 맨 위 레벨부터 아레 레벨까지, 왼쪽 노드에서 오른쪽 노드 순서로 방문하는 방식으로 트리의 루트 노드부터 단계별로 차례대로 나열하는 방식임.

-------------------------------------------------------------------------
  * **다양한 트리 구조**
    - 이진트리는 각 노드가 최대 두개의 자식 노드를 가질 수 있는 트리로, 가장 널리 사용되는 트리 중 하나이지만, 평범한 이진트리는 효용성이 높지 않음.

    - **이진 검색 트리 (BST, Binary Search Tree)**
        + 널리 사용되는 이진트리로 다음과 같은 속성이 존재 함.
          1. 부모 노드 값 >= 왼쪽 자식 노드값
          2. 부모 노드 값 <= 오른쪽 자신 노드 값
        + 즉, **왼쪽 노드 <= 부모 노드 <= 오른쪽 노드**의 관계를 가짐.
        + 부모 노드보다 작거나 같은 모든 원소는 항상 왼쪽에, 부모 노드보다 크거나 같은 원소는 항상 오른쪽에 있 원소 검색을 위해 루트 노드부터 차례대로 값을 비교하는 경우, 각 단계마다 검색 범위가 절반으로 줄어듦.
        + BST가 마지막 레벨을 제외한 모든 노드에 2 개의 자식 노드가 있을 경우, 이 트리의 높이는 log₂*N*이 되며, N는 원소의 개수를 나타냄. 그렇기 때문에 BST의 검색 및 삽입 동작은 O(log *N*)이며, 이러한 형태의 이진 트리는 **완전 이진 트리 (Complete Binary Tree)** 라고도 함.
     
        + BST에서 원소 값 삭제할 때
          1. 자식 노드가 없는 경우 →  단순히 해당 노드를 삭제
          2. 자식 노드가 하나만 있는 경우 → 노드 삭제 후, 부모 노드의 포인터가 해당 자식 노드를 가리키도록 수정
          3. 자식 노드가 두 개 있는 경우 → 노드 삭제 후, 현재 노드를 후속 노드(Successor)로 대체
        + 후속 노드란 현재 노드 다음으로 큰 숫자를 가진 노드를 의미함 즉, **현재 원소 보다 큰 원소들 중에서 가장 작은 원소를 의미**
        + 후속 노드는 오른쪽 자식 노드 하나만 가질 수 있고, 만약에 왼쪽 자신이 있다면 해당 노드가 아닌 해당 노드의 왼쪽 자식 노드를 후속 노드를 선택
        + N개의 노드를 가지고 있는 BST에서 검색에 필요한 시간은 T(*N*) = T(*N*/2) + 1로 표현할 수 있고, T(*N*) = O(log *N*)인 시간 복잡도를 가짐. 하지만, 원소 삽입 순서에 따라 트리의 모양이 결정되기 때문에 검색 범위가 T(*N*/2) 형태로 줄어 드는 것이 항상 성립하지 않음. 그렇기 문에 시간 복잡도 또한 항상 정확하다고 할 수 없음.

    - **균형 트리(Balanced Tree)**
      + 편향되지 않으며, 균형이 잡힌 트리로 여러 방식이 있음
      + AVL Tree, Red-Black Tree 같은 다양한 트리가 존재 함. AVL Tree 같은 경우 BST속성을 유지하면서 트리 높이 균형을 잡기 위해 약간의 회전을 수행 하는 것임.
        
    - **N-항 트리((N-ary Tree)**
      + 각 노드가 N개의 자식을 가질수 있는 트리로 N은 임의의 양수로 N의 자식 노드는 벡터를 이용해서 저장 할 수 있음.
      + N-항 트리는 유용하지 않은 편이지만, 요구 사항에 따라 만들 수 있음
        1. 컴퓨터 파일 시스템 구조 →  리눅스의 / 나 윈도우의 C:\부터 시작해서 다수의 파일 폴더를 가지는 경우
        2. 컴파일러 →  대부분의 컴파일러는 표준 문법에 근거하여 소스 코드로부터 추상 구문 트리(AST, Abstract Syntax Tree)를 구성하고 AST를 다시 분석하여 하위 레벨 코드를 생성 함.

--------------------------------------------------
  * **Heap**
    - Heap은 다음과 같은 시간 복잡도를 만족해야 함.
      1. O(1) → 최대 원소에 즉각적으로 접근할 수 있어야 함.
      2. O(log N) →  원소 삽입에 대한 시간 복잡도
      3. O(log N) →  최대 원소 삭제에 대한 시간 복잡도

    - 원소 삽입 또는 삭제에 대해 O(log N)을 만족하기 위해 트리 구조를 사용하는데, 이 경우에는 주로 완전 이트리를 사용 함.
      
    - 힙의 불변성 → 최대 원소에 즉각적으로 접근이 가능 해야하는데, 이를 위해 최대 원소가 항상 고정된 위치에 있어야 함, 그렇기 떄문에 항상 대 원소가 트리의 뿌리에 있도록 설정하고 부모 노드가 두 자식 노드보다 항상 커야 한다는 불변성을 유지 하도록 설정 해야함 이를 **최대 힙(Max Heap)** 이라고 함.
    - 반대로 최소 원소에도 빠르게 접근할 수 있도록 힙을 구성할수 있는데 이는 최대 힙과 반대로 모든 비교 연산을 설정하면 **최소 힙(Min Heap)** 이 됨.
    - 정리하자면, 최대 힙은 모든 부모 노드의 원소 >= 자식 노드, 최소 힙은 부모 노드의 원소 <= 자식 노드
    [연습 문제 10. 중앙값 구하기]
-----------------------------------------------------
  * **Grpah**
    - 순환 종속성을 표현하기 위해서 그래프를 사용
    - 그래프는 노드 데이터 뿐만 아니라, 노드 사이의 엣지 데이터도 저장 해야함 → 이를 가중치라고 함.
    - **비가중 그래프(Unweighted Graph)와 가중 그래프(Whigthed Graph)** 로 나눌 수 있음

    - 비가중 그래프는 엣지에 가중치가 없는 그래프로 간선에 대해 모두 동일한 비용으로 취급하며 경로 탐색시 단순히 간선 개수(이동 횟수)를 최소화 하는 것이 목표임 주로 BFS(너비 우선 탐색) 사용
    - 가중 그래프는 엣지에 가중치(값)이 있는 그래프로 가중치에 따라 경로의 비용이 달라지고 최단 경로 탐색 시 가중치 합이 최소가 되는 경로를 찾아야 함 대표적으로 다익스트라(Dijkstra), 벨만-포드(Bellman-Ford), 플로이드-위셜(Floyd-Warshall) 알고리즘이 있음.
    - 또한 방향 그래프와 무방향 그래프로 구분 할 수 있는데, 방향 그래프(Directed Graph)는 엣지가 한쪽 방향으로 연결된 그래프를 의미 함 즉, 정점 A에서 정점 B로 가는 엣지가 있더라도 B에서 A로 가는 엣지가 있는 것이 아님.  A → B는 가능하지만 B → A는 안됨 그래서 단방향 그래프라고도 함
    - 무방향 그래프(Undirected Graph)는 엣지가 양방향임을 의미, 대칭적이고 상화 교환적인 속성을 나타냄 즉, A → B, B → A 둘 다 가능

    - 그래프는 행렬로 표현 가능  즉, 정점 간 연결 관계를 2차원 배열로 나타내는 방법으로 노드가 N개면 N*N크기의 행렬를 만들 수 있고 이를 **인접 행렬(Adjacency Matrix)** 라고 표현 함.

    - 행렬인 경우 두 노드가 서로 연결되어 있지 않아도, 모든 노드 사이의 엣지 정보를 저장해야하는 불편함이 있음, 이러한 방식 대신에 각 노드에 직접 노드의 ID만으로 저장하는 방식으로 그래프를 표현할 수 있는데 이를 **인접 리스트(Adjacency List)** 라고 함.
