# Ch3. 해쉬테이블과 블룸 필터

------------------------------------------------
  * **<개요>**
    - 룩업 관련 문제를 이해
    - 주어진 문제에서 결정적 룩업 솔루션, 비결정적 룩업 솔루션 중 어느 쪽이 적합한지 구분 가능
    - 시나리오에 근거한 효율적인 룩업 솔루션 구현 가능
    - STL에서 제공되는 일반적인 솔루션 구현
   
    - **Look up(룩업, 조회)**
      + 특정 원소가 컨테이너에 있는지 확인하거나 또는 컨테이너에서 특정 키(key)에 해당하는 Value을 찾는 작업
      + 모든 원소를 선형적으로 검토하여 원하는 값을 찾는 작업은 일반 적으로 매우 많은 시간이 소요되기 때문에, 이를 효율적이고 빠르게 수행할 알고리즘이 필요함 → 해시 테이블과 블룸 필터 

  ---------------------------------------------------
  * **해시테이블**
    - 선형 검색은 O(*N*)의 시간이 필요함, 이보다 나은 방법은 BST와 같은 높이 균형 트리에 데이터를 저장하는 것인데, 이 또한 O(log *N*)이 되므로 선형 검색보다 빠르지만, 해시 테이블에 비하면 검색 횟수가 많을 때 성능 이점이 줄어들 수 있음. 
    - → 이러한 상황을 극복하기 위한 방법으로 **해시 테이블**이 있는데, 해시 테이블의 핵심은 **해싱(Hashing)과 해시 함수(Hash Function)** 임.
    - 해싱은 각각의 데이터를 가급적 고유한 숫자 값으로 표현하고, 나중에 숫자 값을 사용하여 데이터의 유무를 확인하거나 또는 해당 숫자에 대응하는 원본 데이터를 추출하는 작업
    - 해시 함수는 주어진 데이터로부터 고유한 숫자 값을 계산하는 함수

    - 해시 함수에 의해 반환되는 숫자 값을 → Hash Value
    - 해시 함수가 서로 다른 키에 대해 같은 해시 값을 반환함으로써, 다수의 키가 같은 값을 갖는 현상 → 충돌(Collision)
    - 해시 테이블에 부울 값 대신 실제 데이터를 저장하면, 해당 키에 어떤 데이터가 저장되어 있는지를 알 수 있지만, 여러 데이터를 저장할 수 없음.
    - 해시 테이블을 사용할 때, 단순히 해당 키가 있는지 확인하는 것이 아니라 해당 키에 대응 값이 있는지 확인해야 함. → 해시 테이블에 키만 저장하지 않고 key와 value를 같이 저장하는 방식을 사용
    - 즉, 삽입, 삭제, 룩업 함수에서 키를 기반으로 해시 값을 계산해서 배열에서의 위치를 알아낸 뒤, 함께 저장된 값을 이용할 수 있어야 함.
   
    - **충돌(Collision)**
      + 특정 해시 값 위치에 이미 원소가 존재한다면, 새로운 값과 예전 값 중 하나를 버릴 수 밖에 없는데, **체이닝(Chaining) 기법**은 두 값을 모두 저장할 수 있게 해주는 여러 방법 중 하나임.
      + 해시 테이블의 특정 위치에서 하나의 키를 저장하는 것이 아니라 하나의 연결 리스트로 저장하고, 새로 삽입된 키에 의해 충돌이 발생하면 리스트의 맨뒤에 새로운 키를 추가 가능 → 다수의 원소를 원하는 만큼 저장 가능하고, 벡터를 사용하지 않은 이유는 연결 리스트를 통해 특정 위치의 원소를 빠르게 삭제하기 위해서 임. 또한, 삽입시 재할당 오버헤드가 없는 장점이 존재 

      + 해시 테이블이 저장할 키 개수에 비해 매우 작다면 충돌이 많이 발생하게 되고 리스트는 평균적으로 길어짐 반대로 너무 큰 해시 테이블에 실제 데이터를 듬성듬성 존재하게 되면 메모리 낭비가 발생 함 → 그렇기 때문에 해시 테이블 크기를 적절히 조절해야 함.
      + 부하율(Load Factor)은 해시 테이블에서 각각의 리스트에 저장되는 키의 평균 개수를 나타 냄
      + 부하율은 식으로 표현 가능 → **부하율 = 전체 키 개수 / 해시 테이블 크기**
      + 키 개수 와 해시 테이블 크기가 같다면 부하율은 1로, 매우 이상적인 상태임 반면 1보다 작은면 리스트당 키가 하나도 저장되지 않은 경우가 있다는 거고, 메모리 낭비가 발생 함.
      + 또는 부하율이 1보다 크면 리스트의 평균 길이가 1보다 커 검색, 삭제등의 함수가 약간 느리게 동작 할 수 있음.
      + 그렇기 때문에 부하율이 1의 특정 값보다 너무 크거나 작아지면 해시 함수를 변경하는 재해싱(Rehashing) 작업을 하여 부하율이 1에 가까운 값이 도되록 만듬.
      + 보통 1보다는 0.7정도 이하를 유지하도록 설계하되 1을 넘지 않게 유지하는게  일반적임 
     
      + 충돌을 해결하는 다른 방법으로 **열린 주소 지정 (Open addressing)** 이 있음.
      + 모든 원소를 해시 테이블에 저장하는 방식으로, 해시 테이블의 크기가 반드시 데이터 개수보다 충분히 커야 함.
      + 가장 큰 특징으로는 해시 값에 해당하는 위치가 이미 사용되고 있다면, 테이블의 다른 비어 이있는 위치를 탐색하는 것임
      + 탐색 방법은 여러 방식이 존재 함 → 선형 탐색, 이차 함수 탐색 등..
        
     
      - **선형 탐사(Linear Probing)**
        + 가장 간단한 탐색 방법으로, 특정 해시 값에서 충돌이 발생하면 해당 위치에서 하나씩 다음 셀(Cell) 위치로 이동하면서 셀이 비어 있는지를 확인하고 비어 있는 셀을 찾으면 원소를 삽입하는 방식
        + 즉, hash(*x*)에 해당하는 셀이 이미 채워져 있다면, hash(*x* + 1)  *mod m* 위치의 셀을 확인.. hash(*x* + 1)  *mod m* 셀도 사용중이면 다음 셀인 hash(*x* + 2)  *mod m* 을 확인하는 방식임
        + 만약 데이터가 특정 위치에 군집화(Clustering)이 되는 경우 문제가 발생하게 되는데, 데이터가 클러스터링된다는 것은 특정 해시 값이 너무 자주 발생해서 데이터가 몇 개의 그룹으로 뭉치는 형태로 저장된다는 의미임. 이로 인해 검색 속도는 급격히 저하 됨.
          

      - **이차함수 탐사(Quadratic Probing)**
        + 선형 탐색의 단점인 군집화인데, 충돌이 발생하면 군집을 차례대로 검사해야하기 때문에 이러한 단점을 해결 하기위해 선형 방정식이 아닌 이차 방정식을 사용해서 탐색을 수행 할 수 있음
        + 이차함수 탐색은 hash(*x*) *mod m* 에 데이터를 삽입하려고 할 때, 이 위치의 셀이 이미 사용하고 있으면, hash(*x* + 1²)  *mod m* 위치로 이동하고, 그 다음은  hash(*x* + 2²)  *mod m* 로 이동하는 방식임
        + 이동 폭을 이차함수 형태로 증가시키면 데이터 군집이 나타날 확률은 상대적으로 줄어듦.
         

        + 선형 탐색 및 이차함수 탐색은 모두 원소 위치가 기존에 삽입되어 있는 다른 원소들에 의해 영향을 받고, 이때 기존에 저장되어 있던 원소는 새로 삽입하는 원소와 서로 다른 해시 값을 가질 수도 있음
        + 즉, 특정 해시 값을 갖는 키가 오직 하나만 존재하더라도 충돌이 발생할 수 있음.
     

    - **뻐꾸기 해싱(Cuckoo Hashing)**
      +  완벽한 해싱 기법 중의 하나로 구현만 제대로하면 Worst-case에서 O(1)을 만족함.
      +  크기가 같은 두 개의 해시 테이블을 사용하고, 각각의 해시 테이블은 서로 다른 해시 함수를 가짐
      +  모든 원소는 두 해시 테이블 중 하나에 있을 수 있고, 그 위치는 해당 해시 테이블의 해시 함수에 의해 결정 됨
      +  뻐구기 해싱 기법의 특징은
         1. 원소가 두 해시 테이블 중 어디든 저장될 수 있다.
         2. 원소가 나중에 다른 위치로 이동할 수 있다.

      + 기존의 해싱 방법에서는 재해싱을 수행하지 않는 이상, 원소가 최초 삽입된 위치에서 다른 위치로 이동할 수 없지만, 뻐꾸기 해싱은 모든 원소가 두 개의 저장 가능한 위치를 가지며, 상황에 따라 이동 가능
      + 룩업의 경우 특정 원소가 존재하는지를 알기 위해 저장 가능한 위치 두 군데만 확인하면 되기때문에, 시간복잡도는 항상 O(1)임.
      + 삽입 연산은 더 걸릴 수 있는데, 이는 완전히 비어 있는 셀이 나타날 때까지 재귀적으로 반복하기 때문임.
      + 순환이 발생하면 무한 루프에 빠질 수 있기 때문에, 새로운 해시 함수를 사용해서 재해싱을 해야하는데, 또 순환이 발생할 수 있어, 여러 번 재해싱을 해야할 수도 있음
      + 뻐꾸기 해싱은 전체 해시 테이블 크기 이상의 원소를 저장할 수 없는데, 높은 성능을 보장하려면 부하율이 0.5보다 작게끔 설정해야 함. 즉, 전체 원소 개수가 해시 테이블 크기의 절반보다 작아야 함.

----------------------------------------------
  * **블룸 필터**
    
    + 해시 테이블에 비해 공간 효율이 매우 높은 방법이지만, 결정적(Determinisitc) 해결책 대신 부정확한 결과를 얻을 수 있음.
    + **거짓-부정(False-Negative)이 없다는 것은 보장하지만, 거짓-긍정(False-Positive)** 가 나올 수 있음.
    + 즉, 특정 원소가 존재한다는 긍정적인 답변을 받을 경우, 이 원소가 실제로 존재할 수도 있고, 없을 수 도 있음. 하지만, 특정 원소가 존재하지 않는다는 부정적인 답변을 받았다면 이 원소는 확실히 없음.
    + False Positive는 실제로 없는데 있다고 나오는 거고, False Negative는 실제 있는 값을 없다고 말하는 일은 없다. 
      
    + 여러 개의 해시 함수를 사용하며, 실제 값을 저장하지 않고 부울 타입 배열을 사용해 특정 값이 있는지 없는지를 확인 해줌
    + 원소를 삽입할 경우, 모든 해시 함수 값을 계산하고, 부울 타입 배열에서 이 해시 값에 대응되는 위치의 비트 값을 1로 설정함.
    + 룩업의 경우, 모든 해시 함수 값을 계산하고, 이에 대응되는 위치의 비트 값이 1로 설정되어 있는지를 검사함.
    + 만약에 검사한 모든 비트가 1이면 true를 반환하고, 1이 아닌 비트가 하나라도 있으면 false로 반환 함 → 이는 해당 원소가 없음을 의미.
    + 특정 비트가 다수의 원소에 의해 1로 설정될 수 있기 때문에 **Determinisitic Solution**이 아님
    + 즉, 특정 값 *x*와 연관된 모든 비트가 이전에 삽입된 다른 원소 값들에 의해 모두 1로 설정되어 있을 가능성이 있다는 뜻으로, 이러한 경우 *x*에 대한 룩업 함수는 true로 반환할 것임, 이처럼 특정 원소가 있다고 잘못 판단하는 것은 False-Positive이며, 원소 개수가 많아 질수록 False-Positive이 발생할 가능성이 커짐.
    + 하지만, *x*와 연관된 비트 중 한라도 1로 설정되어 있지않으면 *x*가 확실하게 없다고 말할 수 있기 때문에, False-Negative는 발생할 수 없음
    + 부울 배열에서 모든 원소가 true or 1로 설정되는 경우, 이 배열은 포화 상태가 되어 룩업 함수는 항상 true를 반환하고, 삽입 함수는 블룸 필터에 영향을 주지 못함.
    
    
