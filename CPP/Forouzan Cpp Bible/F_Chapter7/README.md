## 7장 클래스와 생성자 
C++를 객체 지향 언어로서 사용하는 방법을 배움 <br>
객체를 생성하고 소멸하는 원리를 배우고, 인스턴스 멤버와 정적 멤버의 역할을 구분 및 캡슐화에 대해 익힘

--------------
### 7.1 클래스의 개요 
C++는 절차 지향과 객체 지향 패러다임이 결합된 언어. <br>
7장에서는 객체 지향 패러다임을 적용하여 객체 지향 언어로서 C++를 사용하는 방법을 배움 <br>
더 나아가 어떻게 새로운 타입을 만들며 활용하지를 대해 알아봄 <br>
새로운 타입을 만드는 매커니즘으로는 클래스(class)와 열거형 (enumerated type)이 존재함. <br>
7장은 클래스 중점적으로 학습 <br>

#### 타입과 인스턴스
타입을 이용해 인스턴스를 생성할 수 있음. <br>
type은 추상화 된 것이고, instance는 타입을 실체화한 구체적인 실체를 뜻함. <br> 
type과 instance관계는 one-to-many 관계임. <br> 
하나의 타입을 기반으로 많은 인스턴스를 생성할 수 있음.

+ **속성**
  속성(attribute)은 인스턴스가 가지는 특징을 의미함. <br>
  CS에서의 속성이란 우리가 관심 있어 하는 특성임 <br>
  예를 들어, 직원이라는 인스턴스가 있다면 직원의 이름, 주소, 급여 등에 관심이 있을 것임.
  
+ **행위**
  인스턴스는 어떤 행위(behavior)를 가짐 <br>
  행위란 어떤 인스턴스가 스스로 할 수 있는 작업 또는 연산을 뜻함. <br>
  예를 들어, 인스턴스가 직원이면 직원에게 이름, 주소, 급여을 지정할 수 있어야함. <br>
  참고로, 객체지향 프로그래밍에서의 인스턴스는 스스로 작업 또는 연산을 할 수 있어야함 <br>

#### 클래스와 객체
  객체지향 언어에서는 타입과 인스턴스라는 용어를 자주 사용 <br>
  C++는 Class라는 구문을 사용하여 타입(사용자 정의 자료형)을 만듦. <br>
  이러한 CLass를 기반으로 만든 인스턴스를 객체라고 함. 
  또는 인스턴스라고 그냥 부르기도 한다. <br> 
  객체 지향에서 객체의 속성과 행위는 데이터 멤버와 멤버 함수로 만듦 <br>

+ **데이터 멤버**
  속성을 표현하기 위한 변수를 의미
  
+ **멤버 함수**
함수는 어떤 행위를 할 수 있는 기능의 모임임 <br>
객체의 행위는 멤버 함수를 사용해서 구현함. <br>
이러한 함수를 만들 때, 속성과의 관계를 항상 고려해야함 <br>

#### 정리
타입(type) == Type or Class <br> 
instance == 인스턴스 또는 객체 <br> 
속성 == 데이터 멤버 <br>
행위 == 멤버 함수 <br> 

--------------------
### 7.2 객체지향과 클래스 

#### 객체 지향에 필요한 클래스의 구조

새로운 자료형(타입)을 만들 때는 클래스를 사용 <br>
객체 지향 프로그램에서는 타입으로 클래스를 만들고, 이를 기반으로 인스턴스인 객체를 만듬 <br>
클래스를 기반으로 인스턴스를 만드는 것을 인스턴스화(Instantiation)라고 함.

절차 지향 프로그램에서는 기본 자료형을 활용하는 함수를 모아 애플리케이션(응용 프로그램)만 만들면 됨 <br> 
객체 지향 프로그래밍을 할 때는 클래스의 정의, 멤버 함수의 정의, 애플리케이션(클래스를 기반으로 객체를 만들어서 사용하는 부분)이 필요함. <br> 
이 부분이 절차 지향과 객체 지향의 차이점임 <br>
물론, 각각의 부분이 다른 것으로 교체될 수 있지만, 전체적인 원리는 변하지 않는다. <br> 

--------------------------

**클래스의 정의 -> 속성과 행위 선언** <br>
**멤버 함수의 정의 -> 행위 정의** <br>
**애플리케이션 -> 객체를 인스턴스화하고 사용** <br> 

---------------------------

클래스의 정의 부분에서는 데이터 멤버와 멤버 함수를 선언하고, <br> 
멤버 함수의 정의 부분에서는 모든 멤버 함수를 정의함.<br> 
애플리케이션 부분에서는 클래스의 인스턴스를 만들고, 멤버 함수를 사용함 

#### 클래스의 정의 

새로운 타입을 만들려면 클래스의 정의(Class definition)를 작성해야함. <br>
클래스 정의는 헤더, 본문, 세미콜론이라는 세부분으로 구성됨 <br> 
클래스 헤더(Class header)는 class라는 키워드 뒤에 클래스의 이름을 붙여서 만듦 <br> 
사용자 정의 자료형은 소문자와 대문자 어떤 것을 사용해도 관계 없음. <br>
하지만, 일반적으로 클래스 이름의 경우는 대문자로 시작하게 만들어 소문자로 시작하는 라이브러리 클래스와 구분하는 것이 좋음. <br>

**클래스 작성 예시**
```cpp
class Circle { //헤더 

private: 
double radius; //데이터 멤버 선언

// 멤버 함수 선언 
public: 
double getRadius() const; 
double getArea() const; 
double getPerimeter() const; 
double setRadius(double value); 
};
```
+ **데이터 멤버 선언**
  
  클래스의 정의의 첫 번째 부분은 데이터 멤버를 선언하는 부분임 <br>
  데이터 멤버는 내장 자료형으로 만들 수 있고, 이전에 정의한 다른 클래스로도 만들 수 있음.<br>
  클래스의 속성을 구현하는데 사용할 것들을 데이터 멤버로 만듦

  객체는 속성을 여러 개 가질 수 있고, 일부 속성은 다른 속성에 의존하여 계산되는 경우도 있음. <br>
  따라서, 어떤 속성이 단독으로 존재할 수 있는지, 그리고 어떤 속성이 다른 속성에 의존해야하는지를 알아야 함. <br>
  
+ **멤버 함수 선언**
  
  클래스의 행위를 구현하는 데 사용할 함수를 만듦. <br>
  함수 선언(프로토타입)부분과 비슷함. 다만, 함수 끝에 const 한정자가 오는 경우도 있고, 오지 않는 경우도 있음. <br>
  함수 내부에서 어떠한 것도 변경하지 못하게 할 때는 const 한정자를 붙이고, 변경을 허가할 때는 const 한정자를 붙이지 않음. <br>
  
+ **접근 제한자(access modifier)**
  
접근 제한자(access modifier)는 접근 권한을 나타낼 때 사용함. <br>
클래스에서 데이터 멤버와 멤버 함수를 선언하면 기본적으로 private 접근제한자를 가짐.
  private접근 제한자가 붙으면 해당 요소로부터 값을 추출할 수도 없고, 값을 변경할 수 없음. <br>
C++은 값을 접근하기위해, private, protected, public이라는 3가지 접근 제한자를 제공함. <br>

+ private
  private로 선언되어 있다면, 클래내스 내부(멤버 함수를 통해서)에서만 접근할 수 있음. <br>
  즉, 같은 클래스에서만 접근이 가능하며, 서브 클래스와 다른 모든 곳으로부터의 접근은 불가능함 <br>
  
+ public
  public으로 선언되어 있다면, 모든 곳(같은 클래스, 서브 클래스 내부, 애플리케이션)에서 접근 가능.<br>
  즉, 모든 곳에서 접근이 가능하다.

+ protected
    protected는 같은 클래스와 서브 클래스에서의 접근은 가능하지만 모든 곳으로부터의 접근은 불가능함 <br>
    추가적인 내용은 서브클래스를 다루는 11장에서 설명할 예정.

+ 데이터 멤버와 접근 제한자
    
    데이터 멤버에는 일반적으로 private를 적용함 <br>
    기본적으로 private가 붙지만, 강조하기위해서 prrivate을 붙여서 사용함. <br>
    private가 적용된 멤버는 멤버 함수를 통해서만 접근할 수 있음. <br>
    
+ 멤버 함수와 접근 제한자
 
    데이터 멤버에 접근해서 어떤 작업을 하려면, 애플리케이션에서 멤버 함수를 사용할 수 있어야함 <br>
    따라서 일반적으로 멤버 함수는 public을 적용함 <br>
    하지만 클래스 내부(동일한 클래스의 다른 멤버 함수 등)에서만 활용하는 경우에는 멤버 함수의 접근 제한자를 private로 설정하기도 함
    
+ 그룹 함수와 접근 제한자
    접근 제한자는 각각의 것 앞에 붙이는 것이 아니라 **그룹 단위**로 붙임 <br>
    private : 하고 그뒤에 private로 선언할 데이터 멤버를 입력 함 <br>
    public : 똑같음 <br>

    접근 제한자는 다른 접근 제한자를 만나기 전까지 유지됨. <br>

#### 멤버 함수 정의

멤버 함수는 단순하게 함수의 프로토타입을 적은 것으로, 별도의 정의가 필요함. <br>
Example) 

```cpp
doulbe Circle::getRadius() const{
return radius;
}

double Circle::getArea() const {
const double PI = 3.14; <br>
return(PI * radius * radius);
}
```

기본적인 함수 정의와 비슷하지만 2가지 차이점이 있음. <br>
먼저 멤버 함수에는 한정자(Const)가 있다는 것임. <br>
두 번째는 멤버 함수에는 앞에 클래스 이름이 붙는다는 것임. <br>

데이터 멤버는 클래스 정의 내부에 작성하기 때문에 멤버 함수를 정의할 때에는 클래스 이름을 붙여 함<br>
참고로 클래스 스코프 연산자의 위치와 리턴 자료형의 위치가 헷갈리는 경우가 있는데, 함수의 리턴 자료형이 언제나 앞에 옴<br> 

  #### 인라인 함수

  함수 본문이 너무 짧으면, 함수를 실행하는 시간 (매개변수 저장, 제어 이동, 매개변수 추출, 리턴값  저장 등)이 함수 내부의 코드를 실행하는 시간보다 오래 걸릴 수 있음. <br> 
  프로그램의 성능을 위해서 컴파일러가 함수 호출 부분을 실제 코드로 대체해버리게 만들고 싶을 때는 함수를 인라인 함수로 선언함. <br> 
  물론 컴파일러가 이를 무시할 수도 있으며 인라인 함수는 필요한 곳에 사용할 수 있음. <br>
  최근에는 컴파일러의 성능이 좋기 때문에, 필요한 경우 컴파일러가 인라인 함수로 알아서 구성함. <br>
  반대로 개발자가 인라인 함수로 만들 수 없는 정도의 내용을 인라인 함수로 강제로 만들면, 이를 무시하기도 함. <br>

  + **암묵적 인라인 함수**
```cpp
  class Circle{
private:
  double radius;
  public:
  double getRadius() const {return radius;}
  ....
  }
```
  위의 코드처럼, 클래스 정의 내부에 함수를 정의하면, 해당 함수는 인라인 함수가 됨. <br>
  하지만 함수 정의 부분을 읽기 어렵고, 캡슐화 원칙을 위반했기 때문에 추천하지 않음. <br>
  클래스 정의 내부에 함수 정의를 넣었으므로, 이 함수의 정의를 외부에 따로 정의할 필요가 없음. <br>
  
  + **명시적 인라인 함수**
    
함수 정의 앞에 inline 키워드를 추가하면 함수를 명시적 인라인 함수로 만들 수 있음. <br>

```cpp
inline double getRadius() const {return radius;}
```

#### 애플리케이션

클래스 정의와 멤버 함수를 정의 했으므 로, 메인 함수 부분(애플리케이션 부분)에서 이를 인스턴스화 해야 함. <br> 

+ **객체 인스턴스화**
  
  멤버 함수를 사용하려면, 객체를 인스턴스화 해야함. <br>

  ```cpp
  Circle circle1;
  ```

  위의 코드를 실행하면 circle1이라는 객체가 만들어짐. <br>
  하지만, 객체 내부에 있는 double 자료형의 radius라는 데이터 멤버(변수)를 초기화하지 않았으므로, 이 데이터 멤버에는 쓰레기 값이 들어감. <br>
  따라서 사용하기 전에 데이터 멤버를 초기화 해줘야 함.
  
+ **객체에 연산적용**

  인스턴스화했다면 멤버 함수로 정의 했던 연산을 사용할 수 있게됨.<br>

```cpp
   circle1.setRadious(10.0);
   cout << "radius : " << circle1.getRadius() <<endl;
  ```

+ **멤버 선택**
  
  객체 이름과 멤버 함수 사이에 점(.)이 찍혀있는데, 이는 멤버 선택 연산자 (member selection operator)라고 부르는 연산자임. <br>
```cpp
  circle1.getRadius(); 
  circle2.getRadius(); 
  ```

#### 구조체 

구조체의 모든 멤버는 기본적으로 public <br>
반대로 클래스의 모든 멤버는 기본적으로 private <br> 

일부 경우, 멤버 함수를 사용하지 않을 경우, 쉽게 만들고 요소에 접근할 수 있는 구조체를 사용하기도 함 <br>
연결 리스트의 노드 요소처럼 연관 관계를 갖는 데이터가 있을 때 구조체를 사용하기도 함. <br> 

--------------------
### 7.3 생성자와 소멸자. 

인스턴스는 클래스 정의에 있는 데이터 멤버를 캡슐화한 객체. <br>
객체가 데이터 멤버를 갖고 어떤 작업을 하려면, 객체를 만든 뒤 데이터 멤버를 초기화 하는 작업이 필요함. <br> 
객체는 **생성자(Constructor)** 라고 부르는 특별한 멤버가 호출 될 때 생성됨. <br> 
따라서 생성자 내부에서 초기화를 하면 편리함. <br> 

또한 객체가 더 이상 필요가 없어지는 경우에는 객체가 차지하고 있는 메모리를 비워줘야 한다 -> 메모리 재활용 <br> 
 이 때, **소멸자(destructor)** 라고 부르는 특별한 멤버 함수가 호출되어 소멸자 내부에서 객체를 정리하는 작업을 한다. <br> 

 #### 생성자(Constructor)
 
  객체를 생성하는 특별하는 멤버 함수. <br> 
  생성자 내부에서 객체의 데이터 멤버를 초기화 함. <br>  
  클래스 정의에서 데이터 멤버를 선언한다고, 데이터 멤버가 초기화 되는 것은 아니고, 데이터 멤버를 선언할 때는 멤버의 이름과 자료형만 지정할 뿐임. <br> 
  2가지 특징이 존재함. <br> 
  
  **1. 리턴 값이 없음** <br>
  
  생성자는 객체를 생성하고 데이터 멤버를 초기화하는 특별한 역할을 하게 설계 되었기 때문 <br>
  참고로, 생성자 함수 내부에서 값의 유성을 검사하는 등의 별도의 작업을할 수 도 있음. <br>
하지만 이러한 작업도 모두 초기화의 일부일 뿐임. <br>

  **2. 이름이 클래스의 이름과 같음** <br>

생성자는 크게 Parameter가 있는 생성자, 기본 생성자, 복사 생성자라는 3가지로 구분할 수 있음. <br>

+ **생성자 선언**

생성자는 클래스의 멤버 함수이기 때문에, 클래스 정의에서 선언해야함. <br>
생성자는 이전에 설명 했던 것처럼 리턴값이 없고, 이름이 클래스 이름과 동일해야 함. <br>
데이터 멤버를 초기화하는 변경 작업을 하기 때문에 const한정자를 붙일 수 없음. <br>

예시 : 

```cpp
class Circle{
... 
public: 
 Circle(double radius); //매개변수가 있는 생성자 
 Circle(); //기본 생성자 
 Circle(const Circle& circle);// 복사 생성자
.... 
}
```

+ **매개변수가 있는 생성자 (Parameter Constructor)** <br> 
  일반적으로 데이터 멤버를 지정된 값으로 초기화 하기 위해서 사용 <br>
  오버로드할 수 있으므로, 시그니처가 다르면서 여러 개의 Parameter가 있는 생성자를 가질 수 있음. <br>
  
+ **기본 생성자 (Default Constructor)** <br>
  Parameter가 없는 생성자를 의미 <br>
  기본 생성자는 모든 데이터 멤버를 리터럴 값으로 초기화할 때 사용 <br>
  매개변수 목록 자체가 없으므로 오버로드할 수 없음. <br>
  
+ **복사 생성자 (Copy Constructor)** <br>
  객체의 데이터 멤버를 이전에 만들었던 다른 객체와 동일한 값으로 초기화하고 싶을 때가 있는데, 이럴 때 복사 생성자를 사용. <br>
  객체를 복사하면, 원본과 복사된 사본이 같은 값을 갖는 다른 객체로 만들어짐<br>
  복사 생성자는 매개변수로 자신과 같은 객체의 참조를 하나 받음. <br>
  매개변수 앞에 const 한정자를 붙이는데, 이는 원본 객체를 변경하지 못하게 하기 위해서 붙이는 것임. <br>
  복사 생성자의 매개변수는 Call by Reference 매커니즘으로 이루어짐. <br>
  Call by Reference는 원래 2가지 특징이 있음. <br>
  1. 객체를 물리적으로 복사하지 않음 <br>
  2. 전달된 레퍼런스(별칭)로 값을 변경할 수 있음. <br>
 하지만 복사 생성자의 경우는 const 한정자를 붙여서 값을 변경하지 못하게 하므로, 첫 번째 특징만 갖게 됨 <br>
 추가로 복사 생성자는 매개변수 목록의 형태가 고정되어 있으므로, 오버로드할 수 없음. <br>

#### 생성자 정의

생성자는 특별한 멤버 함수로, 리턴값을 가질수 없고 이름은 클래스와 같다고 하였음. 
생성자 정의와 다른 멤버 함수 정의의 주요한 차이점은 생성자의 헤더 뒷부분에 있음. <br> 
생성자는 함수 헤더 뒤에 초기화 리스트(Initialization list)라는 문법을 사용해서 데이터 멤버를 초기화 할 수 있음. <br> 
초기화 리스트는 헤더 뒤와 본문 사이에 넣으며 콜론(:)로 시작함 <br>
여러 개의 데이터 멤버를 초기화할 때는 각가의 데이터 멤버를 쉼표로 구분해서 초기화해야함. 

``` cpp
 Circle::Circle(double radius) //매개변수가 있는 생성자 
 : radius(rds){ ... }  
  Circle::Circle() //기본 생성자 
  : rdaius(1.0){...} 
 Circle::Circle(const Circle& cr) // 복사 생성자 
 : radius(cr.radius) {....} 
```
형식을 간단하게 정리한 것 <br>
: 데이터_멤버(매개변수,....,데이터_맴버(매개변수) 

객체륽 만들 때는 상수 데이터도 초기화 해야함. <br>
상수 엔티티는 선언된 이후에 변경할 수 없음. <br> 
하지만 생성자의 초기화 리스트에서 상수 데이터 값을 변경 할 수 있음 <br>
물론, 초기화 목록에서 초기화하기 힘든 복잡한 데이터 멤버를 사용한 경우가 있는데, 이럴 경우에는 생성자의 본문에서 해주면 됨. 즉, 매개변수의 유효성 검사, 파일 열기 등의 작업등은 생성자 본문에서 작성. <br> 

#### 소멸자

소멸자도 2가지 특징이 있음.  <br>
1. 소멸자의 이름은 클래스 이름 앞에 물결(~)기호가 붙은 형태.<br>
2. 생성자와 마찬가지로 소멸자는 리턴값을 가질 수 없음. <br>

    소멸자는 객체가 스코프를 벗어나는 등의 상황에 **자동적으로 호출** 됨. <br>
   객체 내부에서 파일 등을 여는 부가적인 작업을 했을 때, 이를 정리하는 과정이 반드시 필요함. <br>
   따라서 이러한 상황에 소멸자를 유용하게 활용 할수 있음.<br>
   소멸자는 별도의 매개변수를 가잘수 없으므로  오버로드 할수 없음. <br>

   + **소멸자 선언**<br>
   예시 :
```cpp
   class Circle{
... 
public: 
 .....
 ~Circle(); //소멸자  
}
```

   + **소멸자 정의**<br>
   소멸자도 다른 멤버 함수처럼 정의 <br>
하지만 이름 앞에 물결(~)기호가 있음 <br>
소멸자는 **public**을 적용해야함 <br>

```cpp
Circle::~Circle(){....} 
```

#### 생성자와 소멸자의 호출. <br>
생서자를 호출하면 객체가 생성됨. 그리고 생성자 내부에서 데이터 멤버를 초기화 함. <br>
객체가 완전히 제거될 때는 소멸자가 호출됨. <br>
소멸자 내부에서는 데이터 멤버를 정리함. 객체가 파괴되고 나면 객체가 있던 메모리 영역이 해제됨 <br>

----------------
### 7.4 인스턴스 멤버

지금까지 클래스를 정의하는 방법, 클래스를 기반으로 객체를 인스턴스화하는 방법, 객체의 데이터 멤버와 멤버 함수에 대해 알아봤음.<br>
여기와 다음 7.5에서 멤버를 조금 더 자세하게 알아보고, 멤버 사이의 상호 작용에 대해 알아본다. <br>
클래시를 설계할 때는 인스턴스 멤버와 클래스 멤버라는 2가지 멤버 그룹을 사용하므로, 이를 이해하면 클래스를 더 잘 설계할 수 있음. <br>
인스턴스 데이터 멤버(instance data member)는 인스턴스의 속성을 정의. <br>
따라서 각각의 객체는 클래스에 정의된 데이터 멤버들을 캡슐화해야함. <br>
이러한 데이터 멤버는 해당 인스턴스에만 속하므로, **인스턴스끼리 서로 접근할 수 없음** <br>
캡슐화라는 용어는 객체별로 메모리 영역을 할당하기에, 각 영역에서 객체마다 서로 다른 데이터를 갖는 속성을 의미 <br>

+ **인스턴스 데이터 멤버의 접근 제한자**

  인스턴스 데이터 멤버에는 private과 public이라는 접근 제한자를 적용할 수 있음. <br>
  하지만 인스턴스 데이터 멤버는 일반적으로 **private**으로 설정하는 것이 좋음. <br>
  만약에, 인스턴스 멤버를 public으로 만들면 멤버 함수를 호출하지 않고도 애플리케이션에서 데이터 멤버에 접근할 수 있기 때문임 <br>
  이는 객체 지향 프로그래밍의 기본 개념에서 어긋난다. <br>
  객체가 행위(멤버함수)를 통해서 속성을 조작하는 것이 객체 지향의 기본 원리이기 때문 <br>
  따라서, 인스턴스 멤버 함수를 통해서만 데이터 멤버에 접근할 수 있도록 인스턴스 데이터 멤버를 private로 만드는것이 좋음. <br>
  
#### **인스턴스멤버함수**

인스턴스 데이터 멤버(instance data member)는 인스턴스의 행위를 의미하며, 객체의 인스턴스 데이터 멤버를 조작하기 위해서 사용함. <br>
인스턴스 데이터 멤버는 모든 객체가 개별적으로 갖지만, 멤버 함수는 메모리 위에 하나만 올라가며, 모든 객체가 개별적으로 갖지만, 멤버 함수는 메모리 위에 하나만 올라가며 모든 인스턴스가 공유함. <br>
즉, 인스턴스 멤버 함수는 종류별로 하나만 메모리에 올라갑니다. <br>

+ **인스턴스 멤버 함수의 접근 제한자**
  
  인스턴스 멤버 함수는 일반적으로 **public**접근 제한자를 붙임. <br>
  그래야 클래스 외부(애플리케이션 부분 등)에서 멤버 함수에 접근할 수 있기 때문.<br>
  물론 클래스 내부의 멤버 함수에서만 접근해야 하는 함수를 만들 때도 있음. 이러한 특별한 경우에는 private 접근 제한자를 사용 <br>
  
+ **인스턴스 멤버 함수 선택자**

  객체 지향 프로그래밍의 애플리케이션 부분(main 함수 등)에서는 인스턴스를 생성하고, 그 인스턴스가 인스턴스 멤버 함수를 호출하게 해야함 <br>
  인스턴스가 스스로 동작하는 것처럼 코드를 작성하는 것이 객체 지향프로그래밍의 기본 원리 <br>
  C++은 이를 위해서 멤버 선택 연산자(Member selector operators)로 2개의 연산자를 제공

.연산자 : 후위, 멤버 선택, 표현식: **객체.멤버** (우선 순위 18) 결합 방향 : -> <br>
->연산자 : 후위, 멤버 선택, **포인터->멤버** (우선 순위 18) 결합 방향 : -> <br>

p.s 락킹과 언락킹이란? 
만약에, 멤버 함수 하나만 메모리에 올라간다면, 어떻게 여러 객체가 멤버 함수를 공유할 수 있을까?  <br>
어떤 객체가 멤버 함수를 사용하고 있을 때, 다른 객체가 멤버 함수를 사용하지 못하게 막는 것 일까?, 다른 말로 표현하면 어떻게 어떤 객체가 함수를 사용하고 있을 때 잠그고(lock), 모두 사용한 뒤에 다른 객체가 사용할 수 있도록 잠금을 해제(unlock)를 할 수 있는 것일까?  <br> 
해결 방법은 백그라운드에서 함수를 잠그는 락킹(locking)과 잠금을 해제하는 언락킹(unlocking)이다.  <br>
이를 위해서, 멤버 함수에 포인터(객체의 주소를 나타내는 변수)를 지정하는 방법을 사용한다.  <br>
점(dot) 멤버 선택 연산자를 사용하면, 컴파이를 이를 포인터 멤버 선택 연사자로 변경한다. this 포인터가 있는데, 모든 멤버 함수에는 this 포인터가 숨겨져 있다. <br>
this 포인터는 현재 사용하고 있는 객체를 나타내기 위한 포인터이다.  <br>

+ 숨겨진 매개변수
  인스턴스 멤버 함수는 어떻게 this 포인터에 객체의 주소를 할당할 수 있을까?  <br>
  이는 컴파일러가 멤버 함수의 매개변수에 this 키워드를 자동으로 추가하기 때문이다. <br>

  ```cpp
  double getRadius() const {
  return radius;
  }
  ```

  ```cpp
  double getRadius() const {
  return (this->radius);
  }
  ```
->연산자는 간접 참조 연산자(indirection operator)와 멤버 선택 연산 (member operation)이 조합된 특수한 연산자이다. <br>

```cpp
this->radius와 (*this).radius는 같다. 
```

인스턴스 멤버 함수 호출을 위해서 멤버 선택 연산자를 사용하면, 컴파일러는 다음과 같은 형태로 변경됨.  <br>

```cpp
circle1.getRadius();
```

```cpp
this = &circle1;
getRadius(this);
```

+ **명시적 포인터 사용**
  프로그램 내부에서 this 포인터를 사용해서 데이터 멤버를 명시적으로 가리킬 수 있다. <br>
  this 포인터를 사용하지 않은 경우, 변수 이름 충동을 피하기 위해서 데이터 멤버와 매개변수를 다른 이름으로 사용해야 함. <br>
  하지만 this 포인터를 사용하면 데이터 멤버와 매개변수를 같은 이름으로 사용할 수 있음.  <br>

```cpp
  
//this 포인터를 사용하지 않은 겨웅 
  void Circle::setRadius(double rds)
  {
  radius = rds;
  }

  //this 포인터를 사용한 경우 
    void Circle::setRadius(double rds)
  {
  this->radius = rds;
  }
  ```

참고로 **생성자의 초기화 리스트 실행 중에는 아직 객체가 생성되지 않은 상태이므로 this 포인터를 사용할 수 없음.** <br>
하지만 생성자 본문은 객체가 메모리에 올라간 이후에 실행되므로, **생성자의 본문에서는 this포인터를 사용할 수 있다. 호스트 객체(host object)는 인스턴스 멤버 함수를 호출하는 객체**를 의미.
즉, **this 포인터가 가리키는 객체가 바로 호스트 객체이다.** 
따라서 어떤 인스턴스 멤버 함수가 실행되는 동안 호스트 객체는 **단 하나**이다. 

+ **접근자 멤버 함수**
  
  **접근자 멤버 함수 (accessor member function)는 호스트 객체의 정보를 추출(get)할 때 사용하는 함수**
  
  **겟터**(getter)라고도 함. <br>
  추출만 하므로, 객체의 상태를 변경하지는 않는다. 다른 말로 하면 읽기 전용(read-only)함수 <br>
  예를 들어서 Circle 객체의 반지름 값을 리턴하는 인스턴스 멤버 함수가 바로 접근자 인스턴스 멤버 함수이다. <br>
  접근자 인스턴스 멤버 함수가 객체의 상태를 변경하지 않는다는 것을 확실하게 할 수 있도록, 함수 헤더 끝에 **const한정자**를 추가하는것이 좋음<br>

 ```cpp
  //호스트 객체를 변경하지 않도록 cosnt 한정자 추가
  double getRadius() const;
  double getPerimeter() const;
  double getArea() const;
```

접근자 함수는 일반적으로 매개변수 목록을 갖지 않는다. <br>
헤더 끝에 있는 const 한정자는 호스트 객체를 상수 객체 (값을 변경할 수 없는 객체)로 만들어 줌<br>
접근자 멤버 함수에서 데이터 멤버의 값을 무조건 리턴할 필요는 없다. <br>
다음과 같이 출력하는 기능을 하는 함수도 접근자 멤버 함수라고 할 수 있다. <br>

```cpp
void Circle::print() const{

cout << "Radius : " << radius << endl;
cout << "Perimeter : " << 2 * radius * 3.14 << endl;
cout << "Area : " << radius * radius * 3.14 << endl; 
}
```

참고로 추출 연산자 (<<)도 cout 객체의 접근자 함수이다. 

+ **설정자 멤버 함수**

클래스 자료형의 객체는 일반적으로 매개변수가 있는 생성자에서 초기화. <br>
하지만 이후에, 데이터 멤버를 변경해야 할 때도 있음. <br> 
예를 들어, 은행 계좌를 나타내는 클래스를 만든다고 가정해보자, 은행 계좌는 시간이 지나면서 입금과 출금에 의해서 잔액이라는 속성이 변경됨. <br>
이러한 경우에는 **호스트 객체의 상태를 변경하는 인스턴스 멤버 함수**가 필요. <br>
이러한 **함수는 설정자 멤버 함수(mutator member functiuon)이며 셋터(setter)라고 부르기도 함** <br>
설정자 멤버 함수는 호스트 객체의 상태를 변경하므로 const한정자를 붙이면 **안된다** <br>
Circle 클래스에도 다음과 같은 설정자 멤버 함수가 하나 있다. <br>

```cpp
void setRadius(double rds); //설정자에는 const한정자를 붙이지 않음. 
```

**설정자 인스턴스 멤버 함수의 역할은 데이터 멤버의 값을 변경 하는 것.** <br>
따라서 매개변수가 없어도 데이터 멤버의 값을 변경한다면 설정자 함수임. <br>
예를 들어 다음과 같이 Circle 클래스 객체의; 반지름 값을 사용자로부터 입력받아서 데이터 멤버를 변경하는 input함수도 설정자 멤버 함수이다.<br>
```cpp
void Circle::input()
{
 cout << "Enter the radius of the circle object : " ;
cin >> radius;
}
```
삽입 연산자(>>)도 cin 객체의 접근자 함수이다. <br> 
**생성자와 소멸자는 객체를 초기화하거나 정리하는 등 객체의 상태를 변경하므로 설정자 함수**라고 할 수 있다 <br>

  #### **클래스 불변 속성**

클래스를 디자인할 때 중요한 문제로 클래스 불변 속성이 있다. <br>
클래스 불변 속성(class invariant)은 **클래스의 데이터 멤버의 일부 또는 전체에 적용해야 하는 하나 이상의 조건을 의미** <br>
인스턴스 함수에 사용해서 적용함. 따라서, 인스턴스의 데이터 멤버와 멤버 함수와 관련된 문제임.

불변 속성은 쉽게 말해서, **"설계적으로 지켜야 하는 조건"** 이라고 이해하면 된다. 

예를 들어서 Circle 클래스는 원을 나타낸다. 길이는 음수가 될 수 없기 때문에 radius는 양수여야 한다.<br> 
radius는 double 자료형으로 정의하는 것만으로는 double 자료형에 음수가 들어가는 문제를 컴파일러가 찾을 수 없다. <br>
객체를 생성하는 인스턴스 데이터 멤버 함수(매개변수가 있는 생성자) 또는 데이터 멤버의 값을 변경하는 설정자 멤버 함수에서 클래스의 불변 속성을 적용함. 
Circle 클래스의 매개변수가 있는 생성자를 다음 코드처럼 만들면, 불변 속성을 보장할 수 있다. <br>

```cpp
Circle::Circle(double rds) : radius(rds)
{
   if(radius <= 0.0){
cout << "No circle can be made!" <<endl;
cout << "The program is aborted" << endl;
assert(false);
}
  }
```

만약에 radius에 음수가 들어가면 객체를 만들 수 없으므로, 프로그램의 나머지 부분에 큰 영향을 줄 수 있음. <br>
따라서 프로그램을 종료해야 함. <br>
**assert 함수는 매개변수가 true일 때, 아무 것도 하지 않지만, 매개변수가 false라면 프로그램을 중단**한다.<br>
프로그램을 강제로 중단하기 위해서 false를 매개변수로 넣어서 사용. <br>
assert함수를 사용하려면 **<cassert>헤더 파일**을 읽어 들어야한다. <br> 

[코드7.4 Rectangle 클래스 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-4.cpp)

--------------------------
  ### 7.5 정적 멤버

클래스 자료형에는 인스턴스 멤버와 정적 멤버라는 2가지 멤버가 있는데,  인스턴스 멤버와 마찬가지로 정적 멤버도 정적 데이터 멤버와 정적 멤버 함수로 구분할 수 있다. <br>
**정적 데이터 멤버(static data member)는 클래스 또는 모든 인스턴스에 포함되는 멤버**이다. <br>
정적 데이터 멤버를 설명하는 데 자주 사용되는 예로 "클래스의 인스턴스 수 추적하기"가 있다. <br>
const라는 정적 데이터 멤버를 생성한 뒤, 0으로 초기화하고 인스턴스가 생성될 때 마다 count를 증가시키면, 지금까지 생성된 인스턴스의 수를 구할 수 있다.<br>
추가로 객체가 파괴될 때, 소멸자를 사용해서 count를 감소시키면서 현재 프로그램에 남아있는 인스턴스 수를 추적할 수 도 있다. <br>

+ **정적 데이터 멤버 선언**

  정적 데이터 멤버는 클래스 정의에서 선언해야하고 static 키워드를 붙여야 함. <br>
  다음 코드는 클래스 정의 내부에서 count라는 정적 데이터 멤버를 선언하는 예시임. <br>

  ```cpp
  class Reactangle
  {
  private:
  ....
    static int count; // 정적 데이터 멤버
  public:
  ....
  }
  ```
  
+ **정적 데이터 멤버 초기화**

인스턴스 데이터 멤버는 일반적으로 생성자에서 초기화하지만, 정적 데이터 멤버는 인스턴스에 속하는 것이 아니므로 생성자에서 초기화할 수 없음.<br>
즉, 정적 데이터 멤버는 클래스 정의 후에 초기화 해야함. 따라서 프로그램의 전역 영역에서 초괴화를 한다. <br> 
일반적으로 클래스 정의 바로 뒷 부부분의 전역 영역에서 작성. <br>
**값을 초기화 할 때는 클래스 이름과 클래스 스코프 연산자(::)를 추가해서 클래스에 속한다는 것을 나타내야한다.** <br>
다만 statci 한정자를 추가하면 안됨. **클래스 정의 부분에서 이미 정적 데이터 멤버로 선언했으므로, 추가로 붙일 필요가 없음** <br>

```cpp
int Rectangle::count = 0; //정적 데이터 멤버 초기화
```

#### **정적 멤버 함수**

정적 데이터 멤버를 선안하고 초기화 한 후, 어떻게 접근을 할 수 있을까? <br>
일반적으로 정적 데이터 멤버는 private이므로, 이에 접근할 수 있는 public이 적용된 멤버 함수가 필요하다. <br>
인스턴스 멤버 함수에서도 정적 데이터 멤버에 접근할 수 있지만, 일반적으로 정적 데이터 멤버에 접근할 때는 정적 멤버 함수를 사용함. <br>
정적 멤버 함수는 객체를 따로 선언하지 않아도 클래스 이름을 통해 사용할 수 있음. 따라서, 정적 멤버 함수를 사용하면 인스턴스 내부 또는 애플리케이션 부분에서도 데이터 멤버에 접근할 수 있다. <br>
참고로, 정적 멤버 함수는 인스턴스와 연결되지 않으므로 호스트 객체가 없다.  <br>

+  **정적 멤버 함수 선언**
  정적 데이터 멤버처럼 정적 멤버 함수도 클래스에 속한다. <br>
클래스 내부에 멤버 함수처럼 선언하지만, static 키워드를 붙여야한다. <br>


  ```cpp
  class Reactangle
  {
  private:
  ....
    static int count; // 정적 데이터 멤버
  public:
  ....
static int getCount();//정적 멤버 함수
....
  }
  ```

+  **정적 멤버 함수 정의**
  정적 멤버 함수는 인스턴스 멤버 함수 처럼 클래스 외부에서 정의  <br>
정의할 때는 정적 멤버 함수와 인스턴스 멤버 함수의 차이가 없다.  따라서 함수가 인스턴스 멤버 함수인지, 정적 멤버 함수인지 알려면 선언 부분을 확인해야한다. <br>

```cpp
int Rectangle::getCount()
{
return count;
}
```

정적 멤버 함수는 호스트 객체가 없으므로 const 한정자를 사용할 수 없다 <br>

+  **정적 멤버 함수 호출**

정적 멤버 함수는 인스턴스 또는 클래스를 통해서 호출 할 수 있음. <br> 
인스턴스에서 정적 멤버 함수를 호출할 때는 인스턴스 멤버 함수를 호출할 떄와 같은 구문을 사용함. <br>
클래스를 통해서 정적 멤버 함수를 호출할 때는 클래스 이름과 클래스 범위 연산자(::)를 앞에 붙여서 사용 

```cpp
rect.getCount(); //인스턴스로 접근
Rectangle::getCount(); //클래스로 접근 
```

정적 멤버 함수에는 호스트 객체가 없다. 따라서 정적 멤버 함수 내부에서 인스턴스 데이터 멤버에는 접근할 수 없다. <br>
반면 인스턴스 멤버 함수에서는 정적 데이터 멤버에 접근 할 수있음. <br>
하지만 일반적으로 인스턴스 멤버 함수에서 정적 데이터 멤버에는 접근하지 않는다. <br>
인스턴스 멤버 함수는 인스턴스 데이터 멤버에 접근할 때, 정적 멤버 함수는 정적 데이터 멤버에 접근할 때 사용하는 것이 좋음. <br>

[코드7.5 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-5.cpp)

[코드 7.6참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7_6.cpp)

-------------------------
### 7.6 객체지향 프로그래밍

#### **파일 분할**

 C++은 일반적으로 클래스 정의, 멤버 함수 정의, 애플리케이션 3가지 부분으로 코드가 구분 됨.<br>
 따로 만들거나 하나의 파일처럼 만들 수 있음
 
+ **인터페이스 파일**
  
  클래스 정의(데이터 멤버 선언과 멤버 함수 선언)가 포함된 파일 <br>
  클래스의 형태를 다른 파일 알려주는 역할을 함 <br>
  즉, 구현 파일과 애플리케이션 파일에게 클래스가 어떻게 설계되었는지를 알려줌.<br>
  일반적으로 .h로 즉 헤더파일을 의미함. <br>
  
+ **구현 파일**
  
  멤버 함수 정의가 포함된 파일. <br>
  인터페이스 파일에는 모든 멤버 함수의 선언을 입력.<br>
  일반적으로 .cpp파일을 의미함 <br>
  
+ **애플리케이션 파일**
  
  객체를 인스턴스화하고 객체를 활용하는 main함수의 코드가 포함된 파일. <br>
  애플리케이션 파일은 **반드시 cpp확장자**를 사용해야함.<br>

#### **분할 컴파일**

파일을 3개 만들었다면, 모든 파일을 **컴파일**해서 실행 파일을 만들어야 함 <br>
분할돤 파일을 컴파일하는 것을 **분할 컴파일(separate compilation)** 라고 함<br>
분할 컴파일 과정은 OS에 상관없이 동일하지만 컴파일 명령어 이름, 생성되는 파일의 이름과 확장자는 환경에 따라서 다를 수 있음. <br>

+ **분할 컴파일 과정**
  
1. 인터페이스 파일에는 클래스 정의만 작성, 이 파일은 이후에 구현 파일과 애플리케이션 파일에서 읽어 들여야 함. <br>
(Circle Class라면 인터페이스 파일은 circle.h파일로 만든다) <br>
2. 구현 파일에서는 include 지시문으로 인터페이스 파일을 읽어 들인다.<br>

```cpp
-c circle.cpp
```

컴파일에 성공하면 확장자가 o인 객체 파일이 만들어진다. 

3. 애플리케이션 파일에는 main함수를 작성 <br>
애플리케이션의 가장 앞부분에서는 인터페이스 파일을 읽어 들어야함. <br>

```cpp
-c app.cpp
```

컴파일에 성공하면 확장자가 o인 객체파일이 만들어짐. 

4. 만들어진 2개의 객체 파일을 -o 옵션과 함께 입력해서 실행파일을 만듬. <br>

```cpp
-o application circle.o app.o
```

5. 최종적으로 만들어진 실행파일을 실행한다.
```cpp
application
```
 
+ **인터페이스 파일 생성**
  
[코드 7.7 헤더 파일 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-7/7-7_interface.h) 

+ **구현 파일 생성**
  
  [코드 7.7 구현 파일 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-7/7-7_circle.cpp)

+ **애플리케이션 파일 생성**
  
  [코드 7.7 애플리케이션 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-7/7-7_app.cpp)

+ **컴파일, 링크, 실행**
  
  ```cpp
  c++ -c circle.cpp 
  c++ -c app.cpp
  c++ -o application circle.o app.o
  application
  ```

#### **전처리 지시문**

같은 헤더 파일을 2회 이상 읽으면 컴파일 할 때 오류가 발생함 <br>
이러한 상황을 막으려면 **#define, #ifndef, #endif라는 3가지 전처리 지시문(preprocessor directive)** 를 사용 <br>

```cpp
#ifndef CIRCLE_H
#define CIRCLE_H
//헤더파일 내용
#endif
```

이러한 지시문들은 플래그(상수)로 작동. <br>
ifndef 지시문은 if 조거문과 비슷함. 만약 플래그가 정의되어 있지 않다면  ifndef의 본문을 읽어 들여 CIRCLE_H의 코드를 포함한다. <br>
플래그가 이미 정의되어 있다면, 이후의 내용을 무시하고 곧 바로 endif지시문 위치로 이동.  <br>

```cpp
#ifndef CIRCLE_H
#define CIRCLE_H
//헤더파일 내용 -> 읽어 들임
#endif
...
#ifndef CIRCLE_H
#define CIRCLE_H
//헤더파일 내용 -> 무시됨 
#endif
```

#### **캡슐화**

캡슐화는 객체 지향 프로그래밍의 목표이며, 클래스 설계와 클래스 사용을 구분함.  <br>

+ **클래스 설계와 사용**
  
+ **공용 인터페이스**
  
  사용자가 애플리케이션에서 클래스를 사용하는 방법을 이해할 수 있게 정리한 멤버 함수의 선언과 설명을 정리한 것 

--------------------------
### 7.7 클래스 설계 
 
 [코드 7.10 헤더파일 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-10/7-10_interface.h)
 
 [코드 7.10 구현파일 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-10/7-10_fraction.cpp)
 
 [코드 7.10 애플리케이션 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-10/7-10_app.cpp)

  [코드 7.13 헤더 파일 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-13/7-13_interface.h)
  
  [코드 7.13 구현 파일 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-13/7-13_time.cpp)
  
  [코드 7.13 애플리케이션 참고](https://github.com/ysungJ/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter7/7-13/7-13_app.cpp)
