## 7장 클래스와 생성자 
C++를 객체 지향 언어로서 사용하는 방법을 배움 <br>
객체를 생성하고 소멸하는 원리를 배우고, 인스턴스 멤버와 정적 멤버의 역할을 구분 및 캡슐화에 대해 익힘

--------------
### 7.1 클래스의 개요 
C++는 절차 지향과 객체 지향 패러다임이 결합된 언어. <br>
7장에서는 객체 지향 패러다임을 적용하여 객체 지향 언어로서 C++를 사용하는 방법을 배움 <br>
더 나아가 어떻게 새로운 타입을 만들며 활용하지를 대해 알아봄 <br>
새로운 타입을 만드는 매커니즘으로는 클래스(class)와 열거형 (enumerated type)이 존재함. <br>
7장은 클래스 중점적으로 학습 <br>

#### 타입과 인스턴스
타입을 이용해 인스턴스를 생성할 수 있음. <br>
type은 추상화 된 것이고, instance는 타입을 실체화한 구체적인 실체를 뜻함. <br> 
type과 instance관계는 one-to-many 관계임. <br> 
하나의 타입을 기반으로 많은 인스턴스를 생성할 수 있음.

+ **속성**
  속성(attribute)은 인스턴스가 가지는 특징을 의미함. <br>
  CS에서의 속성이란 우리가 관심 있어 하는 특성임 <br>
  예를 들어, 직원이라는 인스턴스가 있다면 직원의 이름, 주소, 급여 등에 관심이 있을 것임.
  
+ **행위**
  인스턴스는 어떤 행위(behavior)를 가짐 <br>
  행위란 어떤 인스턴스가 스스로 할 수 있는 작업 또는 연산을 뜻함. <br>
  예를 들어, 인스턴스가 직원이면 직원에게 이름, 주소, 급여을 지정할 수 있어야함. <br>
  참고로, 객체지향 프로그래밍에서의 인스턴스는 스스로 작업 또는 연산을 할 수 있어야함 <br>

#### 클래스와 객체
  객체지향 언어에서는 타입과 인스턴스라는 용어를 자주 사용 <br>
  C++는 Class라는 구문을 사용하여 타입(사용자 정의 자료형)을 만듦. <br>
  이러한 CLass를 기반으로 만든 인스턴스를 객체라고 함. 
  또는 인스턴스라고 그냥 부르기도 한다. <br> 
  객체 지향에서 객체의 속성과 행위는 데이터 멤버와 멤버 함수로 만듦 <br>

+ **데이터 멤버**
  속성을 표현하기 위한 변수를 의미
  
+ **멤버 함수**
함수는 어떤 행위를 할 수 있는 기능의 모임임 <br>
객체의 행위는 멤버 함수를 사용해서 구현함. <br>
이러한 함수를 만들 때, 속성과의 관계를 항상 고려해야함 <br>

#### 정리
타입(type) == Type or Class <br> 
instance == 인스턴스 또는 객체 <br> 
속성 == 데이터 멤버 <br>
행위 == 멤버 함수 <br> 

--------------------
### 7.2 객체지향과 클래스 

#### 객체 지향에 필요한 클래스의 구조

새로운 자료형(타입)을 만들 때는 클래스를 사용 <br>
객체 지향 프로그램에서는 타입으로 클래스를 만들고, 이를 기반으로 인스턴스인 객체를 만듬 <br>
클래스를 기반으로 인스턴스를 만드는 것을 인스턴스화(Instantiation)라고 함.

절차 지향 프로그램에서는 기본 자료형을 활용하는 함수를 모아 애플리케이션(응용 프로그램)만 만들면 됨 <br> 
객체 지향 프로그래밍을 할 때는 클래스의 정의, 멤버 함수의 정의, 애플리케이션(클래스를 기반으로 객체를 만들어서 사용하는 부분)이 필요함. <br> 
이 부분이 절차 지향과 객체 지향의 차이점임 <br>
물론, 각각의 부분이 다른 것으로 교체될 수 있지만, 전체적인 원리는 변하지 않는다. <br> 

--------------------------

**클래스의 정의 -> 속성과 행위 선언** <br>
**멤버 함수의 정의 -> 행위 정의** <br>
**애플리케이션 -> 객체를 인스턴스화하고 사용** <br> 

---------------------------

클래스의 정의 부분에서는 데이터 멤버와 멤버 함수를 선언하고, <br> 
멤버 함수의 정의 부분에서는 모든 멤버 함수를 정의함.<br> 
애플리케이션 부분에서는 클래스의 인스턴스를 만들고, 멤버 함수를 사용함 

#### 클래스의 정의 

새로운 타입을 만들려면 클래스의 정의(Class definition)를 작성해야함. <br>
클래스 정의는 헤더, 본문, 세미콜론이라는 세부분으로 구성됨 <br> 
클래스 헤더(Class header)는 class라는 키워드 뒤에 클래스의 이름을 붙여서 만듦 <br> 
사용자 정의 자료형은 소문자와 대문자 어떤 것을 사용해도 관계 없음. <br>
하지만, 일반적으로 클래스 이름의 경우는 대문자로 시작하게 만들어 소문자로 시작하는 라이브러리 클래스와 구분하는 것이 좋음. <br>

**클래스 작성 예시**

class Circle { //헤더 

private: <br>
double radius; //데이터 멤버 선언

// 멤버 함수 선언 <br> 
public: <br>
double getRadius() const; <br>
double getArea() const; <br>
double getPerimeter() const; <br>
double setRadius(double value); <br> 
};

+ **데이터 멤버 선언**
  
  클래스의 정의의 첫 번째 부분은 데이터 멤버를 선언하는 부분임 <br>
  데이터 멤버는 내장 자료형으로 만들 수 있고, 이전에 정의한 다른 클래스로도 만들 수 있음.<br>
  클래스의 속성을 구현하는데 사용할 것들을 데이터 멤버로 만듦

  객체는 속성을 여러 개 가질 수 있고, 일부 속성은 다른 속성에 의존하여 계산되는 경우도 있음. <br>
  따라서, 어떤 속성이 단독으로 존재할 수 있는지, 그리고 어떤 속성이 다른 속성에 의존해야하는지를 알아야 함. <br>
  
+ **멤버 함수 선언**
  
  클래스의 행위를 구현하는 데 사용할 함수를 만듦. <br>
  함수 선언(프로토타입)부분과 비슷함. 다만, 함수 끝에 const 한정자가 오는 경우도 있고, 오지 않는 경우도 있음. <br>
  함수 내부에서 어떠한 것도 변경하지 못하게 할 때는 const 한정자를 붙이고, 변경을 허가할 때는 const 한정자를 붙이지 않음. <br>
  
+ **접근 제한자(access modifier)**
  
접근 제한자(access modifier)는 접근 권한을 나타낼 때 사용함. <br>
클래스에서 데이터 멤버와 멤버 함수를 선언하면 기본적으로 private 접근제한자를 가짐.
  private접근 제한자가 붙으면 해당 요소로부터 값을 추출할 수도 없고, 값을 변경할 수 없음. <br>
C++은 값을 접근하기위해, private, protected, public이라는 3가지 접근 제한자를 제공함. <br>

+ private
  private로 선언되어 있다면, 클래내스 내부(멤버 함수를 통해서)에서만 접근할 수 있음. <br>
  즉, 같은 클래스에서만 접근이 가능하며, 서브 클래스와 다른 모든 곳으로부터의 접근은 불가능함 <br>
  
+ public
  public으로 선언되어 있다면, 모든 곳(같은 클래스, 서브 클래스 내부, 애플리케이션)에서 접근 가능.<br>
  즉, 모든 곳에서 접근이 가능하다.

  + protected
    protected는 같은 클래스와 서브 클래스에서의 접근은 가능하지만 모든 곳으로부터의 접근은 불가능함 <br>
    추가적인 내용은 서브클래스를 다루는 11장에서 설명할 예정.

  + 데이터 멤버와 접근 제한자
    
    데이터 멤버에는 일반적으로 private를 적용함 <br>
    기본적으로 private가 붙지만, 강조하기위해서 prrivate을 붙여서 사용함. <br>
    private가 적용된 멤버는 멤버 함수를 통해서만 접근할 수 있음. <br>
    
  + 멤버 함수와 접근 제한자
 
    데이터 멤버에 접근해서 어떤 작업을 하려면, 애플리케이션에서 멤버 함수를 사용할 수 있어야함 <br>
    따라서 일반적으로 멤버 함수는 public을 적용함 <br>
    하지만 클래스 내부(동일한 클래스의 다른 멤버 함수 등)에서만 활용하는 경우에는 멤버 함수의 접근 제한자를 private로 설정하기도 함
    
  + 그룹 함수와 접근 제한자
    접근 제한자는 각각의 것 앞에 붙이는 것이 아니라 **그룹 단위**로 붙임 <br>
    private : 하고 그뒤에 private로 선언할 데이터 멤버를 입력 함 <br>
    public : 똑같음 <br>

    접근 제한자는 다른 접근 제한자를 만나기 전까지 유지됨. <br>

#### 멤버 함수 정의

멤버 함수는 단순하게 함수의 프로토타입을 적은 것으로, 별도의 정의가 필요함. <br>
Example) <br>
doulbe Circle::getRadius() const{

return radius;

}

double Circle::getArea() const {

const double PI = 3.14; <br>
return(PI * radius * radius);

}

기본적인 함수 정의와 비슷하지만 2가지 차이점이 있음. <br>
먼저 멤버 함수에는 한정자(Const)가 있다는 것임. <br>
두 번째는 멤버 함수에는 앞에 클래스 이름이 붙는다는 것임. <br>

데이터 멤버는 클래스 정의 내부에 작성하기 때문에 멤버 함수를 정의할 때에는 클래스 이름을 붙여 함<br>
참고로 클래스 스코프 연산자의 위치와 리턴 자료형의 위치가 헷갈리는 경우가 있는데, 함수의 리턴 자료형이 언제나 앞에 옴<br> 

  #### 인라인 함수

  함수 본문이 너무 짧으면, 함수를 실행하는 시간 (매개변수 저장, 제어 이동, 매개변수 추출, 리턴값  저장 등)이 함수 내부의 코드를 실행하는 시간보다 오래 걸릴 수 있음. <br> 
  프로그램의 성능을 위해서 컴파일러가 함수 호출 부분을 실제 코드로 대체해버리게 만들고 싶을 때는 함수를 인라인 함수로 선언함. <br> 
  물론 컴파일러가 이를 무시할 수도 있으며 인라인 함수는 필요한 곳에 사용할 수 있음. <br>
  최근에는 컴파일러의 성능이 좋기 때문에, 필요한 경우 컴파일러가 인라인 함수로 알아서 구성함. <br>
  반대로 개발자가 인라인 함수로 만들 수 없는 정도의 내용을 인라인 함수로 강제로 만들면, 이를 무시하기도 함. <br>

  + **암묵적 인라인 함수**

  class Circle{

private:

  double radius;

  public:

  double getRadius() const {return radius;}

  ....
  
  }

  위의 코드처럼, 클래스 정의 내부에 함수를 정의하면, 해당 함수는 인라인 함수가 됨. <br>
  하지만 함수 정의 부분을 읽기 어렵고, 캡슐화 원칙을 위반했기 때문에 추천하지 않음. <br>
  클래스 정의 내부에 함수 정의를 넣었으므로, 이 함수의 정의를 외부에 따로 정의할 필요가 없음. <br>
  
  + **명시적 인라인 함수**
  + 
함수 정의 앞에 inline 키워드를 추가하면 함수를 명시적 인라인 함수로 만들 수 있음. <br>
inline double getRadius() const {return radius;}

#### 애플리케이션

클래스 정의와 멤버 함수를 정의 했으므 로, 메인 함수 부분(애플리케이션 부분)에서 이를 인스턴스화 해야 함. <br> 

+ **객체 인스턴스화**
  
  멤버 함수를 사용하려면, 객체를 인스턴스화 해야함. <br>
  Circle circle1; <br>
  위의 코드를 실행하면 circle1이라는 객체가 만들어짐. <br>
  하지만, 객체 내부에 있는 double 자료형의 radius라는 데이터 멤버(변수)를 초기화하지 않았으므로, 이 데이터 멤버에는 쓰레기 값이 들어감. <br>
  따라서 사용하기 전에 데이터 멤버를 초기화 해줘야 함.
  
+ **객체에 연산적용**

  인스턴스화했다면 멤버 함수로 정의 했던 연산을 사용할 수 있게됨.<br>
  circle1.setRadious(10.0);<br>
   cout << "radius : " << circle1.getRadius() <<endl;
  
+ **멤버 선택**
  
  객체 이름과 멤버 함수 사이에 점(.)이 찍혀있는데, 이는 멤버 선택 연산자 (member selection operator)라고 부르는 연산자임. <br>
  circle1.getRadius(); <br>
  circle2.getRadius(); <br>
  
#### 구조체 

구조체의 모든 멤버는 기본적으로 public <br>
반대로 클래스의 모든 멤버는 기본적으로 private <br> 

일부 경우, 멤버 함수를 사용하지 않을 경우, 쉽게 만들고 요소에 접근할 수 있는 구조체를 사용하기도 함 <br>
연결 리스트의 노드 요소처럼 연관 관계를 갖는 데이터가 있을 때 구조체를 사용하기도 함. <br> 

--------------------
### 7.3 생성자와 소멸자. 

인스턴스는 클래스 정의에 있는 데이터 멤버를 캡슐화한 객체. <br>
객체가 데이터 멤버를 갖고 어떤 작업을 하려면, 객체를 만든 뒤 데이터 멤버를 초기화 하는 작업이 필요함. <br> 
객체는 **생성자(Constructor)** 라고 부르는 특별한 멤버가 호출 될 때 생성됨. <br> 
따라서 생성자 내부에서 초기화를 하면 편리함. <br> 

또한 객체가 더 이상 필요가 없어지는 경우에는 객체가 차지하고 있는 메모리를 비워줘야 한다 -> 메모리 재활용 <br> 
 이 때, **소멸자(destructor)** 라고 부르는 특별한 멤버 함수가 호출되어 소멸자 내부에서 객체를 정리하는 작업을 한다. <br> 

 #### 생성자(Constructor)
 
  객체를 생성하는 특별하는 멤버 함수. <br> 
  생성자 내부에서 객체의 데이터 멤버를 초기화 함. <br>  
  클래스 정의에서 데이터 멤버를 선언한다고, 데이터 멤버가 초기화 되는 것은 아니고, 데이터 멤버를 선언할 때는 멤버의 이름과 자료형만 지정할 뿐임. <br> 
  2가지 특징이 존재함. <br> 
  **1. 리턴 값이 없음** <br>
  생성자는 객체를 생성하고 데이터 멤버를 초기화하는 특별한 역할을 하게 설계 되었기 때문 <br>
  참고로, 생성자 함수 내부에서 값의 유성을 검사하는 등의 별도의 작업을할 수 도 있음. <br>
하지만 이러한 작업도 모두 초기화의 일부일 뿐임. <br>
  **2. 이름이 클래스의 이름과 같음** <br>

생성자는 크게 Parameter가 있는 생성자, 기본 생성자, 복사 생성자라는 3가지로 구분할 수 있음. <br>

+ **생성자 선언**

생성자는 클래스의 멤버 함수이기 때문에, 클래스 정의에서 선언해야함. <br>
생성자는 이전에 설명 했던 것처럼 리턴값이 없고, 이름이 클래스 이름과 동일해야 함. <br>
데이터 멤버를 초기화하는 변경 작업을 하기 때문에 const한정자를 붙일 수 없음. <br>

예시 : <br>
class Circle{

... <br>
public: <br>
 Circle(double radius); //매개변수가 있는 생성자 <br>
 Circle(); //기본 생성자 <br>
 Circle(const Circle& circle);// 복사 생성자 <br>
.... <br>
}

+ **매개변수가 있는 생성자 (Parameter Constructor)** <br> 
  일반적으로 데이터 멤버를 지정된 값으로 초기화 하기 위해서 사용 <br>
  오버로드할 수 있으므로, 시그니처가 다르면서 여러 개의 Parameter가 있는 생성자를 가질 수 있음. <br>
  
+ **기본 생성자 (Default Constructor)** <br>
  Parameter가 없는 생성자를 의미 <br>
  기본 생성자는 모든 데이터 멤버를 리터럴 값으로 초기화할 때 사용 <br>
  매개변수 목록 자체가 없으므로 오버로드할 수 없음. <br>
  
+ **복사 생성자 (Copy Constructor)** <br>
  객체의 데이터 멤버를 이전에 만들었던 다른 객체와 동일한 값으로 초기화하고 싶을 때가 있는데, 이럴 때 복사 생성자를 사용. <br>
  객체를 복사하면, 원본과 복사된 사본이 같은 값을 갖는 다른 객체로 만들어짐<br>
  복사 생성자는 매개변수로 자신과 같은 객체의 참조를 하나 받음. <br>
  매개변수 앞에 const 한정자를 붙이는데, 이는 원본 객체를 변경하지 못하게 하기 위해서 붙이는 것임. <br>
  복사 생성자의 매개변수는 Call by Reference 매커니즘으로 이루어짐. <br>
  Call by Reference는 원래 2가지 특징이 있음. <br>
  1. 객체를 물리적으로 복사하지 않음 <br>
  2. 전달된 레퍼런스(별칭)로 값을 변경할 수 있음. <br>
 하지만 복사 생성자의 경우는 const 한정자를 붙여서 값을 변경하지 못하게 하므로, 첫 번째 특징만 갖게 됨 <br>
 추가로 복사 생성자는 매개변수 목록의 형태가 고정되어 있으므로, 오버로드할 수 없음. <br>

#### 생성자 정의

생성자는 특별한 멤버 함수로, 리턴값을 가질수 없고 이름은 클래스와 같다고 하였음. 
생성자 정의와 다른 멤버 함수 정의의 주요한 차이점은 생성자의 헤더 뒷부분에 있음. <br> 
생성자는 함수 헤더 뒤에 초기화 리스트(Initialization list)라는 문법을 사용해서 데이터 멤버를 초기화 할 수 있음. <br> 
초기화 리스트는 헤더 뒤와 본문 사이에 넣으며 콜론(:)로 시작함 <br>
여러 개의 데이터 멤버를 초기화할 때는 각가의 데이터 멤버를 쉼표로 구분해서 초기화해야함. 

 Circle::Circle(double radius) //매개변수가 있는 생성자 <br>
 : radius(rds){ ... }  <br>
  Circle::Circle() //기본 생성자 <br>
  : rdaius(1.0){...} <br>
 Circle::Circle(const Circle& cr) // 복사 생성자 <br> 
 : radius(cr.radius) {....} <br>

형식을 간단하게 정리한 것 <br>
: 데이터_멤버(매개변수,....,데이터_맴버(매개변수) 

객체륽 만들 때는 상수 데이터도 초기화 해야함. <br>
상수 엔티티는 선언된 이후에 변경할 수 없음. <br> 
하지만 생성자의 초기화 리스트에서 상수 데이터 값을 변경 할 수 있음 <br>
물론, 초기화 목록에서 초기화하기 힘든 복잡한 데이터 멤버를 사용한 경우가 있는데, 이럴 경우에는 생성자의 본문에서 해주면 됨. 즉, 매개변수의 유효성 검사, 파일 열기 등의 작업등은 생성자 본문에서 작성. <br> 

#### 소멸자

소멸자도 2가지 특징이 있음.  <br>
1. 소멸자의 이름은 클래스 이름 앞에 물결(~)기호가 붙은 형태.<br>
2. 생성자와 마찬가지로 소멸자는 리턴값을 가질 수 없음. <br>

    소멸자는 객체가 스코프를 벗어나는 등의 상황에 **자동적으로 호출** 됨. <br>
   객체 내부에서 파일 등을 여는 부가적인 작업을 했을 때, 이를 정리하는 과정이 반드시 필요함. <br>
   따라서 이러한 상황에 소멸자를 유용하게 활용 할수 있음.<br>
   소멸자는 별도의 매개변수를 가잘수 없으므로  오버로드 할수 없음. <br>

   + **소멸자 선언**<br>ㄹ
   예시 : <br>
   class Circle{

... <br>
public: <br>
 .....<br>
 ~Circle(); //소멸자  <br>
}

   + **소멸자 정의**<br>
   소멸자도 다른 멤버 함수처럼 정의 <br>
하지만 이름 앞에 물결(~)기호가 있음 <br>
소멸자는 **public**을 적용해야함 <br>
Circle::~Circle(){....} <br>

#### 생성자와 소멸자의 호출. <br>
생서자를 호출하면 객체가 생성됨. 그리고 생성자 내부에서 데이터 멤버를 초기화 함. <br>
객체가 완전히 제거될 때는 소멸자가 호출됨. <br>
소멸자 내부에서는 데이터 멤버를 정리함. 객체가 파괴되고 나면 객체가 있던 메모리 영역이 해제됨 <br>

----------------
### 7.4 인스턴스 멤버.
