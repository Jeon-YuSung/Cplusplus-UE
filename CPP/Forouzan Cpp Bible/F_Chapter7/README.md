## 7장 클래스와 생성자 
C++를 객체 지향 언어로서 사용하는 방법을 배움 <br>
객체를 생성하고 소멸하는 원리를 배우고, 인스턴스 멤버와 정적 멤버의 역할을 구분 및 캡슐화에 대해 익힘

--------------
### 7.1 클래스의 개요 
C++는 절차 지향과 객체 지향 패러다임이 결합된 언어. <br>
7장에서는 객체 지향 패러다임을 적용하여 객체 지향 언어로서 C++를 사용하는 방법을 배움 <br>
더 나아가 어떻게 새로운 타입을 만들며 활용하지를 대해 알아봄 <br>
새로운 타입을 만드는 매커니즘으로는 클래스(class)와 열거형 (enumerated type)이 존재함. <br>
7장은 클래스 중점적으로 학습 <br>

#### 타입과 인스턴스
타입을 이용해 인스턴스를 생성할 수 있음. <br>
type은 추상화 된 것이고, instance는 타입을 실체화한 구체적인 실체를 뜻함. <br> 
type과 instance관계는 one-to-many 관계임. <br> 
하나의 타입을 기반으로 많은 인스턴스를 생성할 수 있음.

+ **속성**
  속성(attribute)은 인스턴스가 가지는 특징을 의미함. <br>
  CS에서의 속성이란 우리가 관심 있어 하는 특성임 <br>
  예를 들어, 직원이라는 인스턴스가 있다면 직원의 이름, 주소, 급여 등에 관심이 있을 것임.
  
+ **행위**
  인스턴스는 어떤 행위(behavior)를 가짐 <br>
  행위란 어떤 인스턴스가 스스로 할 수 있는 작업 또는 연산을 뜻함. <br>
  예를 들어, 인스턴스가 직원이면 직원에게 이름, 주소, 급여을 지정할 수 있어야함. <br>
  참고로, 객체지향 프로그래밍에서의 인스턴스는 스스로 작업 또는 연산을 할 수 있어야함 <br>

#### 클래스와 객체
  객체지향 언어에서는 타입과 인스턴스라는 용어를 자주 사용 <br>
  C++는 Class라는 구문을 사용하여 타입(사용자 정의 자료형)을 만듦. <br>
  이러한 CLass를 기반으로 만든 인스턴스를 객체라고 함. 
  또는 인스턴스라고 그냥 부르기도 한다. <br> 
  객체 지향에서 객체의 속성과 행위는 데이터 멤버와 멤버 함수로 만듦 <br>

+ **데이터 멤버**
  속성을 표현하기 위한 변수를 의미
  
+ **멤버 함수**
함수는 어떤 행위를 할 수 있는 기능의 모임임 <br>
객체의 행위는 멤버 함수를 사용해서 구현함. <br>
이러한 함수를 만들 때, 속성과의 관계를 항상 고려해야함 <br>

#### 정리
타입(type) == Type or Class <br> 
instance == 인스턴스 또는 객체 <br> 
속성 == 데이터 멤버 <br>
행위 == 멤버 함수 <br> 

--------------------
### 7.2 객체지향과 클래스 

#### 객체 지향에 필요한 클래스의 구조

새로운 자료형(타입)을 만들 때는 클래스를 사용 <br>
객체 지향 프로그램에서는 타입으로 클래스를 만들고, 이를 기반으로 인스턴스인 객체를 만듬 <br>
클래스를 기반으로 인스턴스를 만드는 것을 인스턴스화(Instantiation)라고 함.

절차 지향 프로그램에서는 기본 자료형을 활용하는 함수를 모아 애플리케이션(응용 프로그램)만 만들면 됨 <br> 
객체 지향 프로그래밍을 할 때는 클래스의 정의, 멤버 함수의 정의, 애플리케이션(클래스를 기반으로 객체를 만들어서 사용하는 부분)이 필요함. <br> 
이 부분이 절차 지향과 객체 지향의 차이점임 <br>
물론, 각각의 부분이 다른 것으로 교체될 수 있지만, 전체적인 원리는 변하지 않는다. <br> 

--------------------------
클래스의 정의 -> 속성과 행위 선언 <br>
멤버 함수의 정의 -> 행위 정의 <br>
애플리케이션 -> 객체를 인스턴스화하고 사용 <br> 
---------------------------

클래스의 정의 부분에서는 데이터 멤버와 멤버 함수를 선언하고, <br> 
멤버 함수의 정의 부분에서는 모든 멤버 함수를 정의함.<br> 
애플리케이션 부분에서는 클래스의 인스턴스를 만들고, 멤버 함수를 사용함 

#### 클래스의 정의 

새로운 타입을 만들려면 클래스의 정의(Class definition)를 작성해야함. <br>
클래스 정의는 헤더, 본문, 세미콜론이라는 세부분으로 구성됨 <br> 
클래스 헤더(Class header)는 class라는 키워드 뒤에 클래스의 이름을 붙여서 만듦 <br> 
사용자 정의 자료형은 소문자와 대문자 어떤 것을 사용해도 관계 없음. <br>
하지만, 일반적으로 클래스 이름의 경우는 대문자로 시작하게 만들어 소문자로 시작하는 라이브러리 클래스와 구분하는 것이 좋음. <br>

**클래스 작성 예시**

class Circle { //헤더 

private: <br>
double radius; //데이터 멤버 선언

// 멤버 함수 선언 <br> 
public: <br>
double getRadius() const; <br>
double getArea() const; <br>
double getPerimeter() const; <br>
double setRadius(double value); <br> 
};

+ **데이터 멤버 선언**
  
  클래스의 정의의 첫 번째 부분은 데이터 멤버를 선언하는 부분임 <br>
  데이터 멤버는 내장 자료형으로 만들 수 있고, 이전에 정의한 다른 클래스로도 만들 수 있음.<br>
  클래스의 속성을 구현하는데 사용할 것들을 데이터 멤버로 만듦

  객체는 속성을 여러 개 가질 수 있고, 일부 속성은 다른 속성에 의존하여 계산되는 경우도 있음. <br>
  따라서, 어떤 속성이 단독으로 존재할 수 있는지, 그리고 어떤 속성이 다른 속성에 의존해야하는지를 알아야 함. <br>
  
+ **멤버 함수 선언**
  
  클래스의 행위를 구현하는 데 사용할 함수를 만듦. <br>
  함수 선언(프로토타입)부분과 비슷함. 다만, 함수 끝에 const 한정자가 오는 경우도 있고, 오지 않는 경우도 있음. <br>
  함수 내부에서 어떠한 것도 변경하지 못하게 할 때는 const 한정자를 붙이고, 변경을 허가할 때는 const 한정자를 붙이지 않음. <br>
  
+ **접근 제한자(access modifier)**
  
접근 제한자(access modifier)는 접근 권한을 나타낼 때 사용함. <br>
클래스에서 데이터 멤버와 멤버 함수를 선언하면 기본적으로 private 접근제한자를 가짐.
  private접근 제한자가 붙으면 해당 요소로부터 값을 추출할 수도 없고, 값을 변경할 수 없음. <br>
C++은 값을 접근하기위해, private, protected, public이라는 3가지 접근 제한자를 제공함. <br>

+ private
  private로 선언되어 있다면, 클래내스 내부(멤버 함수를 통해서)에서만 접근할 수 있음. <br>
  즉, 같은 클래스에서만 접근이 가능하며, 서브 클래스와 다른 모든 곳으로부터의 접근은 불가능함 <br>
  
+ public
  public으로 선언되어 있다면, 모든 곳(같은 클래스, 서브 클래스 내부, 애플리케이션)에서 접근 가능.<br>
  즉, 모든 곳에서 접근이 가능하다.

  + protected
    protected는 같은 클래스와 서브 클래스에서의 접근은 가능하지만 모든 곳으로부터의 접근은 불가능함 <br>
    추가적인 내용은 서브클래스를 다루는 11장에서 설명할 예정.

  + 데이터 멤버와 접근 제한자
    
    데이터 멤버에는 일반적으로 private를 적용함 <br>
    기본적으로 private가 붙지만, 강조하기위해서 prrivate을 붙여서 사용함. <br>
    private가 적용된 멤버는 멤버 함수를 통해서만 접근할 수 있음. <br>
    
  + 멤버 함수와 접근 제한자
 
    데이터 멤버에 접근해서 어떤 작업을 하려면, 애플리케이션에서 멤버 함수를 사용할 수 있어야함 <br>
    따라서 일반적으로 멤버 함수는 public을 적용함 <br>
    하지만 클래스 내부(동일한 클래스의 다른 멤버 함수 등)에서만 활용하는 경우에는 멤버 함수의 접근 제한자를 private로 설정하기도 함
    
  + 그룹 함수와 접근 제한자
    접근 제한자는 각각의 것 앞에 붙이는 것이 아니라 **그룹 단위**로 붙임 <br>
    private : 하고 그뒤에 private로 선언할 데이터 멤버를 입력 함 <br>
    public : 똑같음 <br>

    접근 제한자는 다른 접근 제한자를 만나기 전까지 유지됨. <br>

#### 멤버 함수 정의

멤버 함수는 단순하게 함수의 프로토타입을 적은 것으로, 별도의 정의가 필요함. <br>
Example) <br>
doulbe Circle::getRadius() const{

return radius;

}

double Circle::getArea() const {

const double PI = 3.14; <br>
return(PI * radius * radius);

}

기본적인 함수 정의와 비슷하지만 2가지 차이점이 있음. <br>
먼저 멤버 함수에는 한정자(Const)가 있다는 것임. <br>
두 번째는 멤버 함수에는 앞에 클래스 이름이 붙는다는 것임. <br>

데이터 멤버는 클래스 정의 내부에 작성하기 때문에 멤버 함수를 정의할 때에는 클래스 이름을 붙여 함<br>
참고로 클래스 스코프 연산자의 위치와 리턴 자료형의 위치가 헷갈리는 경우가 있는데, 함수의 리턴 자료형이 언제나 앞에 옴<br> 

  #### 인라인 함수

  함수 본문이 너무 짧으면, 함수를 실행하는 시간 (매개변수 저장, 제어 이동, 매개변수 추출, 리턴값  저장 등)이 함수 내부의 코드를 실행하는 시간보다 오래 걸릴 수 있음. <br> 
  프로그램의 성능을 위해서 컴파일러가 함수 호출 부분을 실제 코드로 대체해버리게 만들고 싶을 때는 함수를 인라인 함수로 선언함. <br> 
  물론 컴파일러가 이를 무시할 수도 있으며 인라인 함수는 필요한 곳에 사용할 수 있음. <br>
  최근에는 컴파일러의 성능이 좋기 때문에, 필요한 경우 컴파일러가 인라인 함수로 알아서 구성함. <br>
  반대로 개발자가 인라인 함수로 만들 수 없는 정도의 내용을 인라인 함수로 강제로 만들면, 이를 무시하기도 함. <br>

  + **암묵적 인라인 함수**

  class Circle{

private:

  double radius;

  public:

  double getRadius() const {return radius;}

  ....
  
  }

  위의 코드처럼, 클래스 정의 내부에 함수를 정의하면, 해당 함수는 인라인 함수가 됨. <br>
  하지만 함수 정의 부분을 읽기 어렵고, 캡슐화 원칙을 위반했기 때문에 추천하지 않음. <br>
  클래스 정의 내부에 함수 정의를 넣었으므로, 이 함수의 정의를 외부에 따로 정의할 필요가 없음. <br>
  
  + **명시적 인라인 함수**
  + 
함수 정의 앞에 inline 키워드를 추가하면 함수를 명시적 인라인 함수로 만들 수 있음. <br>
inline double getRadius() const {return radius;}

#### 애플리케이션

클래스 정의와 멤버 함수를 정의 했으므 로, 메인 함수 부분(애플리케이션 부분)에서 이를 인스턴스화 해야 함. <br> 

+ **객체 인스턴스화**
  
  멤버 함수를 사용하려면, 객체를 인스턴스화 해야함. <br>
  Circle circle1; <br>
  위의 코드를 실행하면 circle1이라는 객체가 만들어짐. <br>
  하지만, 객체 내부에 있는 double 자료형의 radius라는 데이터 멤버(변수)를 초기화하지 않았으므로, 이 데이터 멤버에는 쓰레기 값이 들어감. <br>
  따라서 사용하기 전에 데이터 멤버를 초기화 해줘야 함.
  
+ **객체에 연산적용**

  인스턴스화했다면 멤버 함수로 정의 했던 연산을 사용할 수 있게됨.<br>
  circle1.setRadious(10.0);<br>
   cout << "radius : " << circle1.getRadius() <<endl;
  
+ **멤버 선택**
  
  객체 이름과 멤버 함수 사이에 점(.)이 찍혀있는데, 이는 멤버 선택 연산자 (member selection operator)라고 부르는 연산자임. <br>
  circle1.getRadius(); <br>
  circle2.getRadius(); <br>
  
#### 구조체 

구조체의 모든 멤버는 기본적으로 public <br>
반대로 클래스의 모든 멤버는 기본적으로 private <br> 

일부 경우, 멤버 함수를 사용하지 않을 경우, 쉽게 만들고 요소에 접근할 수 있는 구조체를 사용하기도 함 <br>
연결 리스트의 노드 요소처럼 연관 관계를 갖는 데이터가 있을 때 구조체를 사용하기도 함. <br> 

--------------------
### 7.3 생성자와 소멸자. 
