## Ch.20 디자인패턴

정보처리기사 대비용으로 공부하는 단원. 

----------------------------------

  ### 20-1. 개요 
  
  * 객체 지향 프로그래밍 에서 가장 중요한 것은 **재사용**인데, 단순하게 코드 재사용이 아닌 문재를 해결하는 방법이나 패턴 자체도 재사용할 수 있어야 함 <br>
  * 객체 지향의 특징인 **캡슐화, 상속, 추상화, 다형성**과 설계 원칙인 **SOLID** 기반으로 구현됨 <br>
  *  SOLID 원칙은 5가지로 나눌 수 있으며 다음과 같다.
     1. 단일 책임 원칙 (Single Responsibility Principle), (SRP)  : 한 클래스는 하나의 책임만 가져야 한다.
     2. 개방-폐쇄 원칙 (Open-closed Principle), (OCP) : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 즉, 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 해야한다. 
     3. 리스코프 치환 원칙 (Liskov Substitution Principle), (LSP) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다 계약에 의한 설계를 참고하라. 즉, 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야함 -> 상위 타입 객체를 하위 타입객체로 치환해도 정상적으로 동작해야함. 상속 관계에서는 일반화 관계 IS-A가 성립해야 함.  
     4. 인터페이스 분리 원칙 (Interface Segregation Principle), (ISP) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. 즉, 자신이 사용하는 메소드에만 의존해야하며, 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야함 -> 하나의 통상적인 인터페이스보다는 여러 개의 세부적이고 구체적인 인터페이스가 낫다. 
     5. 의존관계 역전 원칙 (Dependency Inversion Principle), (DIP) : 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다. 즉, 의존 관계를 맺을 때, **변하기 쉬운 구체적인 것** 보다는 **변하기 어려운 추상적인 것에** 의존 해야함 
    
  * 디자인 패턴 GoF(Gang of Four) 기준으로 3가지 패턴으로 나눌 수 있음 **생성(Creational Pattern), 구조 (Structural Pattern), 행동 (Behavior Pattern)** 임

  * 디자인 패턴의 장점
    1. 재사용성 : 반복적인 문제에 대한 일반적인 해결책을 제공하여, 유사한 상황에서 코드를 더 쉽게 작성할 수 있음
    2. 가독성 : 일정한 구조로 정리하고, 명확하게 작성하여 개발자가 코드를 이해하고 유지보수하기 쉽게 만듬
    3. 유지보수성 : 코드를 쉽게 모듈화할 수 있으며, 변경이 필요한 경우에 해당 모듈만 수정하여 유지보수가 쉬워짐
    4. 확장성 : 새로운 기능을 추가하거나 변경할 때 디자인 패턴을 사용하면, 기존 코드를 변경하지 않고도 새로운 기능을 통합할 수 있음.
    5. 안정성과 신뢰성 : 검증된 해결책을 제공해줌
    
-----------------------------------

  #### 20-2. 생성 패턴 (Creational Pattern)
   * 전통적인 방법으로, 인스턴스화하면 안되는 상황에서, 어떤 형태로 객체를 인스턴스화해야 하는지에 대한 방법 <br>
   * 객체 지향 프로그래밍은 객체의 설계와 생성을 분리(분할 컴파일)이 목적 <br>
   * 싱글턴, 팩토리 메소드, 빌더, 프로토 타입이 있음

   * **싱글턴 패턴 (Singleton Patton)**
      - **사용자가 클래스의 인스턴스를 하나만 생성도록 강제하는 방법**으로 시스템에서 컨트롤러 또는 관리자 역할을 하는 객체를 만들 때 사용함
      - 클래스의 생성자가 한 번만 호출되게 강제 해야하지만 C++에서는 생성자를 포함한 함수의 호출 횟수를 제한할 수 없다.
      - create함수를 통해 만들 수 있고, create함수가 싱글턴 객체에 포함될 경우, 정적(Static) 함수로 만들어야 함
      - 생성자를 private로 선언하여 사용자가 직접적으로 접근할 수 없도록 만들어야함.

      [20-1. 싱글턴 패턴 예제 코드]()

   * 팩토리 메소드 패턴 (Factory Method Patten)
      - 객체를 생성하는 것은 전통적으로 사용자의 책임이기에, 객체를 만들 때 사용자는 객체와 관련된 세부적인 내용을 알고 있어야 함. 팩토리 메소드 패턴은 사용자의 이러한 점을 쉽게 만들어 주는 패턴
      - **팩토리 메소드 패턴을 사용하면 사용자는 최소의 정보만 제공하면, 적합한 객체를 인스턴스화 할 수 있음**
     
     [20-2. 팩토리 메소드 패턴 예제 코드]()

  * 빌더 패턴 (Builder Pattern)
     - 객체의 생성과 객체의 표현 형태를 분리해서 사용자가 쉽게 사용할 수 있도록 해주는 방법
     - GUI 프로그램에서 복잡한 그래픽 객체를 만들 때 사용 함. 

    [20-3. 빌더 패턴 예제 코드]()
  
  * 프로토타입 패턴 (Prototype Pattern)
    - 사용자가 객체를 많이 만들어야 할 때 사용
    - clone 함수를 사용하면, clone함수 내부에서 복사 생성자를 호출하므로, 별도의 인스터스화와 초기화 없이 객체를 만들어 낼 수 있음.
    - 복제는 원본 대상이 있어야 하므로, 일단 첫 번째 객체는 생성자를 호출해서 만들어야 함.

     [20-4. 프로토 타입 예제 코드]()
    
----------------------------------

  #### 20-3. 구조 패턴 (Structural Pattern)
    * 간단한 객체의 조합으로 복잡한 새로운 객체 구조를 만들어 문제를 해결하는 방법 
    * 적절한 자료형이 없는 상태에서 문제를 해결해야 하는 경우가 있는데, 이러한 경우에는 이미 존재하는 인터페이스와 구현을 결합해서 새로운 자료형을 만들어내 문제를 해결할 수 있음 
    * 구조 패턴은 상속과 구성을 결합해서 사용하는 방법을 정리한 것으로 브리지 패턴, 어댑터 패턴, 퍼사드 패턴, 프록시 패턴, 데코레이터 패턴, 컴포짓 패턴이 있음. 

-----------------------------------

  #### 20-2. 행동 패턴 (Behavior Pattern)
    * 어떤 객체가 혼자 처리할 수 없는 문제를 여러 개의 객체로 분할해서 문제를 해결하는 방법 
