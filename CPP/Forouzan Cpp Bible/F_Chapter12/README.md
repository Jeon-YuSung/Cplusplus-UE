### 12장 다형성

  같은 이름을 갖는 여러 형태의 함수를 클래스별로 만들수 있게 해주는 기능. 

  -----------------------------------
  * #### 12-1 다형성의 요소

* ##### 다형성
  다형성을 구현하려면 포인터(또는 레퍼런스), 플러그 호환 객체, 가상함수가 필요 <br>
  
  플러그 호환 객체 개념알면 좋음 
  
  * 포인터와 레퍼런스
    Pointer & reference가 플러그의 소켓 역할을 함. <br>
    즉, 베이스 클래스를 가리키는 포인터, 레퍼런스를 사용하면 포인터가 베이스 클래스와 파생 클래스 모두를 가리키게 만들 수 있음.
    그리하여 다형성 변수라고도 함 

* 플러그 호환 객체
  
  상속을 하는 객체들이 이런 역할을 함

* 가상 함수
  
  전원 역할을 하는 것 <br>
  vitrual 키워드 사용

  [12-1. 불완전한 다형성 프로그램](https://github.com/ysungJ/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter12/12-1.cpp) <br>
  [12-2. 3가지 재료들을 모두 사용한 다형성 프로그램](https://github.com/ysungJ/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter12/12-2.cpp)

  * virtual 한정자 생략

    부모 클래스의 멤버 함수에만 virtual가 붙어 있으면, 이후의 모든 자식 클래스의 멤버 함수에도 적용되어 virtual 한정자를 생략 가능.
    
  * 매커니즘

    가상 테이블 (virtual table) : 컴퓨터 시스템은 다형성을 목적으로 클래스 계층이 구성될 때 **Virtual table**이라는 것을 만듦.<br>
    가상 테이블에 있는 항목들은 가상 함수에 대한 Pointer를 가짐 <br>

  * 생성자와 소멸자
    
      클래스의 생성자와 소멸자도 멤버 함수로, 가상 함수로 선언되면 어떻게 될까?

    * 1. 가상 생성자 불가 : 생성장도 멤버 함수이지만, 생성자의 이름은 부모 클래스와 자식 클래스가 무조건 달라, 가상 클래스 함수가 될 수 없음 <br>
    * 2. 가상 소멸자 : 소멸자의 이림도 부모 클래스와 자식 클래스가 무조건 다름, 하지만 소멸자는 이름으로 호출하지 않아, 가상 소멸자라는 것이 존재. <br>
     즉, 가상 함수가 있다면, 메모리 누수를 피할 수 있도록 가상 소멸자를 만들어야 함

  흔히 다형성 사용하는 경우와 사용하지 않은 경우로 구분할 수 있는데 이부분은 책을 참고

  [12-3. 다형성 기반으로 사람 클래스에 대한 포인터를 활용한 예제](https://github.com/ysungJ/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter12/Example_Polymorphism) <br>
  12-4 다형성과 배열을 사용하는 예시도 같이 있음. 

  다형성은 다른 객체지향 프로그래밍에서도 사용함. <br>
  하지만 포인터와 레퍼런스, 플러그 호환 객체, 가상함수라는 주제는 나오지 않음 <br>
  위의 3개는 다른 프로그래밍 언어에도 존재하지만, 프로그래머가 따로 인지할 필요 없이 내부적으로 처리되기 때문

  JAVA는 사용자가 Pointer와 Reference를 구분해서 사용하지 않음 : 객체를 변수에 저장하면 무조건 포인터(또는 레퍼런스)로 동작하며, 객체는 무조건 힙에 만들어 지기 때문에 <br>
  또한 pbulic 상속만 지원해서, 상속을 하면 플러그 호환 객체가 작동하고, 모든 멤버 함수는 가상 함수로 만들어지기 때문에, 프로그래머가 따로 인지 하지 않아도 다형성을 만들 수 있음.

  * 바인딩
    
   함수는 함수 호출과 함수 정의로 엔티티를 구분할 수 있음, **바인딩**은 함수호출(print())과 함수 본문 (void print() {})의 연결을 의미함. <br>
  함수는 어디간 정의되고, 또 다른 곳에서 호출됨. 함수에 대한 정의가 하나라면 쉽게 연결을 이해할 수 있음. <br>
함수를 호출하면, 함수정의가 실행됨, 하지만 상속에서 오버라이드하면, 시그니처가 같은 2개 이상의 함수가 만들어질 수 있음. 즉, 함수 호출은 하나이지만 여러개의 정의가 생김 <br>

바인딩은 **정적 바인딩 (static binding)과 동적 바인딩(dynamic binding)** 으로 구분됨.

  * 정적 바인딩 (Static binding)
    
    컴파일 시점 바인딩 (compile-time binding) 또는 조기 바인딩 (early binding)이라고도 함 <br>
    함수에 대한 여러 개의 정의가 있고, 컴파일 시점에 어떤 함수를 호출 해야하는지 명확하게 컴파일러가 이해야하는 경우에 발생.

    ```cpp
    person.print();
    student.print();
    ```

위의 코드 처럼, 컴파일러는 print함수가 누구의 것인지에 대한 것을 명확히 인지하기 때문에 다형성이 필요 없고, 바인딩도 컴파일 시점에 발생함 <br>

  *  동적 바인딩 (Dynamic binding)
    
지연 바인딩(late binding) 또는 런타임 바인딩 (run-time binding)이라고도 함 <br>
런타임 시점에 일어나는 바인딩으로, 컴파일 시점에 객체가 어떤 객체일지 정확하게 모르는 경우 발생 <br>
즉, 프로그램이 실행 중에 어떤 변수에 여러 객체의 포인터가 할당되어, 다형성을 발생시킬 때 일어남.  <br>
컴파일 시점에 어떤 함수를 호출해야하는지 알 수 없으므로, 런타임 시스템이 가상 테이블을 만들어 어떤 함수를 호출해야하는지 관리 함. <br>
다형성은 동적 바인딩과 관련 있음  <br>

* 런타임 타임 정보

  클래스가 계층 구조를 가질 때는 객체가 어떤 객체인지 확인하거나, 객체의 자료형을 변경해야하는 경우가 있는데, 이럴 떄 런타임 타임 정보(Run-Time Type Information)을 사용

* Typeid 연산자

  Runtime일 때, 객체의 자료형을 확인할려면, <typeinfo> 헤더에 있는 type_info 클래스를 사용해야함  <br>
  헤더에는 언더스코어가 없고, 클래스 이름에는 있음  <br>
  type_info class는 생성자, 소멸자, 복사 생성자가 없고, type_info 객체는 typeid 연산자를 호출해서 만듦.  <br>
  typeid는 자료형을 평가할 수 있는 표현식을 피연산자로 사용한다.  <br>
  즉, typeid(5), typeid(object_name), typeid(6+2)등으로 사용 가능.  <br>

```cpp
  t1 == t2 // t1, t2의 자료형이 같으면 true 리턴
  t1 != t2 // 자료형이 다르면 true 리턴
  t1.name() //  t1의 자료형 이림을 C 문자열로 리턴
  t1.before(t2) // t1이 t2와의 상속 관계에서 앞에 있으면 true 리턴
```

  위의 코드에서 t1, t2는 type_info 객체를 의미함.  <br>

  [12.5 typeid 연산자 사용하기](https://github.com/ysungJ/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter12/12-5.cpp)

  * 동적 자료형 변환

    부모 클래스에 대한 포인터에 자식 클래스의 객체를 넣는 것을 업캐스트(Upcast)라고 부름 <br>

```cpp
    Person* ptr1 = new Student;
```

C++는 이를 반대로 하는 **다운캐스트(downcast)**도 가능.  <br>
자식 클래에 대한 포인터에 부모 클래스의 객체를 넣을 수 있음  <br>

```cpp
  Student* ptr2 = dynamic_cast<Student*>(ptr1)
```

위의 코드처럼, 다운 캐스트 사용할려면 dynamic_cast연산자를 사용해야함.  <br>
Student 클래스가 Person의 자식 클래스일 때만 가능하며, 이를 통해 상속 관계를 확인할 수 있음  <br>
다만, 오버헤드가 많이 발생하기 때문에 사용하는 것은 지양함  <br>

----------------------------------------------------
#### 12.2 추상 클래스와 다중 상속 

* ##### 추상 클래스 (Abstract class)
  
   구체 클래스 (Concrete class)는 인스턴스화해서 해당 클래스 자료형의 객체를 만들 수 있는 클래스를 의미. <br>
  is-a 관계를 갖지 않은데, 같은 종류의 함수를 만들어야 하는 경우에는? 즉, 상위 카테고리를 만들어야 하는 상황이면 **추상 클래스(abstract class)** 를 사용함. <br>
  추상 클래스(abstract class)를 사용해 자식 클래스를 설계하는 개발자에게 만들어야 하는 함수를 강제함. <br>
  즉, 추상 클래스는 적어도 하나 이상의 순수 가상 함수를 포함하는 클래스를 의미 <br>

  * 순수 가상 함수

**선언**

  추상 클래스는 하나 이상의 순수 가상 함수를 가져야함, 이때 **순수 가상 함수(pure virtual fucntion)는 선언 시 0을 할당하고, 가상 함수의 정의는 하지 않는다.** <br>
  
  ```cpp
    virtual double getArea() = 0;
    virtual double getPerimeter() = 0;   
  ```

위의 코드는 Shape 클래스에 두 가상 함수를 선언한 예시다.

**정의**

 추상 클래스는 순수 가상 함수를 정의하지 않기에, 추상 클래스를 상속하는 다른 클래스에서 순수 가상 함수를 정의함. 또는 정의하지 않고 다음 상속 단계로 넘어갈 수 있음.
  
  * 인스턴스화 불가 <br>
    순수 가상 함수에 대한 정의가 없어, 클래스를 인스턴스화할 수 없다. <br>
    즉, 클래스를 인스턴스화 하려면 모든 멤버 함수에 대한 정의가 있어야함. <br>
    따라서 추상 클래스를 상속받아 모든 멤버 함수를 정의하고 나서 인스턴스화를 해야함. <br>
    
  * 인터페이스 <br>
    내부적으로 가상함수, 순수 가상 함수 모두 가질 수 있음. <br>
    상황에 따라, **모든 멤버 함수를 순수 가상 함수로 갖는 경우가 가능 이러한 클래스를 인터페이스(interface)라고함.** <br>
    인터페이스는 모든 멤버가 순수 가상 함수로, 구현 파일에 입력할 내용이 없어 구현 파일을 만들지 않는다.
    
  * Shape 클래스 <br>
  
  [12-6. 추상클래스의 Shape 클래스 사용 예시](https://github.com/ysungJ/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter12/Example_Multiple_Shape)

* ##### 다중 상속 (Multiple inheritance)
  다중 상속은 둘 이상의 클래스를 부모 클래스로 자식 클래스를 만드는 상속을 의미 <br>
  즉, 하나의 클래스가 부모 클래스로부터 상속을 받을 수 있게 해주는 기능 <br>

  * 가상 베이스

    중복된 데이터 멤버를 해결하는 방법 중 하나로 가상 베이스 상속(virtual base inheritance)을 사용 <br>
    가상 베이스 상속은 상속할 때, virtual 키워드를 붙이는 방식임. <br>

가상 베이스를 사용면, 자식 클래스에 부모 클래스의 멤버가 직접적으로 들어가지 않음. <br>
그리고 위임을 피해야함. 즉, 공통 데이터 멤버를 protected를 만들어서 모든 자식 클래스에서 접근할 수 있게하고, 위임이 있는 멤버함수는 사용하지 않은 방식임. -> 데이터 멤버를 직접 사용해서 코드를 짜야함. <br>

  [12-7. 다중 상속 예시](https://github.com/ysungJ/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter12/Example_MultiInheritance_TA)

  * 믹스인 클래스 
    
    중복으로 발생하는 문제를 해결하는 또 다른 방법 <br>
    Mixin class는 순수 가상 함수를 가져 인스턴스화할 수 없지만, 다른 클래스에 데이터 멤버를 추가해주는 클래스를 의미함. 
    
    [12-8. Mixin Class를 사용하는 예시](https://github.com/ysungJ/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter12/Example_MixinClass)
  
