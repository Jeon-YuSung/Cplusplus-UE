![image](https://github.com/user-attachments/assets/50d2b9ba-7da6-4ff2-93f6-b513c56ec306)## 13장 연산자 오버라이드

 연산자 오버로드를 알아보는 챕터.
 
### 13-1. 객체의 역할

 사용자 정의 자료형의 객체는 함수 내에서 호스트 객체, 매개변수 객체, 리턴 객체로 사용 될 수 있음. <br>
 함수 설계를 잘하고, 연산자 오버로드 하는 방법을 이해하기 위해 이러한 역할을 잘 파악해야함 <br>
 
 * #### 호스트 객체

   클래스 멤버 함수를 정의 했다면, 인스턴스 앞에 점을 찍고 멤버 함수를 호출 함 <br>
   호스트 객체는 함수 호출의 주체라고 할 수 있음. <br>
   인스턴스 멤버 함수를 만들 때 함수 내부에서 호스트 객체를 지정하지 않는다. 어떤 인스턴스를 호스트 객체로 사용할지 계속 변하기 때문에 <br>
   인스턴스 멤버 함수 내부에서는 호스트 객체로 자기 자신을 가리키려면 **this** 라는 포인터를 사용해야함 <br>
   즉, 함수 내부에서 *this가 곧 호스트 객체 <br>

   * 정리
     호스트 객체는 this 포인터가 가르키는 객체로 *연산자 또는 -> 연산자를 사용해 호스트 객체 또는 호스트 객체의 멤버에 접근할 수 있음 <br>

      * 객체 보호
        명시적으로 멤버 함수가 호스트 객체를 변경하지 못하게 하려면, 멤버 함수 뒤에 **const 한정자**를 써야함 <br>
        
 * #### 매개 변수 객체
     Parameter object는 매개변수로 전달된 객체를 의미 <br>
     명시적으로 활용해야함 <br>

     *전달 방법
    pass by value, pass by reference, pass by pointer로 전달함 <br>
 주로 Pass by reference 사용하는데, 복사 비용이 없고, 단순하게 함수 내부에서 사용할 수 있게 하는 형태임 <br>

    * 객체 보호
      호스트 객체와 똑같이, 변경을 못하게 해야할 때는 **매개변수 앞에 const 한정자**를 붙임. <br>
      
 * #### 리턴 객체

   생성자와 소멸자는 객체를 리턴하지 않고, 객체를 생성하거나 소멸 시키는 역할을 함. <br>
   이외의 다른 멤버 함수는 객체를 리턴할 수 있음 <br>

   * 리턴 방법
     return by value, return by reference, return by pointer 3가지 방법을 사용 <br>

   * 객체보호
     리턴된 객체를 보호해야 하는 경우 (rvalue로만 사용하는 경우) const 한정자를 사용     

----------------------------------------------
### 13-2. 연산자 오버로드

 어떤 연산자를 사용해서 어떤 처리를 할 수 있게 해주는 문법. <br>

 <<는 정수 자료형에 적용하면 정수의 비트를 왼쪽으로 이동하는 (쉬프트 연산)를 하지만, cout 객체에 적용하면 기본 자료형으로 출력 즉, ostream 클래스에 << 연산자를 오버로드 한 것 <br>
 
 * #### 범주
  
 표 13-1 참고 (책 내용)

  참고로, 오버로드할 수 있지만 하지 않은 것이 좋은 연산자가 있음. 이는 연산자의 의미, 평가 순서, 단락 평가(short-circuit)를 사용자가 제대로 구현할 보장이 없기 때문임  <br>
  
  &-주소연산자, &-비트AND연산자, |-비트OR연산자, &&-논리 합 연산자, ||-논리곱 연산자, (.) 삼항-쉼표 연산자
  
 * #### 연산자 오버로드 규칙
   우선 순위 - **변경할 수 없음** 그렇기에 우선 순위가 어떻게 되는지 알면 좋음 <br>
   결합 방향 - **변경할 수 없음** 대부분은 왼쪽에서 오른쪽이지만, 일부 연산자는 오른쪽에서 왼쪽임 <br>
   교환 법칙 - **변경 X** 쉽게 +와 -를 생각하면 됨 <br>
   애러티 - **애러티 (피연산자의 개수)도 변경 X** <br>
   다른 연산자 사용 불가능 - 오버로드 가능한 연산자만 오버로드 가능, 사용자가 연산자를 추가할 수 없음<br>
   연산자 결합 불가능 - 새로운 연산자를 만들겠다고, 기존의 연산자 2개를 결합하는 것도 불가능함 <br>
   
 * #### 연산자 함수

 사용자 정의 자료형에 연산자 오버로드 하려면 연산자 함수(Operator function)를 만들어야함. <br>
 연산자 함수는 함수의 이름이 **'operator 키워드 뒤에 연산자를 붙인 형태'** 를 갖는 함수 <br>

    * 멤버 함수 연산자 오버로드와 비멤버 함수 연산자 오버로드 

    연산자 함수는 멤버 함수로 정의할 수 도 있고, 멤벟 함수가 아닌 일반 함수(비멤버 함수)로도 정의 할수 있음, 일부 연산자는 멤버 함수로만 오버로드 해야함. <br>
    서로 문법이 다르기 때문 <br>

    * 비멤버 함수로 연산자 오버로드 

    연산자 오버로드를 하면 연산자 또는 함수 이름을 호출 할 수 있음 <br>
    연산자 오버로드의 목적은 사용자 정의 객체를 기본 자료형처럼 모방해서 사용하는 것에 있음. <br>

    ```cpp
    -fr //연산자
    fr.operator-() //함수
    ```

    위의예시는 Fraction 클래스에 단항 음수 연산자 (-)를 오버로드 했다면, 2가지 형태로 함수를 호출할 수 있다는 예시이다.
 
------------------------------------------------

### 13-3. 멤버 함수로 오버로드 

 * #### 단항 연산자
 * #### 이항 연산자
 * #### 이외

-----------------------------------------------

### 13-4. 비멤버 함수로 오버로드
 
 * #### 이항 수학 연산자
 * #### 일치, 관계 연산자
 * #### 추출, 삽입 연산자

 -------------------------------------------------
### 13-5. 자료형 변환 

* #### 기본자료형 -> 클래스 자료형 변환
* #### 클래스 자료형 -> 기본 자료형


