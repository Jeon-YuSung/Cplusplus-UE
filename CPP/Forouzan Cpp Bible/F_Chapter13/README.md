## 13장 연산자 오버라이드

 연산자 오버로드를 알아보는 챕터.
 
### 13-1. 객체의 역할

 사용자 정의 자료형의 객체는 함수 내에서 호스트 객체, 매개변수 객체, 리턴 객체로 사용 될 수 있음. <br>
 함수 설계를 잘하고, 연산자 오버로드 하는 방법을 이해하기 위해 이러한 역할을 잘 파악해야함 <br>
 
 * #### 호스트 객체

   클래스 멤버 함수를 정의 했다면, 인스턴스 앞에 점을 찍고 멤버 함수를 호출 함 <br>
   호스트 객체는 함수 호출의 주체라고 할 수 있음. <br>
   인스턴스 멤버 함수를 만들 때 함수 내부에서 호스트 객체를 지정하지 않는다. 어떤 인스턴스를 호스트 객체로 사용할지 계속 변하기 때문에 <br>
   인스턴스 멤버 함수 내부에서는 호스트 객체로 자기 자신을 가리키려면 **this** 라는 포인터를 사용해야함 <br>
   즉, 함수 내부에서 *this가 곧 호스트 객체 <br>

   * 정리
     호스트 객체는 this 포인터가 가르키는 객체로 *연산자 또는 -> 연산자를 사용해 호스트 객체 또는 호스트 객체의 멤버에 접근할 수 있음 <br>

      * 객체 보호
        명시적으로 멤버 함수가 호스트 객체를 변경하지 못하게 하려면, 멤버 함수 뒤에 **const 한정자**를 써야함 <br>
        
 * #### 매개 변수 객체
     Parameter object는 매개변수로 전달된 객체를 의미 <br>
     명시적으로 활용해야함 <br>

     * 전달 방법
    pass by value, pass by reference, pass by pointer로 전달함 <br>
 주로 Pass by reference 사용하는데, 복사 비용이 없고, 단순하게 함수 내부에서 사용할 수 있게 하는 형태임 <br>

    * 객체 보호
      호스트 객체와 똑같이, 변경을 못하게 해야할 때는 **매개변수 앞에 const 한정자**를 붙임. <br>
      
 * #### 리턴 객체

   생성자와 소멸자는 객체를 리턴하지 않고, 객체를 생성하거나 소멸 시키는 역할을 함. <br>
   이외의 다른 멤버 함수는 객체를 리턴할 수 있음 <br>

   * 리턴 방법
     return by value, return by reference, return by pointer 3가지 방법을 사용 <br>

   * 객체보호
     리턴된 객체를 보호해야 하는 경우 (rvalue로만 사용하는 경우) const 한정자를 사용     

----------------------------------------------
### 13-2. 연산자 오버로드

 어떤 연산자를 사용해서 어떤 처리를 할 수 있게 해주는 문법. <br>

 <<는 정수 자료형에 적용하면 정수의 비트를 왼쪽으로 이동하는 (쉬프트 연산)를 하지만, cout 객체에 적용하면 기본 자료형으로 출력 즉, ostream 클래스에 << 연산자를 오버로드 한 것 <br>
 
 * #### 범주
  
 표 13-1 참고 (책 내용)

  참고로, 오버로드할 수 있지만 하지 않은 것이 좋은 연산자가 있음. 이는 연산자의 의미, 평가 순서, 단락 평가(short-circuit)를 사용자가 제대로 구현할 보장이 없기 때문임  <br>
  
  &-주소연산자, &-비트AND연산자, |-비트OR연산자, &&-논리 합 연산자, ||-논리곱 연산자, (.) 삼항-쉼표 연산자
  
 * #### 연산자 오버로드 규칙
   1. 우선 순위 - **변경할 수 없음** 그렇기에 우선 순위가 어떻게 되는지 알면 좋음 <br>
   2. 결합 방향 - **변경할 수 없음** 대부분은 왼쪽에서 오른쪽이지만, 일부 연산자는 오른쪽에서 왼쪽임 <br>
   3. 교환 법칙 - **변경 X** 쉽게 +와 -를 생각하면 됨 <br>
   4. 애러티 - **애러티 (피연산자의 개수)도 변경 X** <br>
   5. 다른 연산자 사용 불가능 - 오버로드 가능한 연산자만 오버로드 가능, 사용자가 연산자를 추가할 수 없음<br>
   6. 연산자 결합 불가능 - 새로운 연산자를 만들겠다고, 기존의 연산자 2개를 결합하는 것도 불가능함 <br>
   
 * #### 연산자 함수

 사용자 정의 자료형에 연산자 오버로드 하려면 연산자 함수(Operator function)를 만들어야함. <br>
 연산자 함수는 함수의 이름이 **operator 키워드 뒤에 연산자를 붙인 형태** 를 갖는 함수 <br>

   * 멤버 함수 연산자 오버로드와 비멤버 함수 연산자 오버로드 

   연산자 함수는 멤버 함수로 정의할 수 도 있고, 멤버 함수가 아닌 일반 함수(비멤버 함수)로도 정의 할수 있음, 일부 연산자는 멤버 함수로만 오버로드 해야함. <br>
   서로 문법이 다르기 때문 

   * 비멤버 함수로 연산자 오버로드 

연산자 오버로드를 하면 연산자 또는 함수 이름을 호출 할 수 있음 <br>
연산자 오버로드의 목적은 사용자 정의 객체를 기본 자료형처럼 모방해서 사용하는 것에 있음.

 ```cpp
  -fr //연산자
  fr.operator-() //함수
 ```

위의 예시는 Fraction 클래스에 단항 음수 연산자 (-)를 오버로드 했다면, 2가지 형태로 함수를 호출할 수 있다는 예시이다.
 
------------------------------------------------

### 13-3. 멤버 함수로 오버로드 

  어떤 연산자는 멤버 함수로 오버로드, 어떤 함수는 비멤버 함수로 오버로드 하는것이 적합 함. <br>
  
 * #### 단항 연산자

    호스트 객체가 곧 피연산자, 따라서 매개변수 객체가 추가로 필요하지 않음. <br>
   호스트 객체를 변경해야하는가? 하면 안되는가? const 한정자 확인 <br>
   리턴 객체는 연산 결과 의미를 return by reference할수 있는가? const 한정자 붙여야 하는가?로 리턴 객체 확인 <br>
   
 * #### 이항 연산자

  피연산자 2개를 가짐, 멤버 함수로 오버로드할 때 피연산자 하나를 호스트 객체로, 다른 피연산자를 매개변수 객체로 사용 <br> 
  일반적으로 왼쪽 피연산자와 오른쪽 피연산자의 역할이 다른 연산자만 멤버 함수로 오버로드. 
 
 * #### 이외

 간접 연산자(*)와 멤버 선택 연산자(->)를 활용해서 스택 또는 힙 메모리에 저장된 객체와 객체의 멤버에 접근. <br>
 피연산자가 하나인 단항 연산자임 <br>

  * 스마트 포인터
   
   스택에서 객체에 대한 포인터를 사용하는 경우, 간접 연산자와 멤버 선택 연산자를 오버로드하지 않아도 됨. <br>
   포인터로 객체를 가리킬 수 있기 때문에, 또한 객체가 스택에 생성되면 스코프에서 벗어날 때 소멸되어 스택에서 해체되기 때문에 메모리 누수가 발생하지 않지만, 
   힙에서 생성하는 경우 메모리 누수를 방지 하기 위해서 객체를 제거해야함. <br>
   스마트 포인터는 원하는 자료형을 가리킬 수 있는 포인터를 데이터 멤버로 갖는 객체 <br> 

   [13-1. Smart Pointer를 사용하는 프로그램 예제](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter13/13-1)
   
   참고로 스마트 포인터를 사용하지 않고도, 힙에 객체를 만들 수 있음.
   
   ```cpp
    Fraction *ptr = new Fraction(2,5);
    (*ptr).print();
    ptr->print();
   ```

하지만 이렇게 만들면 객체는 자동으로 소멸하지 않기 때문에 메모리 누수를 피하기 위해서 소멸를 작업해야 함. <br>
반면 스마트 포인터를 사용할 경우 자동으로 소멸됨. <br>

 * 첨자 연산자

 첨자 연산자([])는 연산자의 의미를 변경하지 않는 것이 좋음. <br>

 [13-2 배열을 이용한 첨자연산자 프로그램 예제](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter13/13-2)

  * 함수 호출 연산자 (Function call operator)

    이름(매개변수_목록)

    함수처럼 호출할 수 있는 객체를 만들 수 있음. 함수처럼 호출할 수 있는 객체를 함수 객체 or functor라고 부름 <br>
    함수 객체와 함수의 차이는 함수 객체는 상태를 계속해서 유지할 수 있고, 반면에 함수는 호출되면 상태가 사라짐.

    [13-3. 함수호출자 예제 프로그램](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter13/13-3)

    함수 객체는 함수 호출의 매개 변수 수를 제한하지 않음. <br>
    그러므로 하나 이상의 매개변수로 함수 호출 연산자를 오버로드 할 수 있음. <br>
    
-----------------------------------------------

### 13-4. 비멤버 함수로 오버로드

   이항 연산자를 멤버 함수로 오버로드한다면, 피연산자 중에 하나가 반드시 호스트 객체여야함 <br>
   일반 함수로 오버로드 하는 것이 좋음, 전역함수 friend 함수로 구현할 수 있음 <br>
   
 * #### 이항 수학 연산자
 * #### 일치, 관계 연산자
 * #### 추출, 삽입 연산자

 위의 내용은 책 참고 

 -------------------------------------------------
### 13-5. 자료형 변환 

 일부 제한 사항이 있지만, 연산자 사용 때, 기본 자료형을 사용자 정의 자료형으로 변환하거나, 사용자 정의 자료형을 기본 자료형으로 변환하게 만들 수 있음.  <br>
 
* #### 기본자료형 -> 클래스 자료형 변환
 
 정수, 부동 소수점 등을 클래스로 변환 가능

* #### 클래스 자료형 -> 기본 자료형

operator double처럼 operator 키워드 뒤에 자료형을 붙이는 형태로 변환 가능 

