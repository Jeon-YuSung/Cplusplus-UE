## Ch-14. 예외 처리 
   
   고전적인 오류 처리하는 방법과 try-catch, thorw를 사용하는법, 생성자-소멸자에서 발생하는 예외 처리에 대해 학습

  ------------------------------------------------

  * ### 14-1. 개요
    
     * 고전적인 오류처리 방법

       구문 오류가 없으면 프로그램은 컴파일 되어 실행됨, 하지만 실행 중에 오류가 발생할 수 있음. 이경우 프로그램은 중단 됨. <br>

       1. [런타임 때 프로그램을 중단](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-1.cpp)
       2. [런타임 때 프로그램 중단 요청](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-2.cpp)
       3. [오류 확인 사용](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-3.cpp)
       4. [오류 확인에 함수 리턴 사용](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-4.cpp)

          고전적인 오류 처리 방법에는 몇가지 문제가 있음 <br>
          1. 어떠한 경고도 없이 프로그램이 중단됨 (14-1)
          2. 프로그램이 중단되는 것은 똑같지만 사용자에게 경고를 줌 (14-2)
          3. 프로그램을 중단시킬 가능성이 있는 처리는 무시, 나머지는 계속 실행 가능, 다만 오류를 처리하는 코드가 기본 코드와 결합 되어 있어서 가독성이 떨어짐 (14-3)
          4. 고전적인 처리 방법 중 가장 좋은 방법이지만 모든 상황에 사용할 수 있는 형태가 아님. **구조적 프로그래밍 원칙(Structural Programming Principle)에 따르면 함수의 리턴 값은 하나의 목적만 가져야 함** 하지만 리턴이 오류를 발견하는 목적과, 계산을 처리하는 목적으로 2가지라 원칙에 위배됨 (14-4)
             
  * C++의 예외 처리 방법
    
    C++에서 고전적인 문제를 해결하고자, **예외 처리 방법(Exception Handing Approach)을 제공**
    런타임 때, 예외가 발생해도 프로그램이 이를 처리하여 중단되지 않게 만들 수 있음 <br>

    * Try-catch 블록
      
      C++에서 사용하는 예외 처리 방법으로 try절에는 프로그램을 중단시킬 가능성이 있는 코드를 넣어서 예외가 발생하면 프로그램이 중단되는게 아니라 catch로 절로가서 코드를 계속 진행 시킴 <br>

```cpp
try{
//예외를 발생시킬 수 있는 코드
}catch(자료형 변수){
//예외를 처리하는 코드
}
```

   즉, try 절에서 유로가 발생하면 예외를 발생(throw)시키고 catch절에서는 예외가 발생했을 경우 프로그램이 중단되는 것을 막는 처리를 함. 

   [14-5. try-catch 사용하는 예제](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-5.cpp) <br>
   [14-6. 함수 내부에서 발생한 예외 처리하는 프로그램](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-6.cpp)

   참고로 thorw 구문은 직접적이든, 간접적으로든 try 구문에 있어야한다.  위의 예시 코드를 통해 thorw 위치를 알 수 있다. <br>
   throw 구문이 사용되지 않은 경우가 있는데, 이는 블록 내부에서 호출하는 미리 정의된 함수 또는 라이브러리 함수 내부에 thorw 구문이 포함되어 있는 경우임 <br>
   또한 catch는 여러개를  사용할 수 있음 <br> 

```
   try {
      // 코드 내용 
} catch(int x) { //특정한 자료형의 예외 처리
      // 코드 내용
} catch(...) { //점 3개 입력시, 모든 자료형의 예외를 처리
       //코드 내용     
}
```

   * 예외 전파와 예외 전달
     
      함수 내부에서 예외가 발생한다고, 꼭 같은 함수 내부에서 예외를 처리할 필요는 없음. **어떤 함수 내부에서 예외가 발생하고 처리되지 않았다면 함수 호출 계층 구조를 타고 예외가 전파됨. 예외를 처리할 수 있는 마지막 함수는 main 함수로,** main에서도 예외를 처리하지 않으면 프로그램 전체가 중단 됨. 이러한 과정을 예외 전파(Exception Propagation)이라고도 함 <br>
      catch 절에서 예외를 완전하게 처리할 수 없거나, 처리하고 싶지 않은 경우에는 한 단계 위의 함수로 예외를 전달하면 된다. 예외에 대한 처리를 위해서는 예외를 발생시켜야 하는데, 네트워크나 파일 처리 등에서 필요한 경우에 사용한다. 
      예외를 그대로 다시 발생 시키고 싶다면 catch 절 내부에 thorw만 사용하면 추가적인 피연산자를 지정하지 않아도, 같은 예외가 발생 <br>

```cpp
try {
...// 내용 
} catch(자료형 변수){
 ... // 코드 내용 
throw; //호출한 함수쪽으로 예외 전파.
}
```

  * 예외 사양
    
    함수 시그니처만으로 함수 내부에서 어떤 예외가 발생하는지 알 수 있는 방법이 **예외 사양(Exception Specificaiton)** 이라고 함<br>
    모든 예외 발생 가능, 특정 예외 발생 가능, 예외 없음 -> 3가지로 구분 가능
    
       * 모든 예외 발생 가능
         
         예외 사양이 없는 함수는 모든 예외가 발생(thorw)할 수 있다는 의미로 어떤 예외가 발생하는지 알려면 함수 본문을 봐야함.

       * 특정 예외 발생 가능

         함수의 설계자와 사용자가 다르다면, 함수 내부에서 어떤 예외가 발생할지 명시적으로 알려주는 것이 좋음. <br> 
         int quotient(int first, int second) thorw (int);

       *  예외 없음. 

         예외를 전혀 발생시키지 않는다고 명시적으로 알려주는 경우가 있는데, 이러한 경우 try-cathc를 사용할 필요가 없음. <br>
         이를 명시할 때, 함수의 헤더에 throw 키워드를 사용한다 <br>
         int print(int f, int s) thorw();
    
  * 스택 해제(stack unwinding)

      메모리와 관련이 있는 예외 처리에서 중요한 개념

       * 프로그램 메모리의 구분
         
         1. 코드 메모리 (프로그램 메모리) : 프로그램의 명령어가 올라가는 영역 
         2. 정적 메모리 : 정적 변수와 전역 변수의 값을 저장하는 영역, 지역 변수는 다른 위치에 올라감
         3. 스택 메모리 : LIFO의 특징을 갖는 메모리, 함수와 관련된 매개변수, 지역변수, 리턴 주소를 추적하는 역할을 함
         4. 힙 메모리 : 함수의 수명보다 오래 유지되어야 하는 정보를 저장하기 위한 영역임

       * 스택 메모리의 삽입과 삭제

          예외 처리는 스택 메모리의 동작 기반으로 이루어짐. 모든 프로그램은 함수를 호출할 때 매개변수, 지역 변수, 리턴 주소등의 정보가 스택에 삽입되고, 이때 리턴 주소는 함수가 정상적으로 또는 비정상적으로 종료(예외 발생)되었을 때 사용됨

       * 스택 해제의 적용

         함수의 관련된 정보가 꺼내지면서 매개변수와 지역 변수가 모두 사라진다 는 것인데, 만약 매개변수 또는 지역 변수가 클래스의 인스턴스라면, 소멸자를 호출해서 소멸시켜야함.
         객체를 지역 변수로 스택에 선언 했으면, 함수가 종료될 때 관련된 정보가 모두 제거되므로 큰 문제가 없음 하지만 **힙에 선언 했다면, 객체가 소멸되지 않아 메모리 누수가 발생할 수 있음**
          
  ----------------------------------------------------
  * ### 14-2. 클래스와 예외 처리
  * 생성자 내부의 예외 처리
  * 소멸자에서의 예외 처리

------------------------------------------------------
  * ### 14-3. 표준 예외 클래스
  * 논리 오류
  * 런타임 오류
  * 이외
  * 표준 예외 클래스의 사용
    
