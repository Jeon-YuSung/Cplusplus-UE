## Ch-14. 예외 처리 
   
   고전적인 오류 처리하는 방법과 try-catch, thorw를 사용하는법, 생성자-소멸자에서 발생하는 예외 처리에 대해 학습

  ------------------------------------------------

  * ### 14-1. 개요
    
     * 고전적인 오류처리 방법

       구문 오류가 없으면 프로그램은 컴파일 되어 실행됨, 하지만 실행 중에 오류가 발생할 수 있음. 이경우 프로그램은 중단 됨. <br>

       1. [런타임 때 프로그램을 중단](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-1.cpp)
       2. [런타임 때 프로그램 중단 요청](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-2.cpp)
       3. [오류 확인 사용](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-3.cpp)
       4. [오류 확인에 함수 리턴 사용](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-4.cpp)

          고전적인 오류 처리 방법에는 몇가지 문제가 있음 <br>
          1. 어떠한 경고도 없이 프로그램이 중단됨 (14-1)
          2. 프로그램이 중단되는 것은 똑같지만 사용자에게 경고를 줌 (14-2)
          3. 프로그램을 중단시킬 가능성이 있는 처리는 무시, 나머지는 계속 실행 가능, 다만 오류를 처리하는 코드가 기본 코드와 결합 되어 있어서 가독성이 떨어짐 (14-3)
          4. 고전적인 처리 방법 중 가장 좋은 방법이지만 모든 상황에 사용할 수 있는 형태가 아님. **구조적 프로그래밍 원칙(Structural Programming Principle)에 따르면 함수의 리턴 값은 하나의 목적만 가져야 함** 하지만 리턴이 오류를 발견하는 목적과, 계산을 처리하는 목적으로 2가지라 원칙에 위배됨 (14-4)
             
  * C++의 예외 처리 방법
    
    C++에서 고전적인 문제를 해결하고자, **예외 처리 방법(Exception Handing Approach)을 제공**
    런타임 때, 예외가 발생해도 프로그램이 이를 처리하여 중단되지 않게 만들 수 있음 <br>

    * Try-catch 블록
      
      C++에서 사용하는 예외 처리 방법으로 try절에는 프로그램을 중단시킬 가능성이 있는 코드를 넣어서 예외가 발생하면 프로그램이 중단되는게 아니라 catch로 절로가서 코드를 계속 진행 시킴 <br>

```cpp
try{
//예외를 발생시킬 수 있는 코드
}catch(자료형 변수){
//예외를 처리하는 코드
}
```

   즉, try 절에서 유로가 발생하면 예외를 발생(throw)시키고 catch절에서는 예외가 발생했을 경우 프로그램이 중단되는 것을 막는 처리를 함. 

   [14-5. try-catch 사용하는 예제](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-5.cpp) <br>
   [14-6. 함수 내부에서 발생한 예외 처리하는 프로그램](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-6.cpp)

   참고로 thorw 구문은 직접적이든, 간접적으로든 try 구문에 있어야한다.  위의 예시 코드를 통해 thorw 위치를 알 수 있다. <br>
   throw 구문이 사용되지 않은 경우가 있는데, 이는 블록 내부에서 호출하는 미리 정의된 함수 또는 라이브러리 함수 내부에 thorw 구문이 포함되어 있는 경우임 <br>
   또한 catch는 여러개를  사용할 수 있음 <br> 

```
   try {
      // 코드 내용 
} catch(int x) { //특정한 자료형의 예외 처리
      // 코드 내용
} catch(...) { //점 3개 입력시, 모든 자료형의 예외를 처리
       //코드 내용     
}
```

   * 예외 전파와 예외 전달
     
      함수 내부에서 예외가 발생한다고, 꼭 같은 함수 내부에서 예외를 처리할 필요는 없음. **어떤 함수 내부에서 예외가 발생하고 처리되지 않았다면 함수 호출 계층 구조를 타고 예외가 전파됨. 예외를 처리할 수 있는 마지막 함수는 main 함수로,** main에서도 예외를 처리하지 않으면 프로그램 전체가 중단 됨. 이러한 과정을 예외 전파(Exception Propagation)이라고도 함 <br>
      catch 절에서 예외를 완전하게 처리할 수 없거나, 처리하고 싶지 않은 경우에는 한 단계 위의 함수로 예외를 전달하면 된다. 예외에 대한 처리를 위해서는 예외를 발생시켜야 하는데, 네트워크나 파일 처리 등에서 필요한 경우에 사용한다. 
      예외를 그대로 다시 발생 시키고 싶다면 catch 절 내부에 thorw만 사용하면 추가적인 피연산자를 지정하지 않아도, 같은 예외가 발생 <br>

```cpp
try {
...// 내용 
} catch(자료형 변수){
 ... // 코드 내용 
throw; //호출한 함수쪽으로 예외 전파.
}
```

  * 예외 사양
    
    함수 시그니처만으로 함수 내부에서 어떤 예외가 발생하는지 알 수 있는 방법이 **예외 사양(Exception Specificaiton)** 이라고 함<br>
    모든 예외 발생 가능, 특정 예외 발생 가능, 예외 없음 -> 3가지로 구분 가능
    
       * 모든 예외 발생 가능
         
         예외 사양이 없는 함수는 모든 예외가 발생(thorw)할 수 있다는 의미로 어떤 예외가 발생하는지 알려면 함수 본문을 봐야함.

       * 특정 예외 발생 가능

         함수의 설계자와 사용자가 다르다면, 함수 내부에서 어떤 예외가 발생할지 명시적으로 알려주는 것이 좋음. <br> 
         int quotient(int first, int second) thorw (int);

       *  예외 없음

          예외를 전혀 발생시키지 않는다고 명시적으로 알려주는 경우가 있는데, 이러한 경우 try-catch를 사용할 필요가 없음. <br>
          이를 명시할 때, 함수의 헤더에 throw 키워드를 사용한다 <br>
          int print(int f, int s) thorw();
    
  * 스택 해제(stack unwinding)

      메모리와 관련이 있는 예외 처리에서 중요한 개념

       * 프로그램 메모리의 구분
         
         1. 코드 메모리 (프로그램 메모리) : 프로그램의 명령어가 올라가는 영역 
         2. 정적 메모리 : 정적 변수와 전역 변수의 값을 저장하는 영역, 지역 변수는 다른 위치에 올라감
         3. 스택 메모리 : LIFO의 특징을 갖는 메모리, 함수와 관련된 매개변수, 지역변수, 리턴 주소를 추적하는 역할을 함
         4. 힙 메모리 : 함수의 수명보다 오래 유지되어야 하는 정보를 저장하기 위한 영역임

       * 스택 메모리의 삽입과 삭제

          예외 처리는 스택 메모리의 동작 기반으로 이루어짐. 모든 프로그램은 함수를 호출할 때 매개변수, 지역 변수, 리턴 주소등의 정보가 스택에 삽입되고, 이때 리턴 주소는 함수가 정상적으로 또는 비정상적으로 종료(예외 발생)되었을 때 사용됨

       * 스택 해제의 적용

         함수의 관련된 정보가 꺼내지면서 매개변수와 지역 변수가 모두 사라진다 는 것인데, 만약 매개변수 또는 지역 변수가 클래스의 인스턴스라면, 소멸자를 호출해서 소멸시켜야함.
         객체를 지역 변수로 스택에 선언 했으면, 함수가 종료될 때 관련된 정보가 모두 제거되므로 큰 문제가 없음 하지만 **힙에 선언 했다면, 객체가 소멸되지 않아 메모리 누수가 발생할 수 있음**
          
  ----------------------------------------------------
  * ### 14-2. 클래스와 예외 처리

    클래스에 정의되어 있는 모든 함수에서 예외가 발생할 수 있음 <br> 
    일반 멤버 함수에서의 예외 처리는 독립적인 함수의 예외 처리와 같지만, 생성자와 소멸자에서 발생하는 예외 처리는 다름.  
    
  * 생성자 내부의 예외 처리

    생성자도 멤버 함수이지만, 객체를 만들고 초기화하는 목적으로 설계 됨 <br>
    생성자에서 예외가 발생하는 되는 경우를 스택 메모리에서 생성되는 경우와 힙 메모리에서 생성되는 경우로 구분할 수 있음 <br>
   
      * 스택에 객체를 생성 하는 경우

         하나의 정수를 저장하는 Integer class가 있다고 가정해보자, 이 클래스처럼 다른 자료형을 감싸는 클래스를 **랩퍼 클래스(Wrapper class)** 라고하며 많이 사용하는 클래스의 형태 <br>
         이를 바탕으로 예외가 발생하지 않은 경우와 발생하는 경우로 구분 할 수 있음 <br>
         
           * 생성자 내부에서 예외가 발생 하지 않은 경우 (스택 메모리)

             객체를 스택 메모리에 만든다면, 생성자가 호출될 때 스택의 가장 위에 객체가 삽입되고 소멸자가 종료될 때 스택에서 삭제 됨 <br>
             생성자 내부의 코드가 실행되기 전에 객체를 위한 영역이 스택에 삽입되고, 생성자 내부의 코드가 실행되면서 영역을 채움 그리고 소멸자가 실행되면 스택에서 객체가 삭제되어 완전히 사라짐 <br>
             
           * 생성자 내부에서 예외가 발생 하는 경우 (스택 메모리)
       
             C++에서 생성자가 생성 작업을 하지 못하는 경우 소멸자를 호출하지 않음.
             생성자 내부에서 예외가 발생하면 프로그램이 중단되고 스택에 할당된 모든 메모리가 해제됨.  <br>

      * 힙에 객체를 일부 생성한 경우
   
        힙도 스택 메모리와 똑같이 내부에서 예외가 발생하지 않은 경우와 발생한 경우로 구분 가능<br>

           * 생성자 내부에서 예외가 발생하지 않은 경우 (힙 메모리) - 책 822쪽 참고 
           
           * 생성자 내부에서 예외가 발생한 경우 (힙 메모리) 
   
              힙에 메모리 영역을 할당하고 생성자 본문에서 예외가 발생하는 경우인데, 생성자에서 예외가 발생한 순간 생성자를 벗어남. 객체가 완전히 만들어진 상태가 아니므로 소멸자가 호출되지 않음 <br>
             스택 해제 중에 객체가 삭제되기는 하지만 소멸자가 호출되지 않으므로 힙에 할당된 영역이 해제되지 않아 메모리 누수가 발생 됨 <br>
             생성자에서 메모리를 할당했는데 예외가 발생해서 처리를 끝까지 하지 않으면, 소멸자가 호출되지 않아 메모리 해제를 하지 못함 <br>
             이럴 때, 할당과 해제를 하나의 작업으로 결합하면 해결할 수 있음 <br>
             
           * 스마트 포인터를 활용해 메모리 관리
              메모리 할당과 해제에 원시 포인터 (raw pointer)가 아니라 스마트 포인터(smart pointer)를 사용하면 생성자가 호출될 때 메모리를 할당하고, 소멸자가 호출될 때 메모리를 해제함 스마트 포인터의 생성자에는 별도의 처리가 없기에 내부적으로 문제가 발생하지 않고 소멸자도 항상 호출 됨. <br>
           
           * Function-try 블록
             생성자 내부에서도 try-catch 블록을 사용해서 예외처리가 가능 함. 하지만 초기화 리스트에서 예외가 발생한다면 try-catch블록을 결합한 형태의 function-try 블록을 사용해야함 <br>
             Function-try은 모든 함수에서 사용할 수 있고 함수 뒤에 곧바로 try catch 블록을 붙여서 사용하는 형태임. 하지만 일반적인 함수는 내부에 try-catch블록을 넣기 때문에 거의 사용하지 않고 클래스 또는 구조체의 생성자와만 조합해서 사용하는 편이지만 많이 사용하지 않음 <br>

```cpp
void test() try{
   throw "예외 발생"; // 함수 본문
} catch(...){
cout << "예외가 발생 했습니다 \n; // 함수 본문에서 예외가 발생하는 경우
}

int main(void){
   test();
   return 0;
}
```

[14-7. Intger 클래스를 사용한 예제 프로그램](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-7)

  * 소멸자에서의 예외 처리

       스택에서 어떤 객체가 사라질 때 **소멸자가 호출 됨, 이때 예외가 발생하면** 스택에서 메모리가 제거되는데 문제가 발생하여 **terminator라는 프로그램 전체를 종료하는 전역 함수**를 호출 함 <br>

------------------------------------------------------
  * ### 14-3. 표준 예외 클래스

      표준 예외 클래스라고 부르는 클래스들이 존재함 exception class에서 파생된 모든 클래시를 예외 클래스라고 부름 <br>
    exception 클래스에 정의된 모든 멤버 함수에는 예외 사양이 존재, 단순하게 괄호()로 되어있어, 어떠한 예외도 발생하지 않는다는 의미임. <br>
    what 멤버 함수는 예외와 관련된 설명을 나타내는 C 문자열을 리턴하는 가상 함수. 즉, 자식 클래스에서 이를 구현해서 제공 해줌. <br>
    
  * 논리 오류
    logic_error라는 클래스가 있음. 논리 오류와 관련된 4개의 클래스의 부모 클래스임 <br>

```cpp
   explicit logic_error(const string& whatArg) //생성자
   virtual const char* what() const throw() //멤버 함수   
```

logic_error 클래스에서 domain_error, out_of_range, length_error, invalid_argument라는 클래스가 파 됨 <br> 
이러한 자식 클래스의 모든 생성자 함수는 logic_error 클래스와 이름만 다르지 같은 매개변수를 받으며 what 멤버 함수를 사용할 수 있음 <br>
  
  1. domain_error : 데이터가 도메인(영역)에서 벗어난 경우에 발생, 즉 도메인을 벗어나는 값이 전달될 때 발생
  2. out_of_range : 라이브러리 클래스에서 인덱스를 넘는 어떤 처리를 할 때 발생
  3. length_error : 객체의 길이가 필요한 길이와 다른 경우에 발생
  4. invalid_argument : 어떤 논리적 오류가 있지만, 위의 3가지 예외에 속하지 않은 경우 사용할 수있는 범용적인 예외
     
  * 런타임 오류

       runtime_error라는 클래스는 일반적으로 오버플로우, 언더플로우등 결과가 범위를 벗어나는 경우에 활용함 <br>
       stdexcept 헤더 파일을 읽어서 사용할 수 있음

```cpp
   explicit runtime_error(const string& whatArg) //생성자
   virtual const char* what() const throw() //멤버 함수   
```

   underflow_error, overflow_error, range_error클래스가 파생됨 논리 오류 클래스처럼 이름만 다르지 같은 매개변수를 받고 what 함수를 사용할 수 있음 <br>

   1. underflow_error : 산술 연산할 때 발생하지만 산술 연산을 할 때 underflow_error 클래스 자료형의 예외를 발생시키지는 않음 즉, 사용자 정의 함수에서 사용자가 언더플로우 발생 가능성이 있는 코드에서 사용함.
   2. overflow_error : 언더플로우 처럼 산술 연산할 때 발생함. 이 또한 사용자가 오버플로우 발생 가능성이 있는 코드에서 사용 
   3. range_error : 함수의 결과가 예상한 범위를 넘을 때 발생 시키도록 설계됨. out_of_range 예외는 함수의 매개변수와 관련된 것이기에 사용되는 상황이 약단 다름. cmath 헤더 파일에 내장되어 있는 수학 함수들은 range_error를 발생시키지 않지만, 다른 라이브러리 함수 등에서 일부 range_error예외를 발생 시킴. 
      
  * 이외

    1.bad_exception : 함수 내부에서, 예외 사양에서 지정하지 않은 예외가 throw될 때 발생. <br>
    2.bad_alloc : new 헤더는 동적 메모리 할당과 관련된 함수들을 제공, new가 어떤 이유로 요청된 메모리를 할당 할 수 없는 경우에 발생 <br>
    3. bad_typied : typeid의 피연산자가 NULL pointer일때 발생 (typeid(*p)에서 p가 널 포인터일 경우) <br>
    4. bad_cast : dynamic_cast이 실패할 때 발생 <br>
    5. failure : ios 헤더 내부에서 입출력과 관련된 예외의 부모 클래스로 사용됨. ios_base 스코프 내부에 있기에 ios_base::failure등의 형태로 사용해야함 <br>

```cpp
explicit failure(const string& mesg) // 생성자
virtual ~failure() //소멸자
virtual const char* what() const throw() //멤버함수 
```

C++의 입출력 클래스는 언어가 예외 처리를 지원하기 전에 만들어져서 failure 클래스는 나중에 예외 클래스 계층에 추가 됨. <br>
입출력 클래스는 스트림에서 오류가 발생하는지 알 수 있게 하는 상태를 가지고 있음 <br>

```cpp
void exception(iostate flags) // 예외를 발생시킬 입출력 상태 설정
iostate exception() const // 현재 설정되어 있는 예외를 발생시키는 입출력 상태 확인 
```

첫 번째 함수는 어떤 상태일 때 예외를 발생시킬지 설정하고, 두 번째 함수는 예외를 발생시키는 상태를 리턴함 

  * 표준 예외 클래스의 사용
    
    사용자 정의 예외 클래스를 만들지 않아도 exception 또는 stdexcpet 헤더에 정의되어 있는 표준 예외 클래스를 사용함 <br>
    
    [14-8 invaild_arugment 클래스를 사용한 예제](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-8.cpp)
