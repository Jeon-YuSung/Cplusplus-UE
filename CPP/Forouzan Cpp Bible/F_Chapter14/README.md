## Ch-14. 예외 처리 
   
   고전적인 오류 처리하는 방법과 try-catch, thorw를 사용하는법, 생성자-소멸자에서 발생하는 예외 처리에 대해 학습

  ------------------------------------------------

  * ### 14-1. 개요
    
     * 고전적인 오류처리 방법

       구문 오류가 없으면 프로그램은 컴파일 되어 실행됨, 하지만 실행 중에 오류가 발생할 수 있음. 이경우 프로그램은 중단 됨. <br>

       1. [런타임 때 프로그램을 중단](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-1.cpp)
       2. [런타임 때 프로그램 중단 요청](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-2.cpp)
       3. [오류 확인 사용](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-3.cpp)
       4. [오류 확인에 함수 리턴 사용](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-4.cpp)

          고전적인 오류 처리 방법에는 몇가지 문제가 있음 <br>
          1. 어떠한 경고도 없이 프로그램이 중단됨 (14-1)
          2. 프로그램이 중단되는 것은 똑같지만 사용자에게 경고를 줌 (14-2)
          3. 프로그램을 중단시킬 가능성이 있는 처리는 무시, 나머지는 계속 실행 가능, 다만 오류를 처리하는 코드가 기본 코드와 결합 되어 있어서 가독성이 떨어짐 (14-3)
          4. 고전적인 처리 방법 중 가장 좋은 방법이지만 모든 상황에 사용할 수 있는 형태가 아님. **구조적 프로그래밍 원칙(Structural Programming Principle)에 따르면 함수의 리턴 값은 하나의 목적만 가져야 함** 하지만 리턴이 오류를 발견하는 목적과, 계산을 처리하는 목적으로 2가지라 원칙에 위배됨 (14-4)
             
  * C++의 예외 처리 방법
    
    C++에서 고전적인 문제를 해결하고자, **예외 처리 방법(Exception Handing Approach)을 제공**
    런타임 때, 예외가 발생해도 프로그램이 이를 처리하여 중단되지 않게 만들 수 있음 <br>

    * Try-catch 블록
      
      C++에서 사용하는 예외 처리 방법으로 try절에는 프로그램을 중단시킬 가능성이 있는 코드를 넣어서 예외가 발생하면 프로그램이 중단되는게 아니라 catch로 절로가서 코드를 계속 진행 시킴 <br>

```cpp
try{
//예외를 발생시킬 수 있는 코드
}catch(자료형 변수){
//예외를 처리하는 코드
}
```

   즉, try 절에서 유로가 발생하면 예외를 발생(throw)시키고 catch절에서는 예외가 발생했을 경우 프로그램이 중단되는 것을 막는 처리를 함. 

   [14-5. try-catch 사용하는 예제](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-5.cpp) <br>
   [14-6. 함수 내부에서 발생한 예외 처리하는 프로그램](https://github.com/Jeon-YuSung/Cplusplus-UE/blob/main/CPP/Forouzan%20Cpp%20Bible/F_Chapter14/14-6.cpp)

   참고로 thorw 구문은 직접적이든, 간접적으로든 try 구문에 있어야한다.  위의 예시 코드를 통해 thorw 위치를 알 수 있다. <br>
   throw 구문이 사용되지 않은 경우가 있는데, 이는 블록 내부에서 호출하는 미리 정의된 함수 또는 라이브러리 함수 내부에 thorw 구문이 포함되어 있는 경우임 <br>
   또한 catch는 여러개를  사용할 수 있음 <br> 

```
   try {
      // 코드 내용 
} catch(int x) { //특정한 자료형의 예외 처리
      // 코드 내용
} catch(...) { //점 3개 입력시, 모든 자료형의 예외를 처리
       //코드 내용     
}
```

   * 예외 전파와 예외 전달
     
      함수 내부에서 예외가 발생한다고, 꼭 같은 함수 내부에서 예외를 처리할 필요는 없음. **어떤 함수 내부에서 예외가 발생하고 처리되지 않았다면 함수 호출 계층 구조를 타고 예외가 전파됨. 예외를 처리할 수 있는 마지막 함수는 main 함수로,** main에서도 예외를 처리하지 않으면 프로그램 전체가 중단 됨. 이러한 과정을 예외 전파(Exception Propagation)이라고도 함 <br>
      catch 절에서 예외를 완전하게 처리할 수 없거나, 처리하고 싶지 않은 경우에는 한 단계 위의 함수로 예외를 전달하면 된다. 예외에 대한 처리를 위해서는 예외를 발생시켜야 하는데, 네트워크나 파일 처리 등에서 필요한 경우에 사용한다. 
      예외를 그대로 다시 발생 시키고 싶다면 catch 절 내부에 thorw만 사용하면 추가적인 피연산자를 지정하지 않아도, 같은 예외가 발생 <br>

```cpp
try {
...// 내용 
} catch(자료형 변수){
 ... // 코드 내용 
throw; //호출한 함수쪽으로 예외 전파.
}
```

  * 예외 사양
    
    함수 시그니처만으로 함수 내부에서 어떤 예외가 발생하는지 알 수 있는 방법이 **예외 사양(Exception Specificaiton)** 이라고 함<br>
    모든 예외 발생 가능, 특정 예외 발생 가능, 예외 없음 -> 3가지로 구분 가능
    
       * 모든 예외 발생 가능
         
         예외 사양이 없는 함수는 모든 예외가 발생(thorw)할 수 있다는 의미로 어떤 예외가 발생하는지 알려면 함수 본문을 봐야함.

       * 특정 예외 발생 가능

         함수의 설계자와 사용자가 다르다면, 함수 내부에서 어떤 예외가 발생할지 명시적으로 알려주는 것이 좋음. <br> 
         int quotient(int first, int second) thorw (int);

       *  예외 없음

          예외를 전혀 발생시키지 않는다고 명시적으로 알려주는 경우가 있는데, 이러한 경우 try-catch를 사용할 필요가 없음. <br>
          이를 명시할 때, 함수의 헤더에 throw 키워드를 사용한다 <br>
          int print(int f, int s) thorw();
    
  * 스택 해제(stack unwinding)

      메모리와 관련이 있는 예외 처리에서 중요한 개념

       * 프로그램 메모리의 구분
         
         1. 코드 메모리 (프로그램 메모리) : 프로그램의 명령어가 올라가는 영역 
         2. 정적 메모리 : 정적 변수와 전역 변수의 값을 저장하는 영역, 지역 변수는 다른 위치에 올라감
         3. 스택 메모리 : LIFO의 특징을 갖는 메모리, 함수와 관련된 매개변수, 지역변수, 리턴 주소를 추적하는 역할을 함
         4. 힙 메모리 : 함수의 수명보다 오래 유지되어야 하는 정보를 저장하기 위한 영역임

       * 스택 메모리의 삽입과 삭제

          예외 처리는 스택 메모리의 동작 기반으로 이루어짐. 모든 프로그램은 함수를 호출할 때 매개변수, 지역 변수, 리턴 주소등의 정보가 스택에 삽입되고, 이때 리턴 주소는 함수가 정상적으로 또는 비정상적으로 종료(예외 발생)되었을 때 사용됨

       * 스택 해제의 적용

         함수의 관련된 정보가 꺼내지면서 매개변수와 지역 변수가 모두 사라진다 는 것인데, 만약 매개변수 또는 지역 변수가 클래스의 인스턴스라면, 소멸자를 호출해서 소멸시켜야함.
         객체를 지역 변수로 스택에 선언 했으면, 함수가 종료될 때 관련된 정보가 모두 제거되므로 큰 문제가 없음 하지만 **힙에 선언 했다면, 객체가 소멸되지 않아 메모리 누수가 발생할 수 있음**
          
  ----------------------------------------------------
  * ### 14-2. 클래스와 예외 처리

    클래스에 정의되어 있는 모든 함수에서 예외가 발생할 수 있음 <br> 
    일반 멤버 함수에서의 예외 처리는 독립적인 함수의 예외 처리와 같지만, 생성자와 소멸자에서 발생하는 예외 처리는 다름.  
    
  * 생성자 내부의 예외 처리

    생성자도 멤버 함수이지만, 객체를 만들고 초기화하는 목적으로 설계 됨 <br>
    생성자에서 예외가 발생하는 되는 경우를 스택 메모리에서 생성되는 경우와 힙 메모리에서 생성되는 경우로 구분할 수 있음 <br>
   
      * 스택에 객체를 생성 하는 경우

         하나의 정수를 저장하는 Integer class가 있다고 가정해보자, 이 클래스처럼 다른 자료형을 감싸는 클래스를 **랩퍼 클래스(Wrapper class)** 라고하며 많이 사용하는 클래스의 형태 <br>
         이를 바탕으로 예외가 발생하지 않은 경우와 발생하는 경우로 구분 할 수 있음 <br>
         
           * 생성자 내부에서 예외가 발생 하지 않은 경우 (스택 메모리)

             객체를 스택 메모리에 만든다면, 생성자가 호출될 때 스택의 가장 위에 객체가 삽입되고 소멸자가 종료될 때 스택에서 삭제 됨 <br>
             생성자 내부의 코드가 실행되기 전에 객체를 위한 영역이 스택에 삽입되고, 생성자 내부의 코드가 실행되면서 영역을 채움 그리고 소멸자가 실행되면 스택에서 객체가 삭제되어 완전히 사라짐 <br>
             
           * 생성자 내부에서 예외가 발생 하는 경우 (스택 메모리)
       
             C++에서 생성자가 생성 작업을 하지 못하는 경우 소멸자를 호출하지 않음.
             생성자 내부에서 예외가 발생하면 프로그램이 중단되고 스택에 할당된 모든 메모리가 해제됨.  <br>

      * 힙에 객체를 일부 생성한 경우
   
        힙도 스택 메모리와 똑같이 내부에서 예외가 발생하지 않은 경우와 발생한 경우로 구분 가능<br>

           * 생성자 내부에서 예외가 발생하지 않은 경우 (힙 메모리) - 책 822쪽 참고 
           
           * 생성자 내부에서 예외가 발생한 경우 (힙 메모리) 
   
              힙에 메모리 영역을 할당하고 생성자 본문에서 예외가 발생하는 경우인데, 생성자에서 예외가 발생한 순간 생성자를 벗어남. 객체가 완전히 만들어진 상태가 아니므로 소멸자가 호출되지 않음 <br>
             스택 해제 중에 객체가 삭제되기는 하지만 소멸자가 호출되지 않으므로 힙에 할당된 영역이 해제되지 않아 메모리 누수가 발생 됨 <br>
             생성자에서 메모리를 할당했는데 예외가 발생해서 처리를 끝까지 하지 않으면, 소멸자가 호출되지 않아 메모리 해제를 하지 못함 <br>
             이럴 때, 할당과 해제를 하나의 작업으로 결합하면 해결할 수 있음 <br>
             
           * 스마트 포인터를 활용해 메모리 관리
              메모리 할당과 해제에 원시 포인터 (raw pointer)가 아니라 스마트 포인터(smart pointer)를 사용하면 생성자가 호출될 때 메모리를 할당하고, 소멸자가 호출될 때 메모리를 해제함 스마트 포인터의 생성자에는 별도의 처리가 없기에 내부적으로 문제가 발생하지 않고 소멸자도 항상 호출 됨. <br>
           * Function-try 블록
             생성자 내부에서도 try-catch 블록을 사용해서 예외처리가 가능 함. 하지만 초기화 리스트에서 예외가 발생한다면 try-catch블록을 결합한 형태의 function-try 블록을 사용해야함 <br>

            Function-try은 모든 함수에서 사용할 수 있고 함수 뒤에 곧바로 try catch 블록을 붙여서 사용하는 형태임. 하지만 일반적인 함수는 내부에 try-catch블록을 넣기 때문에 거의 사용하지 않고 클래스 또는 구조체의 생성자와만 조합해서 사용하는 편이지만 많이 사용하지 않음 <br>

```cpp
void test() try{
   throw "예외 발생"; // 함수 본문
} catch(...){
cout << "예외가 발생 했습니다 \n; // 함수 본문에서 예외가 발생하는 경우
}

int main(void){
   test();
   return 0;
}
```

[14-7. Intger 클래스를 사용한 예제 프로그램]()

  * 소멸자에서의 예외 처리

       스택에서 어떤 객체가 사라질 때 **소멸자가 호출 됨, 이때 예외가 발생하면** 스택에서 메모리가 제거되는데 문제가 발생하여 **terminator라는 프로그램 전체를 종료하는 전역 함수**를 호출 함 <br>

------------------------------------------------------
  * ### 14-3. 표준 예외 클래스
  * 논리 오류
  * 런타임 오류
  * 이외
  * 표준 예외 클래스의 사용
    
