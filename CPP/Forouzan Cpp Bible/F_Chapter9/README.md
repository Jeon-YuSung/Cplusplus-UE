## Chapter9 참조, 포인터, 메모리 관리 

참조 변수와 참조 자료형, 포인터의 개념 
배열과 포인터의 관계, 메모리 관리하는 법을 알아보는 챕터. 

-----------------------------------
### 9-1 참조

* #### 참조 변수와 참조 자료형
  참조(Reference)는 객체의 또 다른 이름 <br>
  C++에서 추가된 기능으로, 함수 등의 엔티티끼리 커뮤니케이션하는걸 쉽게 만들어줌 <br>

+ ##### 참조 변수 (reference variable)
 reference variable는 일반적인 변수와 다르게 메모리 위에 새로운 영역을 잡지 않음<br>
 단순하게 기준에 있던 변수와 바인드해서 기존에 있던 변수에 새로운 이름을 붙여 주기에, **원본 변수**가 있어야만 생성할 수 있음. <br>
 
 ```cpp
int score = 92; //int 자료형 선언하고 초기화
int& rScore = score;  // int& 자료형 변수 rScore를 선언하고 연결
```

두 변수 모두 92 값을 나타내지만, socre 변수는 int 자료형이과, rScore변수는 int& 자료형임. <br>

+ ##### 참조 자료형
  원본 변수와 참조 변수가 같은 메모리 위치를 가리키므로 **값**은 같지만, **자료형**은 다르다. <br>
  참조 변수는 참조 자료형이라는 새로운 자료형을 뜻함. <br>
  참조 자료형은 복합 자료형으로 자료형 + & 형식으로 이루어짐. <br>
  변수를 참조 변수와 연결할 때는 반드시 **변수의 자료형과 참조 변수가 나타내는 자료형**이 일치해야한다.

  ```cpp
  int num = 100;
  doulbe& rNum = num; //자료형이 다르므로 컴파일 오류 발생.
  ```


* ##### 참조 관계
  참조가 선언되고 어떤 변수와 연결되면 참조 관계는 스코프를 벗어나서 변수가 파괴되기 전까지는 계속해서 유지 됨.<br>
  즉 **참조 관계는 한 번 정의되면 변경 불가** <br>
  C++에서는 변수와 참조 변수가 연결된 관계를 **constant relation**이라고 표현

  ```cpp
  int score = 92;
  int& rScore = socre;
  int num = 80;
  int* rScore = num; // 컴파일 오류 - 참조 관계를 깨버림
  ```
  
  ```cpp
  int score = 92;
  int& rScore = socre;
  int num = 80;
  rScore = num; // 정상 작동
  ```

  2번째 코드에서 rScore = num;는 참조 관계를 깨버린 것이 아니다. **공유하고 있는 메모리 위치에 num의 값을 넣은 것이지**, 참조 연결을 하는 문장이 아님<br>
  참고로 rScore는 score의 별칭이므로 rScore = num은 score = num과 같은 기능을 한다.

  * ##### 참조 다중성
    하나의 변수를 기반으로 여러 개의 참조 변수를 만들 수 있지만 반대는 불가능 <br>
    즉, 참조 변수 하나를 여러 변수에 연결할 수 없음.<br>
    
```cpp
int num = 100;
int& rNum1 = num;
int& rNum2 = num;
int& rNum3 = num;
int& rNum4 = num;
```
위의 코드는 num 변수를 기반으로 4개의 참조 변수를 만드는 예시

하지만, 참조 변수 하나를 여러 변수와 연결하려고 하면 컴파일 오류가 발생<br>
같은 이름으로 변수를 생성하는 것도 불가능하고 constant relation을 끊는 것도 불가능하기 때문<br>

```cpp
int num1 = 100;
int num2 = 200;
int& rNum = num1;
int& rNum = num2;
```

위의 코드에서, 마지막 코드는 컴파일 오류가 발생한다. 즉 rNum은 num1와 연결되어 있어 num2와 연결을 할 수 없기 때문이다. <br>
참고로 **참조 변수에 단순한 값을 연결하는 것**은 불가능하다.  

```cpp
int& a = 201;
```

  * #### 값 추출
    참조 관계가 만들어지면, 원본 변수와 참조 변수 중에 아무 것이나 사용해도 값에 접근하여 값을 추출할 수 있음. <br>
    [9-1 값에 접근하기]()
    
  * #### 값 변경
    참조 관계가 만들어지면, 데이터 변수 또는 참조 변수를 사용해서 원본 값을 변경할 수 있다. <br>
    그런데, 원본 변수에 **const 한정자**가 붙으면 값을 변경할 수 없다<br>
    const는 원본 변수 또는 참조 변수의 앞에 올 수 있다. 이때 **원본 변수에 const변수가 붙였다면, 참조 변수도 같이 const 한정자를 붙여야 한다.** <br>

 ```cpp
  int name = value;
  int &rName = name; // 가능
 ```
원본 변수와 참조 변수 중에 아무 것이나 사용해도 메모리 위치의 값을 변경할 수 있음. 

```cpp
 int name =value; 
 const int &rName = name; //가능 
```
원본 변수를 사용해서 값을 변경할 수 있음, 하지만 참조 변수를 사용해서는 값을 변경할 수 없음.

```cpp
 const int name =value; 
 const int &rName = name; //가능
```
원본 변수와 참조 변수 모두 값을 확인할 때만 사용할 수 있고, 값을 변경할 수 없음. <br>
이를 활용해서 프로그램을 만드는 경우는 거의 없음. 

```cpp
 const int name =value; 
 int &rName = name; // 불가능
```
오류가 발생함. <br>
const 한정자가 붙지 않은 참조 변수에 const 한정자가 붙은 변수를 바인드하면 컴파일 오류가 발생. 원본 변수가 const  한정자로 고정되어 있으므로  참조 변수를 사용해서 값을 변경할 수 있는 방법이 없음. 


* #### 참조의 활용

하나의 함수 내부에서 어떤 메모리 위치에 대한 참조 변수를 모두 만드는 경우는 없음<br>
원본 데이터 변수만 활용해도 값을 확인하고 변경하는 작업이 모두 가능하기 때문 <br> 
주로, 참조 변수는 일반저긍로 함수를 만들 때 처럼 서로 다른 스코프를 갖는 경우에 활용 <br>

두 함수의 커뮤니케이션에서 참조를 활용하는 방법을 알아보자 <br>
**함수의 커뮤니케이션이란 데이터를 전달하고 리턴하는 것을 의미** <br>
**참조를 활용해서 데이터를 전달하는 것을 참조로 전달 (Pass-by-reference)**, **데이터를 리턴하는 것을 참조로 리턴 (Retrun-by-reference)** 이라고 부름 <br>

* ##### 참조로 전달 (Pass by Reference)
  참조로 전달 (Pass by Reference)은 호출하는 함수 쪽에서 호출되는 함수 쪽으로 객체(1 or 그 이상)를 전달하는 것을 의미
  6장에서 값으로 전달(Pass by Value)을 알아봤었고, 이번에는 참조로 전달(Pass by Reference)에 알아본다.
   이 둘의 차이점은 Pass by Value는 모든 바이트를 복사하는 것이고, Pass by Reference은 메모리 위치를 공유하는 것이다.

  ```
* ##### 참조로 리턴 (Retrun by Reference)
--------------------------------------------------
* ### 9-2 Pointer 
 
