# 4-19 클래스 설계는 타입 설계와 똑같이 취급하자.
C++에서 새로운 클래스를 선언하고 정의하는건 새로운 타입을 하나 정의하는 것과 같다. 
즉, 단순히 클래스 설계자가 아니라, **Type** 설계자로, 함수와 연산자를 오버로드하고, 메모리 할당 및 해제를 해야하며, 객체 초기화 및 소멸자를 정의하는 모든 걸 해야한다. <br>
좋고 효율적인 클래스를 설계하기 위한 질문들은 다음과 같다 

1. 새로운 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가? → 이 부분이 어떻게 되느냐에 따라 클래스 생성자 및 소멸자의 설계가 바뀌고, 메모리 할당 함수(operator new, operator new[], operator delete, operator delete[])를 직접 작성할 경우 설계에 영향을 미친다. 
2. 객체 초기화는 객체 대입과 어떻게 달라야 하는가? → 생성자와 대입 연산자의 동작 및 둘 사이의 차이점을 결정짓는 요소로, 초기화와 대입을 헷갈리리지 않도록 하는 것이 가장 중요하다. 각각 해당되는 함수 호출이 다르기 때문이다.  
3. 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가? → 값에 의한 전달 (Call by / Pass by Value)을 구현하는 쪽은 **복사 생성자**이다.
4. 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가? → 클래스 데이터 멤버의 몇 가지 조합 값은 **반드시 유효해야** 한다. 이런 조합을 **불변 속성(Invariant)** 라고하고, 클래스 차원에서 지켜줘야 한다. 불변 속성에 따라, 클래스 멤버 함수 안에서 해 주어야 할 에러 점검 루틴이 결정된다. 특히, 생성자, 대입 연산자, setter 함수는 불변 속성에 많이 영향을 받는다. 또한 함수가 발생시키는 예외에도 영향을 미친다.
5. 기존의 클래스 상속 계통망(Inheritance Graph)에 맞출것인가? → 이미 존재하는 클래스를 상속받아 설계시, 이들 클래스에 의해 제약을 받는다. 멤버 함수의 가상(virtual)/비가상(Non-virtual) 여부가 큰 요인이다. 내가 만든 클래스를 다른 클래스에 상속 받을 수 있게 하려면, 가상 함수 여부에 따라 결정된다 (특히 **소멸자**에서)
6. 어떤 종류의 타입 변환을 허용할 것인가? → 타입 변환이 하고 싶다면 암시적/명시적 타입 변환을 선택해서 만들어야 한다.
7. 어떤 연산자와 함수를 두어야 의미가 있을까? →  어떤 것들이 멤버 함수로 적당할 수 있고, 몇몇은 그렇지 않을 것이다(항목 23, 24, 26 참고)
8. 표준 함수들 어떤 것을 허용하지 말아야 할까? → 어떤 함수를 private로 선언하는지를 구분하자
9. 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줘야 하는가? →  클래스 멤버에 대한 접근 제어 지정자 (public, private, protected)를 결정해야하고, friend class로 만들어야 할 클래스 및 함수와 클래스 안에 다른 클래스를 중첩시켜도 되는지 생각 해보자.
10. 선언되지 않은 인터페이스로 무엇을 둘 것인가? → 만들 타입이 제공할 보장이 어떤 종류일까? 보장할 수 있는 부분은 수행 성능이나 예외 안정성, 자원 사용이고, 보장하겠다고 결정한 결과는 클래스 정의(구현)에 있어서 제약으로 작용한다.
11. 새로 만드는 타입이 얼마나 일반적인가? → 새로 만드는 것은 하나의 타입이 아닌 동일 계열의 타입군(Family of types) 전체일 수 있다. 그럼 새로운 클래스를 만드는 것이 아닌 새로운 클래스 템플릿으로 정의해야 한다.
12. 정말로 꼭 필요한 타입인가? → 기존의 클래스에서 기능 몇개가 아쉽다면 파생 클래스를 만들지 않고, 비멤버 함수나 템플릿을 몇 개 더 정의하는 편이 낫다.

### 항목 19 정리 
클래스 설계는 타입 설계이다. 왜 클래스가 사용자 정의 타입에 속하겠는가? 즉, 새로운 타입을 정의하기 전에 항목 19에 나온 질문들을 고려해보자.  
