# 항목 22 - 데이터 멤버가 선언될 곳은 private 영역임을 명심하자.

이번 절에서는 데이터 멤버를 왜 public가 아닌 private에 선언해야하는 이유를 알아보고, public 데이터 멤버에 대한 모든 이야기가 protected 데이터 멤버에도 똑같이 적용되는걸 확인 해보자. 

  - **데이터 멤버를 public으로 선언하면 안되는 이유**
  1. 문법적 일관성
    - 공개 인터페이스가 전부 함수뿐이면, 클래스의 멤버에 접근할 때 괄호를 쓸지 말지 고민할 필요가 없다. 전부 함수로 되어 있으니, 그냥 쓰면 되기 때문이다.

  2. 세밀한 접근제어
    - 변수가 public이라면 읽기, 쓰기, 수정 등... 모든 것을 할 수 있지만, private로 만들면 읽기 '전용', 쓰기 '전용', 읽기 및 쓰기 전용 형식으로 구현할수 있다. (read only, write only...etc)
    - 즉, 접근 권한을 좀더 세밀하게 제어가 가능하다.

```cpp
class AccessLevels{
  private:
    int noAccess; // 접근 불가
    int readOnly; // 읽기 전용
    int readWrite; // 읽기 및 쓰기 전용
    int wirteOnly; // 쓰기 전용

public:
  int getReadOnly() const { return readOnly;}
  int setReadWrite(int Value) { readWrite = Value; }
  int getReadWrite() cosnt {return readWrite;}
  int setWriteOnly(int Value) { wirteOnly = Value;} 
};

```

왜 세밀한 접근제어를 해야하고, 중요한가? → 어떤 식으로든 외부에 노출시키면 안 되는 데이터 멤버들이 많기 때문이다. 모든 데이터 멤버에 읽기 및 쓰기 함수를 달아 줄 일이 거의 없기 때문이다. 
      
  3. 캡슐화(Encapsulation)  
      - 함수를 통해서만 데이터 멤버를 접근할수 있도록 구현하면, 나중에 데이터 멤버를 계산식으로 대체할 수도 있고, 사용자는 절대로 이 클래스를 수정할 수 없다. 
      - 즉, 데이터 멤버를 캡슐화하면, 구현상의 융통성을 전부 누릴 수 있고, 이를 통해 데이터 멤버를 읽거나 쓸 때, 다른 객체에 알림 메시지를 보내거나 클래스의 불변성 및 사전 조건과 사후 조건을 검증하고, 스레딩 환경에서 동기화하는 등.. 간편하게 할 수 있다. 
      - 델파이나 C#의 Property와 같다고 느낄 수 있다. 물론 C++에서는 괄호쌍을 더 붙여줘야 한다. 
      - 캡슐화는 클래스의 불변속성을 항상 유지하는데 매우 큰 도움을 주는데 이는 불변 속성을 보여줄 수 있는 통로가 멤버 함수 밖에 없기 때문이다. 또한, 캡슐화는 현재의 구현을 나중에 바꾸기로 결정할 수 있는 권한을 예약하는 셈이다. 
      - C++에서 public이란? **캡슐화 되지 않았다** 라는 뜻이고, 캡슐화 되지 않았다라는 것은 바꿀 수 없다라는 의미를 지니고 있다. 

  - **public과 protected**
    + protected 데이터 멤버도 같다 비슷하다. **public처럼 protected에도 그대로 적용**할 수 있다.
    + 여러 외부 클래스에서 이 데이터를 사용 중인 경우 였지만, 데이터를 삭제할 일이 생긴다면 고칠 것이 많아지기 때문이다. 

  - **4장 22절 정리**
    + 데이터 멤버는 private 멤버로 선언하자, 이를 통해 클래스 제작자는 문법적으로 **일관성 있는 데이터 접근 통로를 제공**할 수 있고, 필요에 따라서는 세밀한 접근 제어도 가능하고 클래스의 불변속성을 강화할 수 있을 뿐만 아니라, 내부 구현의 융툥성도 발휘할 수 있다.
    + protected는 public보다 더 많이 **보호**받고 있는것이 절대 아니다.
  
