# 3-14 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자!

3-13의 자원 획득 즉 초기화(Resource Acquisition Is Initialization, RAII)통해 힙 기반 자원을 해제하는 법을 알아보았다. <br>
근데 모든 자원은 힙에서 생기지 않기 때문에, 프로그래머 스스로 자원 관리 클래스를 만들어야 한다. <br>
다음의 예제 코드는 Mutex 타입의 객체를 조작하는 C API를 사용 중이라고 가정하자, C API에서 lock, unlock 함수를 제공한다.

```cpp
void lock(Mutex* pm); // pm이 가리키는 뮤텍스에 락을 건다.
void unlock(Mutex* pm); //pm이 가리키는 해당 뮤텍스를 언락한다.
```

이제, 클래스에 뮤텍스 잠금을 관리하는 걸 만들어보자. <br>
자원을 획득하고, 소멸시에 그 자원을 해제해야하니 이전에 걸어 둔 뮤텍스락을 기억하고 후에 뮤텍스 언락을 하는걸 만들어보자 

```cpp
class Lock{
private:
  Mutex* mutexPtr;

public:
  explicit Lock(Mutex* pm) : mutexPtr(pm) {
  lock(mutexPtr); //자원 획득
  }

  ~Lock(){
    unlokc(mutexPTr); //자원 해제 
  }

};
```
사용자가 lock을 사용할 때 RAII방식을 생각하면서 쓰면 된다. 

```cpp
Mutex m; // 뮤텍스 정의

...
{                // 임계 영역을 정하기위해 코드 블록을 만듬
  Lock m1(&m);   //  뮤텍스에 락을 함
  ...            //  임계 영역에서 할 연산을 수행
}                // 코드 블록의 끝, 뮤텍스에 걸렸던 잠금이 자동으로 풀림 
```

만약에 Lock 객체가 복사가 되면 어찌될까?

```cpp
Mutex m;
Lock m1(&m); 
Lock m2(m1); //복사 생성자  
```

RAII의 객체가 복사 될 때 어떤 동작을 해서 해결해야하는지에 대한 선택지는 다음과 같다.

1. **복사를 금지한다**
   
   → RAII 객체가 복사 되도록 놔두는 것 자체가 말이 안되는 경우가 있다. 애초에 어떤 스레드 동기화 객체에 대한 **사본**은 의미가 없기 때문이다. 그럼 복사하면 안되는 RAII 클래스에 대해서는 반드시 복사가 되지 않도록 해야하는데 이에 대한 해결책으로는 **복사 연산(함수)을 private 멤버**로 막는 것이다.

```cpp
class Lock : private Uncopyable{
  public:
...
};
```

2. **관리하고 있는 자원에 대해 참조 카운팅을 수행한다**
   
   → 자원을 사용하고 있는 마지막 객체가 소멸될 때까지 그 자원을 해제하지 않는 것이 바람직한 경우가 있는데, 이럴 경우에는 해당 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 RAII 객체의 복사 동작을 만들어야 한다. 이런 방식은 tr1::shared_ptr이 사용되고 있다. <br>
즉, Lock 클래스의 멤버 변수인 Mutex* mutexPtr → tr1::shared_ptr<Mutex>mutexPtr로 바꾸면 된다. <br>
하지만, tr1::shared_ptr는 참조 카운트가 0이 될 때, 자신이 가리키고 있던 대상을 삭제하도록 기본 동작이 되어있으니, 이를 방지하기 위해 삭제자(deleter)를 지정하면 된다.
  - p.s : 삭제자(deleter)란? → tr1::shared_ptr이 유지하는 참조 카운트가 0이 되었을 때, 호출되는 함수 혹은 함수 객체를 뜻한다. (참고로, auto_ptr은 이 기능이 없기 때문에, auto_ptr에서는 포인터를 바로 삭제 해버린다). <br>
삭제자는 tr1::shared_ptr 생성자의 두 번째 parameter로 선택적으로 넣어 줄 수 있다.

```cpp
class Lock{
private:
  std::tr1::shared_ptr<Mutex> mutexPtr; // 원시 포인터 대신에 shared_ptr 사용

public:
  explicit Lock(Mutex* pm) : mutexPtr(pm, unlock){ //shared_ptr를 초기화하는데, 가리킬 포인터로 Mutex 객체의 포인터를 사용
    lock(mutexPtr.get());                          // 삭제자 함수로 unlock 함수 사용.
  }
};
```

참고로, Lock 클래스에서 소멸자를 선언하지 않는 것을 알 수 있는데, 이건 필요없기 때문에 선언을 하지 않는거다. <br>
만약 모르겠다면 항목 5를 다시 보는걸 추천한다. <br>
쉽게 설명하면 객체 소멸 과정을 잊은게 아니라 컴파일러가 자동적으로 생성한 소멸자를 통해 동작한다로 이해하면 된다 
  
3. **관리하고 있는 자원을 진짜로 복사한다**
   
   → 때에 따라서는 자원을 원하는 대로 복사할 수도 있는데, 이 때 **자원을 다 썼을 때 각각의 사본을 확실히 해제 하는 것**이 자원 관리 클래스가 필요한 이유가 되는거고, 자원 관리 객체를 복사하면 그 객체가 둘러싸고 있는 자원까지 복사되어야 한다 → **깊은 복사(deep copy) <br>
표준 string 타입을 구현해 놓은 것 중에, 문자열을 구성하는 원소들을 힙 메모리(heap memory)에 저장해 놓고, 이 메모리에 대한 포인터를 데이터 멤버로 갖고 있는 경우가 있다. <br>
이때 이 객체를 복사하면, 사본은 포인터 및 그 포인턱 가리키는 새로운 힙 메모리를 갖게 된다.

5. **관리하고 있는 자원의 소유권을 옮긴다**
   
   → 어떤 특정한 자원에 대해 그 자원을 실제로 참조하는 RAII 객체는 딱 하나만 존재하도록 만들고 싶을 때, 그 RAII 객체가 복사될 때 자원의 소유권을 사본 쪽으로 아예 옮기면 되는데 이는 auto_ptr의 복사 동작에 해당한다.

   - **3-14 정리**
       + RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에, 그 자원을 어떻게 복사하느냐에 따라 RAII 객체의 복사 동작이 결정된다.
       + RAII 클래스에 구현하는 일반적인 복사 동작 복사를 금지하거나 참조 카운팅을 해주는 선으로 마무리하는 것이 좋다. 물론, 이 외에도 여러 방법들이 있다.
    
-----------------------------------------------------------------

## 참고 사항
  3-13항목에서도 auto_ptr에 대해서 썼는데, C++17에서 삭제되었다고 한다 <br> 
  그러니 auto_ptr 대신 unique_ptr를 쓰자 

  - **auto_ptr**
    1. 소유권 전송 방식이 위험함
    2. 복사(copy) 시, 원래 포인터가 null이 되고 소유권이 새 객체로 넘어감.
    3. 겉보기에는 "얕은 복사"처럼 보여 버그 유발 가능.
    4. 컨테이너(std::vector, std::map 등)에 넣기 어려움.
    5. 현대 C++의 이동语法(move semantics)와 맞지 않음.

  - **unique_ptr**
    1. 소유권이 유일(Unique Ownership)
    2. 복사 금지 (copy constructor, copy assignment 삭제됨).
    3. 이동(move)만 허용 → 명시적으로 소유권 이동 가능.
    4. 표준 컨테이너와 호환 가능 (std::vector<std::unique_ptr<T>> 가능).
    5. 메모리 해제를 자동으로 관리 (RAII).

```cpp
// C++98 스타일 
std::auto_ptr<int> p1(new int(42));
std::auto_ptr<int> p2 = p1;  // 위험! p1은 null이 되고 p2만 소유

// 현대 C++ (권장)
std::unique_ptr<int> p3 = std::make_unique<int>(42);
// std::unique_ptr<int> p4 = p3; // 오류! 복사 금지
std::unique_ptr<int> p4 = std::move(p3); // OK: 소유권 이동
```
