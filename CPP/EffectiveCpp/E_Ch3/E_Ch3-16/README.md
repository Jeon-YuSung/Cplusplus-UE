# 3-16 new 및 delete를 사용할 떄는 형태를 반드시 맞추자.  

다음 코드를 보자 

```cpp
std::string* stringArray = new std::string[100];
...
delete stringArray;
```

보기엔 문제가 없어보이는 코드 같지만, 실제로는 **미정의 동작**을 할 것 이다. stringArray가 가리키는 100개의 string 객체들 중 99개는 정상적인 소멸과정을 거치지 못할 가능성이 크그 때문이다.

**new와 delete** 

new 연산자로 어떤 객체에 동적 할당을 하면, 2가지 내부 동작이 진행된다.
1. 메모리가 할당된다 (operator new라는 이름의 함수가 사용).
2. 할당된 메모리에 대한 한 개 이상의 생성자가 호출된다.

delete 연산자를 사용할 때는 new 연산자와 다른 2가지의 내부 동작이 진행된다.
1. 기존에 할당된 메모리에 대한 한 개 이상의 소멸자가 호출된다.
2. 그 후에 그 메모리가 해제된다 (operator delete 함수 사용)

이때, delete 연산자가 적용되는 객체의 갯수는 몇개일까? <br>
답은 **소멸자가 호출되는 횟수 만큼 delete연산자가 적용된다** 

삭제되는 포인터는 객체 하나만 가리킬까? 아니면 객체의 배열을 가르킬까? 이 질문이 가장 **중요**한데, 그 이유는 new로 힙에 만들어진 단일 객체의 메모리 배치구조(Layout)는 객체 배열에 대한 메모리 배치구조(Layout)과 다르기 때문이다. 특히, 배열을 위해 만들어지는 힙 메모리에는 대개 배열 원소의 개수가 박혀들어가기 때문에, delete 연산자는 소멸자가 몇 번 호출되는지를 알 수 있지만, 단일 객체용 힙 메모리는 이런 정보가 없기 때문이다. <br>
즉, **배치구조가 다르다** 

<img src = "https://github.com/Jeon-YuSung/Jeon-YuSung.github.io/blob/main/_img/MemoryLayoutGpt.png" width = "700" height= "500"/>

어떤 포인터에 대해 delete연산자를 사용할 때, delete 연산자에게 **배열 크기 정보가 있다**를 알려주는건 프로그래머가 알려줘야한다. 알려주는 방법은 delete연산자에 []를 붙여주면 된다. 그럼 delete 연산자는 **포인터가 배열을 가리키고 있구나**라고 생각하게 될 것이고 알려주지 않으면 단일 객체라고 간주한다. 

```cpp
std::string* stringPtr1 = new std::string;
std::string* stringPtr2 = new std::string[100];
...
delete stringPtr1; //단일 객체 메모리 해제
delete[] stringPtr1; //객체의 배열 메모리 해제. 
```

만약에, 단일 객체에게 []를 붙이면 어찌 될까? <br>
보통은 객체 메모리 앞쪽의 몇 바이트를 읽어 배열 크기라고 해석할 것이고, 배열 크기 만큼 소멸자를 호출할 텐데, 해제하고 싶은 메모리가 단일 객체 메모리라서 결국엔 **엉뚱한 메모리를 해제**할 것이다. <br>
그럼 객체의 배열에 []를 사용하지않으면 어찌될까? <br>
**소멸자 호출 횟수가 너무 적어서**, 심지어 int등의 기본 제공 타입이라고 해도, 이들의 배열에 대해 []선언하지 않으면, 소멸자도 없는데 미정의 동작을 하게 될 것이다. 

**new 연산자에 []를 사용했으면, delete연산자에도 []를 써야한다는** 규칙을 꼭 기억하면 된다. 

동적 할당된 메모리에 대한 포인터를 멤버 데이터로 갖고 있는 클래스를 만드는 중이며, 이 클래스에서 제공하는 생성자도 여러 개일 경우에 이 규칙을 반드시 기억하자, 포인터 멤버를 초기화하는 부분인 생성자에서 **new 형태를 똑같이** 맞출 수 밖에 없기 때문이다. <br>
typedef로 정의된 어떤 타입의 객체(배열)를 메모리에 생성하려고 new를 썼을 때, 나중에 어떤 형태의 delete 연산자를 줘야할지는 typedef의 정의에 따라 달라진다. 

```cpp
typedef std::string AddressLines[4];

std::string* pal = new AddressLines; //new string[4]와 똑같다, 그래서 string*를 반환해야한다.
//delete pal; 미정의 동작이 발생함으로 []를 붙여주자
delete [] pal;
```

그리고, 배열 타입을 typedef로 정의하는걸 추천하지 않는다. string, vector, STL의 array...등 좋은 라이브러리(클래스 템플릿)있기 때문에, 잘 활용하면 동적 할당 배열이 필요해질 이유가 거의 없기 때문이다. vector\<string\>타입으로 만드는 등

  - **3-16 정리**
    + new 표현식에는 []를 썼으면, 대응되는 delete 표현식에도 []를 써야하고, 마찬기지로 new에 []를 쓰지 않았으면 delete도 []를 쓰면 안된다. 
