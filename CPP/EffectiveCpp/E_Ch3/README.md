# Ch3. 자원 관리

**<개요>**

프로그래밍에서 자원(Resource)란? → 사용을 일단 마치고 난 후엔, 시스템에 돌려주어야하는 모든 것. 돌려주지 않으면 많은 문제가 발생함 <br>
일단, C++에서는 동적 할당 메모리를 예로 들 수 있는데 new 연산자를 해주면, delete연산자를 꼭 써줘야 한다 만약에 메모리 할당 해제를 해주지 않는다면 **메모리 누수**가 발생한다. (C언어에서는 malloc, calloc으로 할당해주고, free연산자로 해제). 그리고 메모리는 프로그래머가 관리해야하는 수 많은 자원중 하나일 뿐이다. 자원에는 파일 서술자(File Descriptor), 뮤텍스 락(Mutex Lock), GUI에서 사용하는 Font와 brush도 자원이며, 심지어 DataBase 연결, 네트워크 소켓 역시 자원에 속한다.  <br>
가장 중요한 것은 **어쨌든 가져와서 다 썼으면 해제 해야한다. 즉, 놓아주어야 한다.** <br>
이번 챕터에서는 **객체 기반 방식의 자원 관리를 보여주는 것**부터 시작한다. C++가 지원하는 생성자, 소멸자, 객체 복사 함수를 잘 이용하면 대부분의 자원 관리 문제는 모두 해결할 수 있다. 그러니 일반적인 메모리 관리 방법과, 특수 사항에 대해 보충하는 내용을 알게 되면, 메모리를 관리하는 객체가 그 메모리를 적절히 처리하는 방법을 알 수 있다. 

**<목차>**
  - [3.13 자원 관리에는 객체가 그만!](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/EffectiveCpp/E_Ch3/E_Ch3-13)
  - [3-14 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/EffectiveCpp/E_Ch3/E_Ch3-14)
  - [3-15 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록  하자](https://github.com/Jeon-YuSung/Cplusplus-UE/tree/main/CPP/EffectiveCpp/E_Ch3/E_Ch3-15)
  - 3-16 new/delete를 사용할 때는 형태를 반드시 맞추자.
  - 3-17 new 생성한 객체를 smart pointer에 저장하는 코드는 별도의 한 문장으로 만들자

-----------------------------------------------------------------------------------

## 참고 사항
  이번 챕터에 auto_ptr가 나오는데 Ch3. 자원 관리

**<개요>**

프로그래밍에서 자원(Resource)란? → 사용을 일단 마치고 난 후엔, 시스템에 돌려주어야하는 모든 것. 돌려주지 않으면 많은 문제가 발생함 <br>
일단, C++에서는 동적 할당 메모리를 예로 들 수 있는데 new 연산자를 해주면, delete연산자를 꼭 써줘야 한다 만약에 메모리 할당 해제를 해주지 않는다면 **메모리 누수**가 발생한다. (C언어에서는 malloc, calloc으로 할당해주고, free연산자로 해제). 그리고 메모리는 프로그래머가 관리해야하는 수 많은 자원중 하나일 뿐이다. 자원에는 파일 서술자(File Descriptor), 뮤텍스 락(Mutex Lock), GUI에서 사용하는 Font와 brush도 자원이며, 심지어 DataBase 연결, 네트워크 소켓 역시 자원에 속한다.  <br>
가장 중요한 것은 **어쨌든 가져와서 다 썼으면 해제 해야한다. 즉, 놓아주어야 한다.** <br>
이번 챕터에서는 **객체 기반 방식의 자원 관리를 보여주는 것**부터 시작한다. C++가 지원하는 생성자, 소멸자, 객체 복사 함수를 잘 이용하면 대부분의 자원 관리 문제는 모두 해결할 수 있다. 그러니 일반적인 메모리 관리 방법과, 특수 사항에 대해 보충하는 내용을 알게 되면, 메모리를 관리하는 객체가 그 메모리를 적절히 처리하는 방법을 알 수 있다. 

**<목차>**
  - 3.13 자원 관리에는 객체가 그만!
  - 3-14 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자
  - 3-15 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록  하자
  - 3-16 new/delete를 사용할 때는 형태를 반드시 맞추자.
  - 3-17 new 생성한 객체를 smart pointer에 저장하는 코드는 별도의 한 문장으로 만들자

-----------------------------------------------------------------------------------

## 참고 사항
  이번 챕터에 auto_ptr가 나오는데, C++17에서 삭제되었다고 한다 <br> 
  그러니 auto_ptr 대신 unique_ptr를 쓰자 

  - **auto_ptr**
    1. 소유권 전송 방식이 위험함
    2. 복사(copy) 시, 원래 포인터가 null이 되고 소유권이 새 객체로 넘어감.
    3. 겉보기에는 "얕은 복사"처럼 보여 버그 유발 가능.
    4. 컨테이너(std::vector, std::map 등)에 넣기 어려움.
    5. Modern C++의 이동(move semantics)와 맞지 않음.

  - **unique_ptr**
    1. 소유권이 유일(Unique Ownership)
    2. 복사 금지 (copy constructor, copy assignment 삭제됨).
    3. 이동(move)만 허용 → 명시적으로 소유권 이동 가능.
    4. 표준 컨테이너와 호환 가능 (std::vector<std::unique_ptr<T>> 가능).
    5. 메모리 해제를 자동으로 관리 (RAII).

```cpp
// C++98 스타일 
std::auto_ptr<int> p1(new int(42));
std::auto_ptr<int> p2 = p1;  // 위험! p1은 null이 되고 p2만 소유

// 현대 C++ (권장)
std::unique_ptr<int> p3 = std::make_unique<int>(42);
// std::unique_ptr<int> p4 = p3; // 오류! 복사 금지
std::unique_ptr<int> p4 = std::move(p3); // OK: 소유권 이동
```
