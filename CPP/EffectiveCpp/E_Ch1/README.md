# Ch1. C++의 법을 따르자.

효과적으로 활용하기 위해선 C++는 C++스타일답게 사용하자. 
  
  - [1.1 C++를 언어들의 연합체로 바라보는 안목은 필수](#-1.1-C++를-언어들의-연합체로-바라보자)
  - [1.2 #define을 쓰려거든 const, enum, inline을 떠올리자](#-1.2-#define을-쓰려면-const,-enum,-inline을-생각하자)
  - [1.3 낌새만 보이면 const를 들이대 보자](#-1.3-const)
  - [1.4 객체를 사용하기 전에 반드시 그 객체를 초기화하자]()

-------------------------------------------------

### 1.1 C++를 언어들의 연합체로 바라보자
c++는 처음에 C with classes로 시작한 언어임, 즉 절차 지향 언어인 C언어에 클래스를 입혀 객체 지향 언어로 변모하였습니다. <br>
과거와 달리 요즘은 많이 발전하여 예외, 템플릿 프로그램 설계, STL으로 **확장성**과 사고방식을 바꿔 주었고, <br>
현재의 C++는 **다중패러다임 프로그래밍 언어(Multiparadigm Programming Language)이며, 절차적인 프로그래밍을 베이스하여 객체 지향, 함수, 일반화 프로그래밍을 포함한 메타프로그래밍 개념까지 지원하는 언어로 자리를 잡았습니다 <br>
복잡해 보이지만 **C++를 상관 관계가 있는 여러 언어들의 연합체(Federation)** 으로 생각하면 쉽게 생각할 수 있습니다. <br>
즉, C++를 제대로 이해하기 위해선, 여러 개의 **하위 언어(Sub-Language)** 를 제공하는걸 기억하면 쉽게 기억할 수 있습니다. 

1. C언어 → C++는 여전히 C언어로 기반으로한 언어이기에 C언어와 상당히 많이 호환이 됨. 그래서 필자는 C++을 C언어의 DLC or 확장판 언어라고 생각합니다.
2. 객체지향 개념의 C++  →  **클래스를 쓰는 C**에 관한 모든 부분이 해당 됩니다. 즉, 클래스의 생성자, 소멸자, 캡슐화, 상속, 다형성, 가상 함수 및 동적 바인딩 등등....
3. 템플릿 C++  → C++의 일반화 프로그래밍으로, C++에서 매우 많이 전방위적으로 사용됨. 또한 또 파생되어 템플릿 메타 프로그래밍(Template metaprogramming, TMP)까지 생겼습니다.
4. STL  → Standard Template Library으로, 컨테이너(Container), 반복자(Iteraotr), 알고리즘(Algorithm), 함수 객체(Function Object)가 얽혀 돌아가는 것을 규악으로 삼고 있으나, 템플릿과 라이브러리는 다른 아이디어를 중심으로 만들어질 수 있습니다.

가장 중요한 것은, 한 하위 언어에서  → 다른 하위 언어로 옮겨가면서 대응 전략이 바뀌어도 당황하지말고 그에 맞는 전략을 선택해야 한다. <br>
예를 들어 C 스타일로, call by value가 call by reference보다 대개 효율이 더 좋을 수 있으나 객체 C++에서는 사용자 정의 생성자/소멸자가 있어서 상수 객체 참조자에 의한 전달(Pass-by-reference-to-const)방식이 더 좋을 효율을 보입니다. 좀더 설명 하자면, C언어에서 call by value는 단순히 스택에 값(혹은 레지스터)을 복사하는 개념이라서 구조체 같은 큰 자료형이 아니라면, 값 전달이 참조(포인터 전달)보다 더 효율적일 때가 많습니다. 또한 C에는 생성자/소멸자가 없으므로 추가 비용이 없음 → 값 전달 시 **복사 비용**만 고려하면 되기 때문에, 작은 타입은 값 전달이 대체로 더 빠르다라는 규칙이 통합니다. <br> 
반면에 C++에서는 사용자 정의 생성자/소멸자 개념이 있어, 객체를 값으로 전달하면 **복사 생성자**가 호출될 수 있고, 이 복사 비용은 단순 메모리 복사(struct 복사)보다 매우 비싸다. 또한, 지역 임시 객체가 생기면 소멸자까지 호출되고. Pass-by-reference-to-const (const T&)는 복사 생성자/소멸자를 건너뛰기 때문에 **비용 0** 에 가깝고, 원본을 수정하지 않겠다는 보장도 있으므로 안전하여 보통 **큰 객체 인자** 전달 시 const T&가 권장됩니다. <br> 
특히 템플릿 C++에서는 객체의 타입조차 알 수 없어 이러한 방식이 더 두드러지지만, 반대로 STL로 넘어오면 또 전세가 역전된다. 즉 STL에서는 반복자와 함수 객체가 C의 포인터를 본떠 만든 것이라, STL에서는 반복자 및 함수 객체에 대해서는 값 전달에 대한 규칙이 다시 제 힘을 발휘하게 됨. 

결론 : C++는 한 가지 프로그래밍 규칙 아래 똘똘 뭉친 통합 언어(Unified Language)가 아니라 위의 4가지 하위 언어들의 **연합체**로 구성되어 있습니다. 

### 1.2 #define을 쓰려면 const, enum, inline을 생각하자
가급적 선행 처리자보다 컴파일러를 더 가까이 하자로 C++에서 #define은 일부가 아닌것으로 취급 될 수 있음. 

예를 들어 

```cpp
#define ASPECT_RATIO 1.653
```

로 정의했을 때, 프로그래머는 ASPECT_RATIO라는 Symbolic name이 보이지만 컴파일에서는 안 보여서 선행처리자가 밀어버리고 숫자 상수로 바꾸기 때문임 
이러한 문제는 Symbolic Debugger에서도 발생할 가능성이 있는데 이러한 방법을 해결하는건 매크로 대신에 상수로 정의 하는 것임. 

```cpp
const double aspectRatio = 1.653;
```
이러면 상수 타입의 데이터이기 때문에 컴파일러에도 보이고, Symbolic Table에도 들어감. 즉, 매크로로 정의하면 ASPECT_RATIO가 등장하는 곳은 선행처리자로 의해 숫자 1.653으로 바뀌어 1.653의 사본이 등장하는 만큼 들어가지만 aspectRatio는 여러번 쓰더라도 사본은 딱 1개만 생기기 때문에 더 효율적임 

**#deifne을 상수로 교체할 때 주의할 점 2가지가 존재함** <br>
1. 상수 포인터(constant potiner)로 정의하는 경우
   상수 정의는 주로 헤더 파일에 작성하기 때문에, 포인터와 포인터가 가리키는 대상(값)까지 const로 선언하는 것이 보통임
   그렇게 때문에 밑에 있는 코드처럼 const를 2번 작성 해야함
   
```cpp
const char* const myName = "Vi dan";
const std::string myName("Vi dan");
```

참고로 문자열 상수를 쓸대 string 객체를 사용하는 것이 대체적으로 좋음 

2. 클래스 멤버로 정의하는 경우
   클래스 상수를 정의하는 경우 인데, 어떤 상수의 유효범위를 클래스로 한정하고자 할 때는 그 상수를 멤버로 만들고, 사본 개수가 한 개를 넘지 못하게 하고 싶으면 static 멤버로 선언 하면 됨 <br>
   참고로, 정적 멤버로 만들어지는 정수류의 타입 (int, char, short, long, long long, bool 등)의 클래스 내부 상수는 예외.<br>
   즉, 이들에 대해 주소를 취하지 않는 한, 정의 없이 선언만 해도 아무 문제거 없음. <br>
   오래된 컴파일러나 문법인 경우는 안될 수도 있는데, 이때는 초기값을 상수 **정의** 시점에 줘야함.

나열자 둔갑술(enum hack)
이 기법은 나열자(enumerator)의 타입의 값은 int가 놓일 곳에 쓸 수 있다는 것을 뜻함.
동작 방식은 const보단 define쪽에 가까우며, 제대로 만들어진 컴파일러는 정수 타입의 const 객체에 대해 저장공간을 준비하지 않지만, 반대로 편찮게 만들어진 컴파일러에서는 동작을 할 수 있기 때문에, 메모리를 낭비하고 싶지 않을 때 방법으로 추천함 
또  다른 이유는 템플릿 메타프로그래밍의 핵심 기법이기 때문임. (추후 설명)

#define의 오용 
매크로 함수에서 주로 오용하는 경우가 많이 발생하는데, 이는 '함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않는 매크로를 구현'하는 것이기 때문임. <br>
그렇기 때문에 인라인 함수에 대한 템플릿으로 매크로의 효율을 유지하면서 함수의 동작 방식 및 타입 안정성을 취할 수 있음

즉, 선행처리자인 define 보다는 **enum, const, inline**을 우선적으로 생각하는게 중요함 

-----------------------------------------------

### 1.3 const
