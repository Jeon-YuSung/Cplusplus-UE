# Ch1. C++의 법을 따르자.

효과적으로 활용하기 위해선 C++는 C++스타일답게 사용하자. 
  
  - [1.1 C++를 언어들의 연합체로 바라보는 안목은 필수](###-1.1-C++를-언어들의-연합체로-바라보자)
  - 1.2 #define을 쓰려거든 const, enum, inline을 떠올리자
  - 1.3 낌새만 보이면 const를 들이대 보자
  - 1.4 객체를 사용하기 전에 반드시 그 객체를 초기화하자

코드에서 using namesapce std;를 사용했다고 가정했기 때문에 std::는 제외함 

-------------------------------------------------

### 1.1 C++를 언어들의 연합체로 바라보자
c++는 처음에 C with classes로 시작한 언어임, 즉 절차 지향 언어인 C언어에 클래스를 입혀 객체 지향로 진화. <br>
과거와 달리 요즘은 많이 발전하여 예외, 템플릿 프로그램 설계, STL으로 **확장성**이 생김 <br>
현대의 C++는 **다중패러다임 프로그래밍 언어(Multiparadigm Programming Language)** 이며, 절차적인 프로그래밍을 베이스하여 **객체지향, 함수, 일반화 프로그래밍(템플맀)을 포함한 메타프로그래밍 개념까지 지원하는 언어**로 자리 잡음. <br>
복잡해 보이지만 **C++를 상관 관계가 있는 여러 언어들의 연합체(Federation)** 임 <br>
즉, C++를 제대로 이해하기 위해선, 여러 개의 **하위 언어(Sub-Language)** 로 구성되어 연합한걸로 생각하면 됨 <br>

1. C언어 → C++는 여전히 C언어로 기반으로한 언어이기에 C언어와 상당히 많이 호환이 됨. 쉽게 C++을 C언어의 DLC or 확장판 언어 
2. 객체지향 개념의 C++ → **클래스를 쓰는 C**에 관한 모든 부분이 해당. 즉, 클래스의 생성자, 소멸자, 캡슐화, 상속, 다형성, 가상 함수 및 동적 바인딩 등등....
3. 템플릿 C++ → C++의 일반화 프로그래밍으로, C++에서 매우 많이 전방위적으로 사용됨. 또한 파생되어 템플릿 메타 프로그래밍(Template metaprogramming, TMP)까지 생김.
4. STL  → Standard Template Library으로, 컨테이너(Container), 반복자(Iteraotr), 알고리즘(Algorithm), 함수 객체(Function Object)가 얽혀 돌아가는 것을 규악으로 삼고 있으나, 템플릿과 라이브러리는 다른 아이디어를 중심으로 만들어질 수 있음. 

가장 중요한 것은, 한 하위 언어에서  → 다른 하위 언어로 옮겨가면서 대응 전략이 바뀌어도 당황하지말고 그에 맞는 전략을 선택해야 한다는 것. <br>
예를 들어 C 스타일로, call by value가 call by reference보다 대개 효율이 더 좋을 수 있으나 객체 C++에서는 **사용자 정의 생성자/소멸자가 있어서 상수 객체 참조자에 의한 전달(Pass-by-reference-to-const)방식**이 더 좋을 효율을 보일 수 있음.
C언어에서 call by value는 단순히 스택에 값(혹은 레지스터)을 **복사**하는 개념이라서 구조체 같은 큰 자료형이 아니라면, 값 전달이 참조(포인터 전달)보다 더 효율적일 때가 많음. <br>
또한 C에는 생성자/소멸자가 없으므로 추가 비용이 없음 → 값 전달 시 **복사 비용**만 고려하면 되기 때문에, 작은 타입은 값 전달이 대체로 더 빠르다라는 규칙이 통함. <br> 
반면에 C++에서는 사용자 정의 생성자/소멸자 개념이 있어, 객체를 값으로 전달하면 **복사 생성자**가 호출될 수 있고, 이 복사 비용은 단순 메모리 복사(struct 복사)보다 매우 비싸다. 또한, 지역 임시 객체가 생기면 소멸자까지 호출되고. Pass-by-reference-to-const (const T&)는 복사 생성자/소멸자를 건너뛰기 때문에 **비용 0** 에 가깝고, 원본을 수정하지 않겠다는 보장도 있으므로 안전하여 보통 **큰 객체 인자** 전달 시 const T&가 권장됨 <br> 
특히 템플릿 C++에서는 객체의 타입조차 알 수 없어 이러한 방식이 더 두드러지지만, 반대로 STL로 넘어오면 또 전세가 역전됨. <br>
즉 STL에서는 반복자와 함수 객체가 **C의 포인터를 본떠 만든 것**이라, STL에서는 반복자 및 함수 객체에 대해서는 값 전달에 대한 규칙이 다시 제 힘을 발휘하게 됨. 

----------------------------------------------------------------------------

### 1.2 #define을 쓰려면 const, enum, inline을 생각하자
가급적 선행 처리자보다 컴파일러를 더 가까이 하자로 C++에서 #define은 일부가 아닌것으로 취급 될 수 있음. 

예를 들어 

```cpp
#define ASPECT_RATIO 1.653
```
로 정의했을 때, 프로그래머는 ASPECT_RATIO라는 Symbolic name이 보이지만 컴파일에서는 안 보여서 선행처리자가 밀어버리고 숫자 상수로 바꾸기 때문임 
이러한 문제는 Symbolic Debugger에서도 발생할 가능성이 있는데 이러한 방법을 해결하는건 매크로 대신에 상수로 정의 하는 것임. 

```cpp
const double aspectRatio = 1.653;
```
이러면 상수 타입의 데이터이기 때문에 컴파일러에도 보이고, Symbolic Table에도 들어감. 즉, 매크로로 정의하면 ASPECT_RATIO가 등장하는 곳은 선행처리자로 의해 숫자 1.653으로 바뀌어 1.653의 사본이 등장하는 만큼 들어가지만 aspectRatio는 여러번 쓰더라도 사본은 딱 1개만 생기기 때문에 더 효율적임 

**#deifne을 상수로 교체할 때 주의할 점 2가지가 존재함** <br>
1. 상수 포인터(constant potiner)로 정의하는 경우
   상수 정의는 주로 헤더 파일에 작성하기 때문에, 포인터와 포인터가 가리키는 대상(값)까지 const로 선언하는 것이 보통임
   그렇게 때문에 밑에 있는 코드처럼 const를 2번 작성 해야함
   
```cpp
const char* const myName = "Vi dan";
const std::string myName("Vi dan");
```

참고로 문자열 상수를 쓸대 string 객체를 사용하는 것이 대체적으로 좋음 

2. 클래스 멤버로 정의하는 경우
   클래스 상수를 정의하는 경우 인데, 어떤 상수의 유효범위를 클래스로 한정하고자 할 때는 그 상수를 멤버로 만들고, 사본 개수가 한 개를 넘지 못하게 하고 싶으면 static 멤버로 선언 하면 됨 <br>
   참고로, 정적 멤버로 만들어지는 정수류의 타입 (int, char, short, long, long long, bool 등)의 클래스 내부 상수는 예외.<br>
   즉, 이들에 대해 주소를 취하지 않는 한, 정의 없이 선언만 해도 아무 문제가가 없음. <br>
   오래된 컴파일러나 문법인 경우는 안될 수도 있는데, 이때는 초기값을 상수 **정의** 시점에 줘야함.

- 나열자 둔갑술(enum hack)
이 기법은 나열자(enumerator)의 타입의 값은 int가 놓일 곳에 쓸 수 있다는 것을 뜻함.
동작 방식은 const보단 define쪽에 가까우며, 제대로 만들어진 컴파일러는 정수 타입의 const 객체에 대해 저장공간을 준비하지 않지만, 반대로 편찮게 만들어진 컴파일러에서는 동작을 할 수 있기 때문에, 메모리를 낭비하고 싶지 않을 때 방법으로 추천함 
또  다른 이유는 템플릿 메타프로그래밍의 핵심 기법이기 때문임. (추후 설명)

#define의 오용 
매크로 함수에서 주로 오용하는 경우가 많이 발생하는데, 이는 '함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않는 매크로를 구현'하는 것이기 때문임. <br>
그렇기 때문에 인라인 함수에 대한 템플릿으로 매크로의 효율을 유지하면서 함수의 동작 방식 및 타입 안정성을 취할 수 있음

즉, 선행처리자인 #define 보다는 **enum, const, inline**을 우선적으로 생각하는게 중요함 

-----------------------------------------------

### 1.3 const
const → 의미적인 제약, 즉 const로 선언한 객체나 자료형은 변경이 불가함. 값은 불변해야 함 <br>
const는 여러곳에서 쓸 수 있음, 클래스 외부, 전역, 네임스페이스 유효범위의 상수 선언(정의), 파일, 함수, 블록의 유호범위에서 선언한 static 등등...

```cpp
char greeting[] = {"Hello"};

char *p = greeting; // 비상수 포인터, 비상수 데이터

const char *p = greeting; //비상수 포인터, 상수 데이터

char* const p = greeting; //상수포인터, 비상수 데이터

const char* const p = greeting //상수 포인터, 상수 데이터

void f1(const Widget *pw); //f1함수는 상수 Widget 객체에 대한 포인터를 매개변수로 취함
void f2(Widget const *pw); //f2도 f1와 같음 
```

const가 *의 왼쪽에 있으면 포인터가 가리키는 대상이 상수 <br>
const가 *의 오른쪽에 있으면 포인터 자체가 상수 <br>
const가 양옆에 선언되면 포인터가 가리키는 대상, 포인터 다 상수 

참고로 포인터가 가리키는 대상을 상수로 만들 때, 타입 앞에 const를 붙이거나, 타입의 뒤쪽이자 * 표의 앞에 const를 붙이는건 코딩 스타일의 차이이지, 의미적인 차이는 전혀 없다.  <br>
→ 받아들이는 매개변수 타입이 모두 똑같기 때문임 

STL의 Iterator는 포인터를 본 떠서 만든거라, 기본적인 동작 원리가 T* 포인터와 흡사함. <br>
어떤 iterator를 const로 선언하는 것은 포인터를 상수로 선언하는 것 (T* const pointer)와 같고, iterator는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않지만, iterator **가리키는 대상 자체는 변경이 가능하다** 만약 변경 불가인 객체를 가리키는 iterator(const T* pointer의 STL 대응물)이 필요하면 const_iterator를 쓰면 된다. 

```cpp
const vector<int>::iterator iter = vec.begin(); //T* const처럼 동작 
*iter = 10; // 가능, iter가 가리키는 대상을 변경
++iter; //error, iter는 상수이기 때문

vector<int>::const_iterator iter2 = vec.begin(); //iter2도 const T*처럼 동작
*iter2 = 10; // error, *iter2는 상수라 안됨
++iter2; //가능 iter2를 변경하기 때문에.
```

const를 **함수 선언**에서 사용할 경우 매우 유용하게 사용 가능 <br>
함수 반환 값, parameter, 멤버 함수 앞에, 함수 전체에 대해 const를 사용 가능 
함수 반환 값을 상수로 정해주면 안전성이나 효율을 챙기고, 사용자측의 에러 돌발 상황을 줄이는 효과를 볼 수 있음. 

```cpp
class Rational {....};

const Rational operator* (const Rational* lhs, const Rational& rhs);

```

- 상수 멤버 함수 
멤버 함수에 붙는 const의 역할은 **해당 멤버 함수가 상수 객체에 대해 호출될 함수**를 알려주는 것임. <br>
이는 매우 중요한데 그 이유는 2가지임 <br>
1. 클래스의 인터페이스를 이해를 돕기 위해서 → 객체를 변경할 수 있는 함수, 변경할 수 없는 함수가 무엇인가를 사용자쪽에서 알고 있어야 한다는 것 
2. 코드의 효율을 높이기 위해 상수 객체를 사용할 수 있게 하는 것 → 객체 전달을 **상수 객체에 대한 참조자(Reference-to-const)** 로 진행하기 때문인데, 이 기법을 제대로 사용할려면 상수 상태로 전달된 객체를 조작할 수 있는 const 멤버 함수, 즉 **상수 멤버 함수**가 준비되어 있어야 함.

const 키워드가 있고 없고의 차이만 있는 멤버 함수 들은 **오버로딩**이 가능하다.

실제로 상수 객체가 생기는 경우는 1. 상수 객체에 대한 포인터 혹은 2. 상수 객체에 대한 참조자로 객체가 전달될 때임.

이제 어떤 멤버 함수가 상수 멤버(const)라는 것은 어떤 의미인지 알아보자 <br>
이 개념에 2개의 매우 거대한 개념이 자리 잡고 있는데 1. 비트수준 상수성(bitwise constness) or 물리적 상수성(physical constness) 2. 논리적 상수성(logical constness)임. 
 1. 비트수준 상수성(bitwise constness) or 물리적 상수성(physical constness)
    → 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 **const** 임을 인정하는 개념 (단, 정적 멤버열자 둔갑술(enum hack)
이 기법은 나열자(enumerator)의 타입의 값은 int가 놓일 곳에 쓸 수 있다는 것을 뜻함.
동작 방식은 const보단 define쪽에 가까우며, 제대로 만들어진 컴파일러는 정수 타입의 const 객체에 대해 저장공간을 준비하지 않지만, 반대로 편찮게 만들어진 컴파일러에서는 동작을 할 수 있기 때문에, 메모리를 낭비하고 싶지 않을 때 방법으로 추천함 
또  다른 이유는 템플릿 메타프로그래밍의 핵심 기법이기 때문임. (추후 설명)

#define의 오용 
매크로 함수에서 주로 오용하는 경우가 많이 발생하는데, 이는 '함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않는 매크로를 구현'하는 것이기 때문임. <br>
그렇기 때문에 인라인 함수에 대한 템플릿으로 매크로의 효율을 유지하면서 함수의 동작 방식 및 타입 안정성을 취할 수 있음

즉, 선행처리자인 #define 보다는 **enum, const, inline**을 우선적으로 생각하는게 중요함 

-----------------------------------------------

### 1.3 const
const → 의미적인 제약, 즉 const로 선언한 객체나 자료형은 변경이 불가함. 값은 불변해야 함 <br>
const는 여러곳에서 쓸 수 있음, 클래스 외부, 전역, 네임스페이스 유효범위의 상수 선언(정의), 파일, 함수, 블록의 유호범위에서 선언한 static 등등...

```cpp
char greeting[] = {"Hello"};

char *p = greeting; // 비상수 포인터, 비상수 데이터

const char *p = greeting; //비상수 포인터, 상수 데이터

char* const p = greeting; //상수포인터, 비상수 데이터

const char* const p = greeting //상수 포인터, 상수 데이터

void f1(const Widget *pw); //f1함수는 상수 Widget 객체에 대한 포인터를 매개변수로 취함
void f2(Widget const *pw); //f2도 f1와 같음 
```

const가 *의 왼쪽에 있으면 포인터가 가리키는 대상이 상수 <br>
const가 *의 오른쪽에 있으면 포인터 자체가 상수 <br>
const가 양옆에 선언되면 포인터가 가리키는 대상, 포인터 다 상수 

참고로 포인터가 가리키는 대상을 상수로 만들 때, 타입 앞에 const를 붙이거나, 타입의 뒤쪽이자 * 표의 앞에 const를 붙이는건 코딩 스타일의 차이이지, 의미적인 차이는 전혀 없다.  <br>
→ 받아들이는 매개변수 타입이 모두 똑같기 때문임 

STL의 Iterator는 포인터를 본 떠서 만든거라, 기본적인 동작 원리가 T* 포인터와 흡사함. <br>
어떤 iterator를 const로 선언하는 것은 포인터를 상수로 선언하는 것 (T* const pointer)와 같고, iterator는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않지만, iterator **가리키는 대상 자체는 변경이 가능하다** 만약 변경 불가인 객체를 가리키는 iterator(const T* pointer의 STL 대응물)이 필요하면 const_iterator를 쓰면 된다. 

```cpp
const vector<int>::iterator iter = vec.begin(); //T* const처럼 동작 
*iter = 10; // 가능, iter가 가리키는 대상을 변경
++iter; //error, iter는 상수이기 때문

vector<int>::const_iterator iter2 = vec.begin(); //iter2도 const T*처럼 동작
*iter2 = 10; // error, *iter2는 상수라 안됨
++iter2; //가능 iter2를 변경하기 때문에.
```

const를 **함수 선언**에서 사용할 경우 매우 유용하게 사용 가능 <br>
함수 반환 값, parameter, 멤버 함수 앞에, 함수 전체에 대해 const를 사용 가능 
함수 반환 값을 상수로 정해주면 안전성이나 효율을 챙기고, 사용자측의 에러 돌발 상황을 줄이는 효과를 볼 수 있음. 

```cpp
class Rational {....};

const Rational operator* (const Rational* lhs, const Rational& rhs);

```

- 상수 멤버 함수 
멤버 함수에 붙는 const의 역할은 **해당 멤버 함수가 상수 객체에 대해 호출될 함수**를 알려주는 것임. <br>
이는 매우 중요한데 그 이유는 2가지임 <br>
1. 클래스의 인터페이스를 이해를 돕기 위해서 → 객체를 변경할 수 있는 함수, 변경할 수 없는 함수가 무엇인가를 사용자쪽에서 알고 있어야 한다는 것  <br>
2. 코드의 효율을 높이기 위해 상수 객체를 사용할 수 있게 하는 것 → 객체 전달을 **상수 객체에 대한 참조자(Reference-to-const)** 로 진행하기 때문인데, 이 기법을 제대로 사용할려면 상수 상태로 전달된 객체를 조작할 수 있는 const 멤버 함수, 즉 **상수 멤버 함수**가 준비되어 있어야 함.

const 키워드가 있고 없고의 차이만 있는 멤버 함수 들은 **오버로딩**이 가능하다.

실제로 상수 객체가 생기는 경우는 1. 상수 객체에 대한 포인터 혹은 2. 상수 객체에 대한 참조자로 객체가 전달될 때임.

이제 어떤 멤버 함수가 상수 멤버(const)라는 것은 어떤 의미인지 알아보자 <br>
이 개념에 2개의 매우 거대한 개념이 자리 잡고 있는데 1. 비트수준 상수성(bitwise constness) or 물리적 상수성(physical constness) 2. 논리적 상수성(logical constness)임.  <br>
  1. 비트수준 상수성(bitwise constness) or 물리적 상수성(physical constness)  
    → 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 **const** 임을 인정하는 개념 (단, 정적(static) 멤버 제외)  <br>
    즉, 그 객체를 구성하는 비트 중 그 어떤 것도 바꾸면 안된다는 개념으로, 상수 멤버 함수는 그 함수가 호출된 객체의 어떤 비정적 멤버도 수정할 수 없음.  <br>
    근데 "제대로 const"가 동작하지 않아도, 비트수준 상수성 검사를 통과하는 멤버 함수들이 있음.... <br>
    어떤 포인터가 가리키는 대상을 수정하는 멤버 함수들 중 상당수가 속하지만, 그 포인터가 객체의 멤버로 들어 있는 한 이 함수는 비트수준 상수성을 갖는 것으로 판별되어, 컴파일러도 가만히 있음.  <br>
  2. 논리적 상수성(logical constness)
    → 어떤 값으로 초기화된 상수 객체를 하나 만들어 놓고 이 곳에 상수 멤버 함수를 호출했더니 값이 변해버리는 상황을 보완하는 대체 개념으로 나온 것이 논리적 상수성임.  <br>
    상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아닌 일부 몇 비트 정도는 바꿀 수 있되, 그걸 사용자측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다는 것임 

- 상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법은 책을 참고

- 정리
    + const는 여러 곳(포인터, 반복자, 참조자, 매개변수...)등등 여러곳에서 쓰니 잘 알아두자
    + const를 사용하면 컴파일러가 사용상의 에러를 잡는데 도움을 주고, 어떤 유효범위에 있는 객체나 함수의 매개변수 및 반환 타입, 멤버 함수에도 붙을 수 있음.
    + 컴파일러 쪽에서 비트수준 상수성을 지켜야 하지만, 우리는 논리적(개념적인) 상수성을 사용해서 프로그래밍 해야함. 
    + 상수 멤버 및 비 상수 멤버 함수가 기능적으로 **서로 똑같이 구현**되어 있을 경우, 코드 중복을 피하자 → 이때 비상수 버전이 상수 버전을 호출하도록 만들면 해결.
  
    
-------------------------------------------------

### 1.4 객체를 사용하기전에는 반드시 객체를 초기화하자

```cpp
int x;
```
어떤 상황에서는 x의 값이 확실히 0으로 초기화 되지만, 어떤 상황에서는 그것이 보장되지 않음.

```cpp

class Point{
int x, y;
};
....
Point p; 

```

위의 코드처럼 클래스에서도 초기화를 안하면 p의 데이터 멤버 역시 어떤 상황에서 초기화를 보장되지만 또 어쩔 때는 안됨. <br>
**초기화되지 않은 값을 읽도록 내비두면 정의되지 않은 동작이 그대로 흘러 나오는 경우**가 있음  <br>
IDE(플랫폼)에 따라 미초기화 객체를 읽기만 해도 프로그램이 멈추는 경우도 있지만, 대부분 경우에는 적당히 무작위 비트의 값을 읽고, 객체의 내부에 이상한 값을 가짐  <br>
초기화에 런타임 비용이 소모될 수 있는 상황이라면 값이 초기화된다는 보장이 없음.  <br>
Array은 각각의 원소가 확실히 초기화된다는 보장이 없지만, Vector에서는 초기화된다는 보장을 가지고 있음.  <br> 
가장 좋은 방법은 **모든 객체를 사용하기전에 항상 초기화**작업을 해야함  <br>

```cpp
int x = 0; // int 직접 초기화
const char * text = "A C-style string"; // 포인터 직접 초기화
double d; // 입력 스트름에서 읽음으로써  초기화 진행 
cin >> d;
```

기본 제공 타입으로 만들어진 비멤버 객체를 제외하고 나면 C++에서 대부분 초기화는 생성자로 귀결됨.  <br>
생성자에서 지켜야할 규칙은 **그 객체의 모든 것을 초기화**하는 것임.  <br>

주의할 점 

**대입(Assignment)와 초기화(initialization)을 구분하자** 

```cpp

class PhoneNumber{....};

//ABEntry = "Address Book Entry"

class ABEntry{
private:
  stirng theName;
  string theAddress;
  list<PhoneNumber> thePhones;
  int numTimesConsulted;
 
public:
  ABEntry(const string& name, const string& address, const list<PhoneNumber>& phones)
};

//초기화가 아닌 대입을 하는 부분
ABEntry(const string& name, const string& address, const list<PhoneNumber>& phones){
  theName = name;
  theAddress = address;
  thePhones = phones;
  numTimesConsulted = 0;
}
```
위의 코드는 초기화가 아니 대입을 한 코드이다. <br>
이제 초기화를 하는 다음 코드를 보자 

```cpp
ABEntry::ABEntry(const string& name, const string& address, const list<PhoneNumber>& phones)
  : theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) {....}

//매개변수가 없는 생성자인 경우
ABEntry::ABEntry() :  theName(), theAddress(), thePhones(), numTimesConsulted(0)
{....}

```
C++에서는 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 전에 초기화되어야한다고 명시되어 있음. <br>
초기화 리스트에 들어가는 Argument는 바로 데이터 멤버에 대한 생성자의 Argument로 쓰이기 때문임  <br>
기본 생성자 호출 후에 복사 대입 연산자를 연달아 호출하는 이전의 방법 보다는 복사 생성자를 한 번 호출하는 쪽이 더 효율적  <br>
기본 자료형의 초기화 리스트로 넣는 일이 선택이 아니라 **의무**일 경우가 있는데, 이는 상수이거나 참조자로 되어있는 데이터 멤버의 경우엔 반드시 초기화를 해야히기 때문임. <br>
→ 상수와 참조나는 대입 자체가 불가능 하기에  <br>
아니면 대입으로 초기화가 가능한 데이터 멤버들은 초기화리스트가 아닌 별도의 함수로 옮기는 방법도 있음.  <br>

**<중요> 객체를 구성하는 데이터의 초기화 순서** <br>
1.부모 클래스(기본, 슈퍼)는 자식 클래스(파생, 하위)보다 먼저 초기화되고,  <br>
2. 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화 → 선언된 순서와 같아, 멤버 초기화 리스트에 이들이 넣어진 순서가 다르더라도, 초기화 순서는 그대로임. <br>
(클래스에 선언한 순서와 동일하게 맞춰서 멤버 초기화 리스트에 넣자. 이는 잠재적인 동작 버그를 피하자는 의미임)

반대로 비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다.  <br>
(비지역 정적 객체(non-local static object)는 프로그램 전역 또는 네임스페이스 유효범위에서 선언된 객체을 의미하며, 개별 번역 단위(separate translation unit)는 각 소스파일이나 헤더파일 등 컴파일러가 독립적으로 컴파일 하는 단위를 의미함)

- 정적 객체 (Static Object)
Static Object란 → 자신이 생성된 시점부터 프로그램이 끝날 때 까지 살아 있는 객체 <br>
(스택 객체나 힙 객체는 정적 객체가 불가능)
즉, Static Object는 **프로그램이 끝날 때 자동으로 소멸됨**, 

1. 전역 객체(Global Object)
2. 네임스페이스 유효 범위에서 정의된 객체
3. 클래스 안에서 static으로 선언된 객체
4. 함수 안에서 static으로 선언된 객체
5. 파일 유효범위에서 static으로 정의된 객체
이 중에서 함수 안에 있는 Static Object는 지역 정적 객체(Local Static Object), 나머지는 비지역 정적 객체(Non-local Static Object)라고 함. <br>

- 번역 단위(Translation Unit)
Translation Unit란 → 컴파일을 통해 하나의 목적 파일(Object File)을 만드는 바탕이되는 Source Code.
별도로 컴파일된 소스 파일이 2개 이상 있으며, 각 소스파일에 비지역 정적 객체(Non-local Static Object)가 1개 이상 들어있고, 한쪽 번역 단위에서 다른 쪽 번역 단위의 객체를 사용할 경우, 이 객체가 초기화되어 있지 않을 수 있다는 것임 <br>
즉, 서로 다른 번역 단위에서 정의된 비지역 정적 객체(Non-local Static Object)들 사이의 상대적인 초기화 순서는 정해져 있지 않으므로, 유의하면서 설계해야 하며, 이를 피하기위해선 **비지역 정적 객체(Non-local Static Object) →  지역 정적 객체(Local Static Object)** 로 바꾸면 됨. (이는 GoF 패턴의 Singleton Pattern의 전형적인 구현 양식임)

추가적으로, 비지역 정적 객체(Non-local Static Object)를 직접 접근하지 않고, 지역 정적 객체(Local Static Object)에 대한 참조자를 반환하는 쪽이라면, 그 참조자는 **반드시 초기화된 객체를 참조하도록 맞춰야함** 그리고 **지역 객체 참조자 반환 함수**를 호출할 일이 없다면, 해당 객체의 생성/소멸 cost가 발생하지 않도록 막아야함.

p.s 프로그래밍에서 번역이란? <br>
사람이 읽는 소스 코드의 언어를 컴퓨터가 이해할 수 있도록 기계어로 번역한다는 의미임 

```cpp
class FileSystem{....};

// 비지역 정적 객체를 함수로 대신 함, 클래스 안에 정적 멤버로 들어가 됨. 
FileSystem& tfs(){
  static FileSystem fs; //지역 정적 객체를 정의 및 초기화
  return fs;  //fs 객체에 대한 참조자를 반환.
}

class Directory{...};

// 이전과 동일한데, tfs의 참조자였던 것이 지금은 tfs()함수로 바뀌었다는 것만 다름.
Directory::Directory( params ){
  ...
  size_t disk = tfs().numDisks();
  ...
}

//tempDir라는 비지역 정적 객체를 함수로 대신함, Directory 클래스의 정적멤버로 들어가도 됨. 
Directory& tempDir(){
  static Directory td; //지역 정적 객체를 정의 및 초기화
  return td; // 참조자 반환.
}
```

어떤 객체가 초기화되기 전에 그 객체를 사용하는 일이 생기지 않도록 예방하려면 <br>
1. 멤버가 아닌 기본 제공 타입 객체는 직접 초기화
2. 객체의 모든 부분에 대한 초기화에는 멤버 초기화 리스트를 사용
3. 별개의 번역 단위에 정의된 비지역 정적 객체에 영향을 끼치는 불확실한 초기화 순서를 염두해두고, 불확실성을 피하면서 프로그래밍

- 정리
  + 기본 제공 타입의 객체는 직접 초기화 할 것, 경우에 따라 자동으로 되기도하고 안되기도 하기 때문에 
  + 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기하지말고 **멤버 초기화 리스트**를 사용할 것, 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 **클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열 할 것** <br>
  + 여러 번역 단위에 있는 비지역 정적 객체(Non-local Static Object)의 **초기화 순서 문제는 피해서 설계** 할 것, 비지역 정적 객체(Non-local Static Object)를 지역 정적 객체(Local Static Object)로 바꾸면 해결 됨 
