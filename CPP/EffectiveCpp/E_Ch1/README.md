# Ch1. C++의 법을 따르자.

효과적으로 활용하기 위해선 C++는 C++스타일답게 사용하자. 
  
-------------------------------------------------

### <1.1 C++를 언어들의 연합체로 바라보자>
c++는 처음에 C with classes로 시작한 언어임, 즉 절차 지향 언어인 C언어에 클래스를 입혀 객체 지향 언어로 변모하였습니다. <br>
과거와 달리 요즘은 많이 발전하여 예외, 템플릿 프로그램 설계, STL으로 **확장성**과 사고방식을 바꿔 주었고, <br>
현재의 C++는 **다중패러다임 프로그래밍 언어(Multiparadigm Programming Language)이며, 절차적인 프로그래밍을 베이스하여 객체 지향, 함수, 일반화 프로그래밍을 포함한 메타프로그래밍 개념까지 지원하는 언어로 자리를 잡았습니다 <br>
복잡해 보이지만 **C++를 상관 관계가 있는 여러 언어들의 연합체(Federation)** 으로 생각하면 쉽게 생각할 수 있습니다. <br>
즉, C++를 제대로 이해하기 위해선, 여러 개의 **하위 언어(Sub-Language)** 를 제공하는걸 기억하면 쉽게 기억할 수 있습니다. 

1. C언어 → C++는 여전히 C언어로 기반으로한 언어이기에 C언어와 상당히 많이 호환이 됨. 그래서 필자는 C++을 C언어의 DLC or 확장판 언어라고 생각합니다.
2. 객체지향 개념의 C++  →  **클래스를 쓰는 C**에 관한 모든 부분이 해당 됩니다. 즉, 클래스의 생성자, 소멸자, 캡슐화, 상속, 다형성, 가상 함수 및 동적 바인딩 등등....
3. 템플릿 C++  → C++의 일반화 프로그래밍으로, C++에서 매우 많이 전방위적으로 사용됨. 또한 또 파생되어 템플릿 메타 프로그래밍(Template metaprogramming, TMP)까지 생겼습니다.
4. STL  → Standard Template Library으로, 컨테이너(Container), 반복자(Iteraotr), 알고리즘(Algorithm), 함수 객체(Function Object)가 얽혀 돌아가는 것을 규악으로 삼고 있으나, 템플릿과 라이브러리는 다른 아이디어를 중심으로 만들어질 수 있습니다.

가장 중요한 것은, 한 하위 언어에서  → 다른 하위 언어로 옮겨가면서 대응 전략이 바뀌어도 당황하지말고 그에 맞는 전략을 선택해야 한다. <br>
예를 들어 C 스타일로, call by value가 call by reference보다 대개 효율이 더 좋을 수 있으나 객체 C++에서는 사용자 정의 생성자/소멸자가 있어서 상수 객체 참조자에 의한 전달(Pass-by-reference-to-const)방식이 더 좋을 효율을 보입니다. 좀더 설명 하자면, C언어에서 call by value는 단순히 스택에 값(혹은 레지스터)을 복사하는 개념이라서 구조체 같은 큰 자료형이 아니라면, 값 전달이 참조(포인터 전달)보다 더 효율적일 때가 많습니다. 또한 C에는 생성자/소멸자가 없으므로 추가 비용이 없음 → 값 전달 시 **복사 비용**만 고려하면 되기 때문에, 작은 타입은 값 전달이 대체로 더 빠르다라는 규칙이 통합니다. <br> 
반면에 C++에서는 사용자 정의 생성자/소멸자 개념이 있어, 객체를 값으로 전달하면 **복사 생성자**가 호출될 수 있고, 이 복사 비용은 단순 메모리 복사(struct 복사)보다 매우 비싸다. 또한, 지역 임시 객체가 생기면 소멸자까지 호출되고. Pass-by-reference-to-const (const T&)는 복사 생성자/소멸자를 건너뛰기 때문에 **비용 0** 에 가깝고, 원본을 수정하지 않겠다는 보장도 있으므로 안전하여 보통 **큰 객체 인자** 전달 시 const T&가 권장됩니다. <br> 
특히 템플릿 C++에서는 객체의 타입조차 알 수 없어 이러한 방식이 더 두드러지지만, 반대로 STL로 넘어오면 또 전세가 역전된다. 즉 STL에서는 반복자와 함수 객체가 C의 포인터를 본떠 만든 것이라, STL에서는 반복자 및 함수 객체에 대해서는 값 전달에 대한 규칙이 다시 제 힘을 발휘하게 됨. 

결론 : C++는 한 가지 프로그래밍 규칙 아래 똘똘 뭉친 통합 언어(Unified Language)가 아니라 위의 4가지 하위 언어들의 **연합체**로 구성되어 있습니다. 

### <#define을 쓰려면 const, enum, inline을 생각하자>
가급적 선행 처리자보다 컴파일러를 더 가까이 하자로
