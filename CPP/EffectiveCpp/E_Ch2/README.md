# Ch2. 생성자, 소멸자 및 대입 연산자 

개요
  - 생성자
    + 새로운 객체를 메모리에 만드는 데 필요한 과정을 제어 및 객체의 초기화를 담당하는 함수
  - 소멸자
    + 객체를 없앰과 동시에 그 객체를 메모리에서 적절히 사라질 수 있도록 하는 과정을 제어하는 함수
  - 대입 연산자
    + 기존의 객체에 다른 객체의 값을 줄 때 사용하는 함수. 

목차 
  + 2-5 C++가 은근슬쩍 만들어 호출해버리는 함수들에 촉각을 세우자
  + 2-6 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자
  + 2-7 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자
  + 2-8 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
  + 2-9 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자
  + 2-10 대입연산자는 *this의 참조자를 반환하게 하자
  + 2-11 operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자 
  + 2-12 객체의 모든 부분을 빠짐없이 복사하자

-------------------------------------------------

## 2-5 C++가 은근슬쩍 만들어 호출해버리는 함수들에 촉각을 세우자

**비어 있지만, 비어있지 않은 Class**

C++에서 직접 선언을 하지 않아도, 컴파일러가 저절로 선언할 수 있도록 되어 있음. <br>
즉, 복사 생성자(Copy Constructor), 복사 대입 생성자(Copy Assignment Operator), 소멸자(Destructor)을 기본형으로 선언 해줌. 심지어 생성자조차도 선언되지 있지 않았으면, 컴파일러가 기본 생성자를 선언 해줌 <br>
이들은 모두 public멤버이며 inline 함수. 

```cpp
class Empty {...};

class Empty{
  public:
  Empty() {} //기본 생성자
  Empty(const Empty& rhs){} // 복사생성자
  ~Empty() {} //소멸자
  Empty& operator= (const Empty& rhs) {....} // 복사 대입 연산자
};

```

이들은 꼭 필요하다고 컴파일러가 판단할 때 만들어지며, 다음과 조건을 만족 한다. 

```cpp

Empty e1; //기본 생성자, 소멸자
Empty e2(e1); //복사 생성자
e2 = e1; //복사 대입 생성자

```

'어떤 일을 하기때문에 컴파일러가 판단해서 저절로 만들어지는 걸까?'에 대해 알아보는게 이번 2-5의 목표 

**생성자와 소멸자**
일차적으로 컴파일에게 **배후의 코드**를 깔 수 있는 자리를 마련해줌 → 기본 클래스 및 비정적 데이터 멤버의 생성자와 소멸자를 호출하는 코드가 여기서 생김. <br>
이떄 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 **가상 소멸자로 되어 있지 않으면 역시 비가상 소멸자**로 만들어짐

**복사 생성자와 복사 대입 연산자**
컴파일러가 몰래 만들어낸 복사 생성자/복사 대입 연산자는 원본 객체의 비정적 데이터를 사본 객체쪽으로 그냥 복사하는 일을 함. 

```cpp

template<typename T>
class NamedObject{

private:
  string nameValue;
  T objectValue;
  ....

public:
  NamedObject(const char* name, const T& value);
  NamedObject(const string& name, const T& value);
  ....
};

```

위의 코드에서 NamedObject 템플릿 안에는 생성자가 선언되어 있어서, **컴파일러는 기본 생성자를 만들어내지 않음** <br>
반면, 복사 생성자나 복사 대입 연산자는 NamedObject에 선언되어 있지 않기 때문에, 필요하다고 판단하면 이 두 함수의 기본형이 컴파일러에 의해 만들어짐.

```cpp
NamedObject<int> no1("Smallest Prime Number",2);
NamedObject<int> no2(no1); //복사 생성자 호출 
```
위의 코드를 보면 no2에서 복사 생성자를 호출하기 때문에, 기본 복사 생성자가 호출되고 no1.nameValue(string 복사 생성자 호출) <br>
no.obJectValue(int 비트 복사)는 각각 no2 멤버 변수에 복사 됨. <br>
복사 대입 연산자도 동작 원리가 같지만 최종 결과 코드가 **Legal 하고 Resonalbe**해야 한다 operator=를 생성하지만 
둘 중 하나라도 검사를 통과하지 못하면 컴파일러는 operator=의 자동생성을 거부함 <br> 
다음 예제 코드를 보자, nameValue는 string에 대한 **참조자**이고 objectValue는 const T로 되어 있음.

```cpp
template<typename T>
class NamedObject{

private:
  string& nameValue; // 참조자 
  const T objectValue; // 상수
  ....

public:
  NamedObject(const string& name, const T& value);
  //이 생성자는 상수 타입의 name을 취하지 않는다 → nameValue가 비상수 string의 참조자가 되었기 때문에
  //참조할 string을 가져야하기 떄문에 char*는 없어짐. 
  // 그리고 operator=는 선언된게 없다고 가정. 
....

};

string newDog("Persephone");
string oldDog("Satch");

NamedObject<int> p (newDog, 2);
NamedObject<int> s (oldDog,36);

p = s; //p에 들어있는 데이터 멤버에서 어떤일이 일어날까? 

```
위의 코드는 불가능 <br>
멤버 변수 string&은 참조자인데, 두 객체는 각각 다른 strin 참조형을 가지고 있기 때문에 대입 연산이 불가능 <br>
C++ 참조자는 자신이 참조하고 있는 것과 다른 객체를 참조할 수 없기 때문 <br>
즉, 참조자를 데이터 멤버로 갖고 있는 클래스에 대입 연산 지원하려면 직접 복사 대입 연산를 정의해야 하고, 만약에 컴파일러에 의해 자동으로 생성된 암시적 복사 대입 연산자는 내부에서 상수 멤버를 어떻게 처리할지 모호해져 암시적 생성을 거부함. <br>
또한 데이터 멤버가 상수 객체인 경우에도 상수 멤버를 수정하는 것이 문법에 어긋나기 때문에, 이 또한 암시적 생성을 거부함. <br>
마지막으로, 복사 대입 연산자를 private로 선언한 부모 클래스로부터 파생된 자식 클래스의 경우에도 암시적 복사 대입 연산자를 가질 수 없음<br> 
컴파일러가 거부해버리고, 애초에 자식 클래스는 호출한 권한이 없는 멤버 함수는 암시적 복사 대입 연산자가 어떻게든 호출할 수 없기 때문임 

- **2-5 정리**

  컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.

-----------------------------------------------------------------

## 2-6 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

2-5에서 컴파일러가 자동으로 만들어낸 함수들을 사용하고 싶지 않을 때에 대해 알아보는 항목 <br> 
컴파일러가 생성 함수는 모두 공개가 되는 public 멤버가 되고, 복사 생성자와 복사 대입 연산자가 자동으로 생성되는 것을 막기 위해 
직접 선언해야 한다는 점은 맞지만, 이를 반드시 public 멤버로 선언해야한다고 한 적은 없음 <br> 
그러니, 복사 생성자와 복사 대입 연산자를 public 멤버가 아닌 private 멤버로 선언하면
1. 클래스 멤버 함수가 명시적으로 선언되기 때문에, 컴파일러는 자신의 기본 버전을 만들 수 없고,
2. private의 접근성을 가지기 때문에, 외부로부터의 호출을 차단하여 복사를 할수 없게 만든다.

하지만 private 멤버 함수도 그 클래스의 멤버 함수 및 friend()함수가 호출 할 수 있는 단점이 존재하는데, 이를 **정의(define)** 를 안하는 방법으로 해결할 수 있음. <br>

```cpp

class HomeForSale{

private:
  HomeForSale(const HomeForSale&); //선언만 존재
  HomeForSale& operator= (const HomeForSale&);

public:
  ....
};

```

외부에서 복사 생성자나 복사 대입 연산자를 호출시키면, 정의되지 않은 함수를 호출하기 때문에 링크 시점에서 에러가 발생 함<br>
(단, 클래스 내부에 friend함수로 호출 가능)

또한, 링크 시점을 에러를 컴파일 시점에러로 옮길 수 도 있다
1. 복사 생성자와 복사 대입 연산자를 private로 선언하되,
2. 이것을 HomeForSale 클래스 자체에 넣지 말고 별도의 기본 클래스에 넣고,
3. 이 클래스로부터 HomeForSale클래스를 파생시키는 것이다.
4. 그리고 그 별도의 클래스는 복사 방방지만 맡는 역할을 부여한다.

다음 코드를 보자 

```cpp

class Uncopyable{
protected: //파생된 객체에 대해서
  Uncopyable(); //생성과 소멸을 허용
  ~Uncopyable();

private:
  Uncopyable(const Uncopyable&); //하지만 private로 선언하여 복사를 방지한다/
  Uncopyable& operator=(const Uncopyable&);
};

class HomeForSale : pricate Uncopyable{

// HomeForSale 클래스를 Uncopyable로 부터 상속을 받게하고 그냥 냅둔다.
// 그러면 복사 생성자도, 복사 대입 연산자도 선언되지 않는다.

};

```

이렇게하면, HomeForSale는 Uncopyable로부터 상속을 받았기 때문에, HomeForSale 객체의 복사를 외부(멤버 함수 및 프렌드 함수까지 포함하여)에서 시도하려고 할 때, 통하지 않는다. <br>
즉, 복사 생성자 및 복사 대입 연산자를 선언하지 않는다. <br>
왜냐면 컴파일러가 생성한 복사 함수는 기본 클래스의 대응 버전을 호출하게 되어 있는데, 여기서는 복사 함수들이 부모 클래스에서 공개되어 있지 않기 때문이다. <br>

마지막으로, Uncopyable의 구현과 사용법에 대해 미묘한 부분들을 알아보자.

  - Uncopyable의 구현과 사용법
  1.  Uncopyable로부터 상속은 public일 필요가 없다.
  2.  Uncopyable의 소멸자는 가상 소멸자가 아니여도 된다
  3.  Uncopyable의 클래스는 데이터 멤버가 전혀 없기 때문에, 공백 기본 클래스 최적화 기법(Empty base class Optimization)이 먹힐 수 도 있지만, Uncopyable 클래스는 기본 클래스이기 때문에, 이 기법을 사용한다면 다중 상속으로 갈 가능성이 있다.
  4.  다중 상속 시 공백 기본 클래스 최적화 기법(Empty base class Optimization)이 돌아가지 못할 때도 있다.
  5.  Boost 라이브러리를 보면 Uncopyable과 똑같은 구실을 하는 클래스를 찾을 수 있고, 이것을 써도 된다 → noncopyable class

  - **2-6 정리**
    
    컴파일에서 자동으로 제공하는 기능을 허용하지 않을려면, 대응되는 멤버 함수를 private로 선언하고나서 구현은 하지 않은 채로 두면 된다, 아니면 Uncopyable과 비슷한 기본 클래스를 쓰는 방법이 있다. 

-----------------------------------------------------------------

## 2-7 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

C++의 특징 중 하나인 다형성을 통해, 공통 기능을 가진 하나의 클래스를 기본 클래스로 만들어 용도에 따라 적절하게 파생시켜 사용할 수 있는데, 이렇게 파생시킨 객체를 쉽게 사용하기 위해 이 객체에 대한 포인터를 가져오는 팩토리 함수(factory funcion)에 대해 알아보자 

- **팩토리 함수(Factory Funcion)** <br>
팩토리 함수(Factory Funcion) → 새로 생성된 파생 클래스 객체에 대한 기본 클래스 포인터를 반환 함수로, 파생 클래스의 객체를 new로 할당하기 때문에 delete를 사용하여 적절히 메모리에서 제거해야함 <br>
즉, 함수에서 반환되는 객체는 힙(Heap) 메모리에 있게 되어, 잘 못 사용하면 메모리 누수(Memory Leak)이나 기타 자원의 누출이 발생 문제가 발생 함 <br>

```cpp

class TimeKeeper{
public:
  TimeKeeper();
  ~TimeKeeper();
  ...
};

class AtomicClock : public TimeKeeper {...};
class WaterClock : public TimeKeeper {....};
class WristWatch : public TimeKeeper {.....};

// TimeKeeper* getTimeKeeper(); TimeKeeper에서 파생된 클래스를 통해 동적으로 할당된 객체의 포인터로 반환

TimeKeeper* ptk = TimeKeeper(); //TimeKeeper클래스 계통으로부터, 동적으로 할당된 객체를 얻어 사용함

....

delete ptk; //자원 누출을 막기 위해 삭제

```
이 코드의 문제점은, getTimeKeeper함수가 반환하는 포인터가 파생 클래스 객체에 대한 포인터라는 점과 이 포인터가 가리키는 객체가 삭제될 때는 기본 클래스 포인터를 통해 삭제되는 점, 기본 클래스에 들어있는 소멸자가 비가상 소멸자라는 것. <br>
이렇게되면 대부분 그 객체의 파생 클래스 부분은 소멸하지 않게 되는데, 기본 클래스 부분은 소멸되므로 **부분 소멸(Partially Destroyed)** 객체로 남는다.
(C++의 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때, 그 기본 클래스에 비가상 소멸자가 들어 있으면 프로그램 동작은 미정의 사항이라고 되어 있기 때문) 

이러한 문제를 해결하는 방법은 매우 간단한데, **기본 클래스의 소멸자를 가상 소멸자**로 변경하면 된다. 
이러면 파생 클래스 객체를 기본 클래스 포인터로 삭제할 때, 사용자가 원하는대로 동작하게 된다 

```cpp

class TimeKeeper{
public:
  TimeKeeper();
  virtual ~TimeKeeper();
  ...
};

TimeKeeper* ptk = TimeKeeper();
delete ptk
```

하지만, 모든 클래스에 가상 소멸자를 붙이는건 virtual를 절대 선언하지 않는 것만큼이나 안좋은 습관이다. 
virtual를 사용하면, 클래스에서 가상 함수 테이블(Virtual Function Table)이 포함되고 객체는 가상 함수 포인터(Virtual Function Pointer)를 가지게되어, 객체의 크기가 커지기 때문에, **가상소멸자를 선언하는 것은 그 클래스에 가상 함수에 하나라도 들어있는 경우에만 선언하는 것으로 정의하고**, 다형성의 의도가 없는 클래스와 다형성을 갖도록 설계되지 않은 클래스(string, STL Container-vector, list, set, trl::unordered_map....)등은 기본 소멸자를 사용하는게 좋다. <br>
(비가상 소멸자를 가진 표준 컨테이너 등의 클래스를 써서 쓸모 있는 나만의 클래스를 만드는 경우가 있는데 자제하는 것이 좋다... Java의 final class, C#의 sealed class 같은 방지 매커니즘이 C++에는 아예 없기 때문) <br>
경우에 따라 순수(pure) 가상 소멸자를 두면 편리하게 쓸수 있으니, 순수 가상 소멸자 대해 알아보자. 

- **순수 가상 소멸자**
  순수 가상 함수는 해당 클래스를 추상 클래스(Abstract Class) - 그 자체로는 인스턴스를 못 만드는, 그 타입의 객체를 생성할 수 없는 클래스 - 로 만든다 <br>
  어떤 클래스가 추상 클래스였으면 좋겠는데, 마땅히 넣을 만한 순수 가상 함수가 없다면 어차피 추상 클래스는 기본 클래스로 사용하기 위한 목적이기에 가상 소멸자가 필요함으로, 가상 소멸자를 순수 가상 함수로 만들면 된다.

```cpp
//AWOV = "Abstract w/o Virtuals"
class AWOV{
public:
  virtual ~AWOV() = 0 ; //순수 가상 소멸자 선언
};

AWOV::~AWOV() {} //순수 가상 소멸자 정의

```

위의 코드에서 AWOV 클래스는 순수 가상 함수를 갖고 있기 때문에, 추상 클래스이며 동시에 순수 가상 함수가 가상 소멸자로 소멸자 호출 문제는 고민할 필요가 없다, 단. 순수 가상 소멸자의 정의를 두지 않으면 안된다. 

소멸자의 동작하는 순서는 가장 말단에 있는 파생 클래스의 소멸자가 먼저 호출되는 것을 시작하여, 기본 클래스 쪽으로 거쳐 올라가면서 각 기본 클래스의 소멸자가 하나씩 호출된다. <br>
즉, 순수 가상 소멸자를 사용했다면 정의를 꼭 두어야하며 정의가 없다면 링커 에러가 발생한다는 점만 알고 있으면 됨 

기본 클래스의 손에 가상 소멸자를 쥐어 주자는 규칙은 **다형성(Polymorphic)을 가진 기본 클래스** 즉, 기본 클래스 인터페이스를 통해 파생 클래스 타입의 조작을 허용하도록 설계된 기본 클래스에만 적용됨

모든 기본 클래스가 다형성을 갖도록 설계된 것은 아니다 (string, STL 컨테이너 타입... 특히 STL 컨테이너 타입은 기본 클래스는 커녕 다형성의 흔적조차 볼 수 없다) <br>
한편, 기본 클래스로 쓰일 수 있지만, 다형성은 갖지 않도록 설계된 클래스(2-6의 Uncopyalbe, 표준 라이브러리의 input_iterator_teg)도 있는데. 이런 클래스는 기본 클래스의 인터페이스를 통한 파생 클래스 객체의 조작이 허용되지 않아, 가상 소멸자를 볼 수 없다. 

  - **2-7 정리**
    
  다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 한다. 즉, 어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자이어야 한다.
  기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 한다.

-----------------------------------------------------------------

## 2-8 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

소멸자가 호출되는 경우는 1. 정상적으로 객체가 종료되었을 때, 2 예외처리 매커니즘에 의해 객체가 소멸될 때 인데, 예외처리 매커니즘에 의해 객체가 소멸될 때 또 예외가 발생한다면, terminate 함수가 호출되어 프로그램이 종료됨 <br>
그러니 try-catch문으로 예외를 소멸자내로 묶어두어야 함. 

일단 아래의 코드를 보자

```cpp

class DBConnection{
public:
  static DBConnection create(); //db 생성
  void close(); // 연결 닫기, 연결이 실패하면 예외를 발생  
};

// DBConnection 객체를 관리하는 클래스
class DBconn{
private:
   DBConnection db;
public:
  ....
  //DB연결이 항상 닫히도록 확실히 챙겨주는 함수. 
  ~DBConn() { db.close(); }

};
```

이코드에서 DBconn이 소멸할 때, db.close가 호출되며, 이때 예외가 발생한다면 프로그램은 미정의 동작을 발생시킬 것임<br> 
그러니까 DBconn의 소멸자는 분명히 이 예외를 전파할 것이고, 그 소멸자에서 예외가 나가도록 내버려 둔다는 건인데 이게 문제. <br>
예외를 던지는 소멸자는 곧 '걱정거리'를 의미하기 때문에, 이를 피하는 방법은 2가지임 <br>

1. close에서 예외가 발생하면 **프로그램을 바로 끝내는 방법** → 주로 abort함수를 호출함

```cpp
DBConn::~DBConn(){
  try{
  db.close();
}catch(...){
  abort(); //std:: 생략, claose 호출이 실패했다는 로그 작성. 
}

};
```

위의 코드는 객체 소멸이 진행되다가 에러가 발생한 후에 프로그램 실행을 계속 할 수 없는 상황이라면 괜찮은 선택지 <br>
소멸자에서 생긴 예외를 그대르 흘려 내보냈다가 정의되지 않은 동작에까지 이를 수 잇는 그런 불상사를 막는다는 의미에서 어느 정도 효과적. <br>

2. claose를 호출한 곳에서 일어난 예외를 삼켜버림. 

```cpp
DBConn::~DBConn(){
  try{
  db.close();
}catch(...){
  //예외를 무시한다. 
}

};
```

대부분의 경우에서 예외 삼키기는 그리 좋은 방법이 아님, 중요한 정보(무엇이 잘못됐는지를 알려주는 정보)가 있을 수 도 있는데 그걸 묻혀버리기 때문에. <br>
하지만 때에 따라서 불완전한 프로그램 종료 혹은 미정의 동작으로 인해 입는 위험을 감수하는 것보다 그냥 예외를 먹어 버리는 게 나을 수 있음 단, **예외 삼키기**를 선택한 것이 제대로 효과를 볼려면, 발생한 예외를 그냥 무시한 뒤라도 프로그램이 **신뢰성**있게 실행을 지속 해야함 <br>

3. 발생한 소지가 있는 문제에 대처할 기회를 사용자가 가질 수 있도록 한다. 즉, 예외가 호출될 수 있는 부분을 소멸자가 아닌 사용자가 호출할 수 있게 제공.

```cpp
DBConn::DBConn(){
private:
   DBConnection db;
  bool closed = false;

public:
  void close(){
    db.close();
    closed = true;
  }

  ~DBConn(){
    if(!colsed) {
    try{
      db.close();  //사용자가 연결을 안 닫았으면 여기서 닫아본다 
      } catch(...){
        //close 호출이 실패했다는 로그를 작성; 연결을 닫다가 실패하면, 실패를 알려주고 프로그램을 종료하거나 예외를 삼킨다. 
        ....
       }
    }
  }
};

```
위의 코드처럼 예외 발생시 그 예외는 **소멸자가 아닌 다른 함수에서 비롯된 것이어야 한다**가 핵심 <br>
예외를 일으키는 소멸자는 시한 폭탄처럼 프로그램의 불완전 종료 혹은 미정의 동작의 위험을 내포하고 있기 때문에 <br>
사용자가 에러가 발생할만한 가능성이 있는 코드를 원하는 타이밍에 호출할 수 있으므로, 에러에 잘 대처 할 수 있음 <br>

  - **2-8 정리**
    
  소멸자에서는 예외가 빠져나가면 안됨, 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든 소멸자에서 모두 받아낸 후에 삼켜버리든지 프로그램을 끝내든지 해야한다.
  어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보틍의 함수(소멸자가 아닌 함수)이어야 한다.

-----------------------------------------------------------------

## 2-9 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자

우선... 객체 생성 및 소멸 과정 중에는 **가상 함수를 호출하면 절대 안 됨** <br>
1. 호출 결과가 원하는 대로 돌아가지 않을 거고,
2. 원하는 대로 돌아간다고 해도, 겉은 멀쩡해도 속은 망가진 느낌 즉, 이식성과 안정성이 떨어짐

C++는 같은 객체지향 언어인 C#이나 Java보다 보통의 경우에 어려운 언어이기 때문임 

일단 다형성과 가상 함수에 대해 알아보자 

  - **다형성과 가상함수**

일단 예제 코드부터 보자 

```cpp
class Transaction{ //모든 거대에 대한 기본 클래스
public:
  Transaction();
  virtual void logTransaction() const = 0; //타입에 따라 달라지는 로그 기록 
  ...
};

Transaction::Transaction(){ //기본 클래스 생성자의 구현
  ...
  logTransaction();  // 마지막 동작으로, 이거래를 로킹 시작 즉, 기본 클래스의 생성자에서 가상 함수 호출 
}

class BuyTransaction: public Transaction{ //Transaction의 자식 클래스인 BuyTransaction 클래스
public:
  virtual void logTransaction() const; // 이타입에 따른 거래내역 로깅을 구현
  ....
};

class SellTransaction: public Transaction{ //이 또한 Transaction의 자식 클래스
public:
   virtual void logTransaction() const; 

};

int main(void){
  BuyTransaction b; 
  return 0;
}
```

 BuyTransaction b;를 실행하면 어찌 되는지 확인해보자. <br>
 BuyTransaction의 생성자가 호출되는 것은 맞다. 하지만 그 전에 우선적으로 Transaction의 생성자가 먼저 호출되어야 한다. <br>
 자식 클래스 객체가 생성될 때, 그 객체의 부모 클래스 부분이 자식 클래스 부분보다 먼저 호출되는 것이 정석이기 때문에 <br>
 여기서, logTransaction()함수는 BuyTransaction의 함수가 아닌 Transaction의 함수이다.

기본(부모) 클래스의 생성자가 호출될 동안, 가상 함수는 절대로 파생(자식) 클래스쪽으로 내려가지 않는다. 그 대신에, 객체 자신이 기본 클래스 타입인 것처럼 동작한다. 즉, 기본 클래스 생성 과정에서는 가상 함수가 먹히지 않는다. <br>
소멸자 또한 동일한 문제가 발생한다. 

이제 해결하는 방법을 알아보자 
여러 방법이 있지만, 그중 하나는 **가상 함수가 아닌 비가상 멤버 함수를 사용 하는 것**이다. <br>
위의 코드는 타입에 따라 달라지는 로그 기록을 노출하고 싶어, 자식 클래스의 생성자들로 하여금 필요한 로그 정보를 Transaction의 생성자로 넘기고, logTransaction을 비강사 함수로 변경하면 ButTransaction객체의 초기화도지 않은 멤버로 건드릴 위험이 없기에 안전해진다. 

```cpp
class Transaction{ //모든 거대에 대한 기본 클래스
public:
  explicit Transaction(const string* logInfo); // explicit 자신이 원하지 않은 형변환이 일어나지 않도록 제한 
  void logTransaction(const string* logInfo) const; // 비가상 함수
  ...
};

Transaction::Transaction(const string* logInfo){ //기본 클래스 생성자의 구현
  ...
  logTransaction(logInfo);  //비가상 함수를 호출
}

class BuyTransaction: public Transaction
private:
  static string createLogString(parameters);
public:
   BuyTransaction(parameters):Transaction(createLogString(parameters)){....} //로그 정보를 기본 클래스 생성자로 넘김 
  ....
};

```

기본 클래스 부분이 생성될 때는 가상 함수를 호출한다 해도 기본 클래스의 울타리를 넘어 내려갈 수 없기 때문에, 필요한 초기화 정보를 파생 클래스 쪽에서 기븐 클래스 생성자로 '올려'주도록 만듦으로써 부족한 부분을 역으로 채울 수 있다. 

  - **2-10 정리**
    생성자/소멸자 안에서 가상 함수를 호출하지 말자, 가상 함수라고 해도 지금 실행중인 생성자나 소멸자에 해당되는 클래스의 자식 클래스쪽으로 내려가지 않기 때문이다.
    
-----------------------------------------------------------------

## 대입 연산자는 *this 의 참조자를 반환 하게 하자

C++의 대입 연산은 여러 개가 사슬처럼 엮일 수 있는 특징이 있다. 

```cpp
int x, y, z;
x = y = z = 15;
```

대입 연산이 가진 또 하나의 특징은 **우측 연관(right-associative) 연산**이라는 것이다.
```cpp
x = y =( z= 15));
```
위의 코드에서, 15가 z에 대입되고, 그 대입 연산의 결과 (갱신된 z)는 y에 대입 되고, 또 y에 대한 대입 연산의 결과가 x에 대입된다. 
대입 연산이 사슬처럼 엮일려면 대입 연산자가 좌변 인자에 대한 참조자를 반환 하도록 구현되어 있을 것인데, 이를 일종의 **관례(conveintion)** 이라고 함.

```cpp
class Widget{
public:
  ...
  Widget& operator= (const Widget& rhs){ //반환 타입은 현재의 클래스에 대한 참조자 
  ...
  return *this; //좌변 객체(의 참조자)를 반환
  }
  ...
};
```

**좌변 객체의 참조자를 반환하게 만들자**라는 규약은 단순 대입형 연산자 말고도 모든 형태의 대입 연산자에서 지켜져야 한다. 

```cpp
class Widget{
public:
  ...
  Widget& operator+= (const Widget& rhs){ //+=, -=, *=등에도 동일한 규약이 적용
  ...
  return *this; //좌변 객체(의 참조자)를 반환
  }

  Widget& operator= (int rhs){ //대입 연산자의 매개변수 타입이 일반적이지 않을 경우에도 동일한 
  ...
  return *this;
  }
  ...

};
```

관례를 지키지 않는다고 해서 컴파일이 안되지 않지만, 표준 라이브러리와 기본 타입들은 이 관례를 따르고 있으니 지키자

  - **2-10 정리**
    대입 연산자는 *this의 참조자를 반환하도록 만들자.
    
-----------------------------------------------------------------

## 2-11 operator= 에서는 자기대입에 대한 처리가 빠지지 않도록 하자 

자기 대입(self assignment)란 → 어떤 객체가 자기 자신에 대해 대입 연산자를 적용하는 것 

```cpp
class Widget{...};
  Widget w;
  ...
  w = w; // 자기에 대한 대입
```

이 코드는 적법한(legal) 코드이다. 다음 코드를 보자.

```cpp
a[i] = a[j]; //자기 대입에 대한 가능성을 아름드리 품은 품장
*px = *py; //자기 대입의 가능성을 하나 가득 품은 품장 
```
a[i] = a[j]에서 i와 j가 같은 값을 갖게 되면 자기 대입문이 됨 <br>
*px = *py 이 또한 가리키는 대상이 같으면 자기 대입이 됨 <br>
언뜻 보기에 명확하지 않은 자기대입이 생기는 이유는 여러 곳에서 하나의 객체를 참조하는 상태, **중복참조(aliasing)** 이 일어나기 때문이라서, 같은 클래스의 객체를 두룰 때는 중복 참조를 고려해서 설계 해야함.
즉, 같은 타입으로 만들어진 객체 여러 개를 참조자 혹은 포인터로 물어 놓고 동작하는 코드를 작성할 때는 같은 객체가 사용될 가능성을 고려해야 함.

다음 코드를 보자 

```cpp
class Bitmap{...};

class Widget{
  ...
private:
  Bitmap *pb; //힙에 할당한 객체를 가리키는 포인터 
};

Widget& Widget::operator= (const Widget& rhs){ //안전하게 구현되지 않은 operator=
  delete pb; //현재의 비트맵 사용을 중지
  pb = new Bitmap(*rhs.pb); //rhs의 비트맵을 사용하도록 만듬
  return *this;  //참조자 반환
}
```

위의 코드에서 자기 참조 문제는 operator= 내부에서 *this(대입되는 대상)와 rhs가 같은 객체일 가능성이 있음. <br>
그러니까... *this와 rhs가 같은 객체이면, delete 연산자가 *this 객체의 비트맵에만 적용되는 것이 아닌, rhs의 객체까지 적용된다. <br>
즉, delete pb 실행시 rhs의 pb도 삭제되어 제대로된 동작을 할 수 없다 <br>

이에 대한 해결책으로 전통적인 방법으로는 operator=의 첫머리에서 **일치성 검사(identity test)**를 통해 자기대입을 확인 하는 것임. 

```cpp
Widget& Widget::operator= (const Widget& rhs){
  if(this == &rhs) return *this; // 객체가 같은지, 즉 자기대입인지 검사, 자기대입이면 아무것도 안함 
  delete pb; //현재의 비트맵 사용을 중지
  pb = new Bitmap(*rhs.pb); //rhs의 비트맵을 사용하도록 만듬
  return *this;  //참조자 반환
}
```

하지만 이코드 또한 예외 안정성에는 문제가 있는데, **new Bitmap**에서 예외가 터지면, 이미 삭제된 비트맵을 포인터를 가지게 될 것이고, *this와 rhs 비교 검사를 거쳐야 하므로 속도 면에서도 비효율적인 상황이 발생함 

그럼 코드 순서를 바꿔 예외 안정성을 해결해보자

```cpp
Widget& Widget::operator= (const Widget& rhs){

  Bitmap *pOrig = pb; //원래의 pb를 어딘가에 기억
  pb = new Bitmap(*rhs.pb); //다음, pb가 *pb의 사본을 가리키게 만듬
  delete pOrig; //원래의 pb를 삭제

  return *this;
}
```

이렇게 순서를 바꾸면 new Bitmap 부분에서 예외가 발생해도 delete가 실행되지 않아 pb는 변경되지 않고, 자기 참조가 일어나더라도 안전한 동작이 발생함 

-----------------------------------------------------------------

## 2-12 객체의 모든 부분을 빠짐없이 복사하자
-----------------------------------------------------------------
