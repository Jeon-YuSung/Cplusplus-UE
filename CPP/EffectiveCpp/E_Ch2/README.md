# Ch2. 생성자, 소멸자 및 대입 연산자 

개요
  - 생성자
    + 새로운 객체를 메모리에 만드는 데 필요한 과정을 제어 및 객체의 초기화를 담당하는 함수
  - 소멸자
    + 객체를 없앰과 동시에 그 객체를 메모리에서 적절히 사라질 수 있도록 하는 과정을 제어하는 함수
  - 대입 연산자
    + 기존의 객체에 다른 객체의 값을 줄 때 사용하는 함수. 

목차 
  + 2-5 C++가 은근슬쩍 만들어 호출해버리는 함수들에 촉각을 세우자
  + 2-6 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자
  + 2-7 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자
  + 2-8 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
  + 2-9 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자
  + 2-10 대입연산자는 *this의 참조자를 반환하게 하자
  + 2-11 operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자 
  + 2-12 객체의 모든 부분을 빠짐없이 복사하자

-------------------------------------------------

## 2-5 C++가 은근슬쩍 만들어 호출해버리는 함수들에 촉각을 세우자

**비어 있지만, 비어있지 않은 Class**

C++에서 직접 선언을 하지 않아도, 컴파일러가 저절로 선언할 수 있도록 되어 있음. <br>
즉, 복사 생성자(Copy Constructor), 복사 대입 생성자(Copy Assignment Operator), 소멸자(Destructor)을 기본형으로 선언 해줌. 심지어 생성자조차도 선언되지 있지 않았으면, 컴파일러가 기본 생성자를 선언 해줌 <br>
이들은 모두 public멤버이며 inline 함수. 

```cpp
class Empty {...};

class Empty{
  public:
  Empty() {} //기본 생성자
  Empty(const Empty& rhs){} // 복사생성자
  ~Empty() {} //소멸자
  Empty& operator= (const Empty& rhs) {....} // 복사 대입 연산자
};

```

이들은 꼭 필요하다고 컴파일러가 판단할 때 만들어지며, 다음과 조건을 만족 한다. 

```cpp

Empty e1; //기본 생성자, 소멸자
Empty e2(e1); //복사 생성자
e2 = e1; //복사 대입 생성자

```

'어떤 일을 하기때문에 컴파일러가 판단해서 저절로 만들어지는 걸까?'에 대해 알아보는게 이번 2-5의 목표 

**생성자와 소멸자**
일차적으로 컴파일에게 **배후의 코드**를 깔 수 있는 자리를 마련해줌 → 기본 클래스 및 비정적 데이터 멤버의 생성자와 소멸자를 호출하는 코드가 여기서 생김. <br>
이떄 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 **가상 소멸자로 되어 있지 않으면 역시 비가상 소멸자**로 만들어짐

**복사 생성자와 복사 대입 연산자**
컴파일러가 몰래 만들어낸 복사 생성자/복사 대입 연산자는 원본 객체의 비정적 데이터를 사본 객체쪽으로 그냥 복사하는 일을 함. 

```cpp

template<typename T>
class NamedObject{

private:
  string nameValue;
  T objectValue;
  ....

public:
  NamedObject(const char* name, const T& value);
  NamedObject(const string& name, const T& value);
  ....
};

```

위의 코드에서 NamedObject 템플릿 안에는 생성자가 선언되어 있어서, **컴파일러는 기본 생성자를 만들어내지 않음** <br>
반면, 복사 생성자나 복사 대입 연산자는 NamedObject에 선언되어 있지 않기 때문에, 필요하다고 판단하면 이 두 함수의 기본형이 컴파일러에 의해 만들어짐.

```cpp
NamedObject<int> no1("Smallest Prime Number",2);
NamedObject<int> no2(no1); //복사 생성자 호출 
```
위의 코드를 보면 no2에서 복사 생성자를 호출하기 때문에, 기본 복사 생성자가 호출되고 no1.nameValue(string 복사 생성자 호출) <br>
no.obJectValue(int 비트 복사)는 각각 no2 멤버 변수에 복사 됨. <br>
복사 대입 연산자도 동작 원리가 같지만 최종 결과 코드가 **Legal 하고 Resonalbe**해야 한다 operator=를 생성하지만 
둘 중 하나라도 검사를 통과하지 못하면 컴파일러는 operator=의 자동생성을 거부함 <br> 
다음 예제 코드를 보자, nameValue는 string에 대한 **참조자**이고 objectValue는 const T로 되어 있음.

```cpp
template<typename T>
class NamedObject{

private:
  string& nameValue; // 참조자 
  const T objectValue; // 상수
  ....

public:
  NamedObject(const string& name, const T& value);
  //이 생성자는 상수 타입의 name을 취하지 않는다 → nameValue가 비상수 string의 참조자가 되었기 때문에
  //참조할 string을 가져야하기 떄문에 char*는 없어짐. 
  // 그리고 operator=는 선언된게 없다고 가정. 
....

};

string newDog("Persephone");
string oldDog("Satch");

NamedObject<int> p (newDog, 2);
NamedObject<int> s (oldDog,36);

p = s; //p에 들어있는 데이터 멤버에서 어떤일이 일어날까? 

```
위의 코드는 불가능 <br>
멤버 변수 string&은 참조자인데, 두 객체는 각각 다른 strin 참조형을 가지고 있기 때문에 대입 연산이 불가능 <br>
C++ 참조자는 자신이 참조하고 있는 것과 다른 객체를 참조할 수 없기 때문 <br>
즉, 참조자를 데이터 멤버로 갖고 있는 클래스에 대입 연산 지원하려면 직접 복사 대입 연산를 정의해야 하고, 만약에 컴파일러에 의해 자동으로 생성된 암시적 복사 대입 연산자는 내부에서 상수 멤버를 어떻게 처리할지 모호해져 암시적 생성을 거부함. <br>
또한 데이터 멤버가 상수 객체인 경우에도 상수 멤버를 수정하는 것이 문법에 어긋나기 때문에, 이 또한 암시적 생성을 거부함. <br>
마지막으로, 복사 대입 연산자를 private로 선언한 부모 클래스로부터 파생된 자식 클래스의 경우에도 암시적 복사 대입 연산자를 가질 수 없음<br> 
컴파일러가 거부해버리고, 애초에 자식 클래스는 호출한 권한이 없는 멤버 함수는 암시적 복사 대입 연산자가 어떻게든 호출할 수 없기 때문임 

- 정리
  컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.

-----------------------------------------------------------------

## 2-6 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

