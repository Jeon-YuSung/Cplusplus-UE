# Ch2. 생성자, 소멸자 및 대입 연산자 

개요
  - 생성자
    + 새로운 객체를 메모리에 만드는 데 필요한 과정을 제어 및 객체의 초기화를 담당하는 함수
  - 소멸자
    + 객체를 없앰과 동시에 그 객체를 메모리에서 적절히 사라질 수 있도록 하는 과정을 제어하는 함수
  - 대입 연산자
    + 기존의 객체에 다른 객체의 값을 줄 때 사용하는 함수. 

목차 
  + 2-5 C++가 은근슬쩍 만들어 호출해버리는 함수들에 촉각을 세우자
  + 2-6 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자
  + 2-7 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자
  + 2-8 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
  + 2-9 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자
  + 2-10 대입연산자는 *this의 참조자를 반환하게 하자
  + 2-11 operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자 
  + 2-12 객체의 모든 부분을 빠짐없이 복사하자

-------------------------------------------------

## 2-5 C++가 은근슬쩍 만들어 호출해버리는 함수들에 촉각을 세우자

**비어 있지만, 비어있지 않은 Class**

C++에서 직접 선언을 하지 않아도, 컴파일러가 저절로 선언할 수 있도록 되어 있음. <br>
즉, 복사 생성자(Copy Constructor), 복사 대입 생성자(Copy Assignment Operator), 소멸자(Destructor)을 기본형으로 선언 해줌. 심지어 생성자조차도 선언되지 있지 않았으면, 컴파일러가 기본 생성자를 선언 해줌 <br>
이들은 모두 public멤버이며 inline 함수. 

```cpp
class Empty {...};

class Empty{
  public:
  Empty() {} //기본 생성자
  Empty(const Empty& rhs){} // 복사생성자
  ~Empty() {} //소멸자
  Empty& operator= (const Empty& rhs) {....} // 복사 대입 연산자
};

```

이들은 꼭 필요하다고 컴파일러가 판단할 때 만들어지며, 다음과 조건을 만족 한다. 

```cpp

Empty e1; //기본 생성자, 소멸자
Empty e2(e1); //복사 생성자
e2 = e1; //복사 대입 생성자

```

'어떤 일을 하기때문에 컴파일러가 판단해서 저절로 만들어지는 걸까?'에 대해 알아보는게 이번 2-5의 목표 

**생성자와 소멸자**
일차적으로 컴파일에게 **배후의 코드**를 깔 수 있는 자리를 마련해줌 → 기본 클래스 및 비정적 데이터 멤버의 생성자와 소멸자를 호출하는 코드가 여기서 생김. <br>
이떄 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 **가상 소멸자로 되어 있지 않으면 역시 비가상 소멸자**로 만들어짐

**복사 생성자와 복사 대입 연산자**
컴파일러가 몰래 만들어낸 복사 생성자/복사 대입 연산자는 원본 객체의 비정적 데이터를 사본 객체쪽으로 그냥 복사하는 일을 함. 

```cpp

template<typename T>
class NamedObject{

private:
  string nameValue;
  T objectValue;
  ....

public:
  NamedObject(const char* name, const T& value);
  NamedObject(const string& name, const T& value);
  ....
};

```

위의 코드에서 NamedObject 템플릿 안에는 생성자가 선언되어 있어서, **컴파일러는 기본 생성자를 만들어내지 않음** <br>
반면, 복사 생성자나 복사 대입 연산자는 NamedObject에 선언되어 있지 않기 때문에, 필요하다고 판단하면 이 두 함수의 기본형이 컴파일러에 의해 만들어짐.

```cpp
NamedObject<int> no1("Smallest Prime Number",2);
NamedObject<int> no2(no1); //복사 생성자 호출 
```
위의 코드를 보면 no2에서 복사 생성자를 호출하기 때문에, 기본 복사 생성자가 호출되고 no1.nameValue(string 복사 생성자 호출) <br>
no.obJectValue(int 비트 복사)는 각각 no2 멤버 변수에 복사 됨. <br>
복사 대입 연산자도 동작 원리가 같지만 최종 결과 코드가 **Legal 하고 Resonalbe**해야 한다 operator=를 생성하지만 
둘 중 하나라도 검사를 통과하지 못하면 컴파일러는 operator=의 자동생성을 거부함 <br> 
다음 예제 코드를 보자, nameValue는 string에 대한 **참조자**이고 objectValue는 const T로 되어 있음.

```cpp
template<typename T>
class NamedObject{

private:
  string& nameValue; // 참조자 
  const T objectValue; // 상수
  ....

public:
  NamedObject(const string& name, const T& value);
  //이 생성자는 상수 타입의 name을 취하지 않는다 → nameValue가 비상수 string의 참조자가 되었기 때문에
  //참조할 string을 가져야하기 떄문에 char*는 없어짐. 
  // 그리고 operator=는 선언된게 없다고 가정. 
....

};

string newDog("Persephone");
string oldDog("Satch");

NamedObject<int> p (newDog, 2);
NamedObject<int> s (oldDog,36);

p = s; //p에 들어있는 데이터 멤버에서 어떤일이 일어날까? 

```
위의 코드는 불가능 <br>
멤버 변수 string&은 참조자인데, 두 객체는 각각 다른 strin 참조형을 가지고 있기 때문에 대입 연산이 불가능 <br>
C++ 참조자는 자신이 참조하고 있는 것과 다른 객체를 참조할 수 없기 때문 <br>
즉, 참조자를 데이터 멤버로 갖고 있는 클래스에 대입 연산 지원하려면 직접 복사 대입 연산를 정의해야 하고, 만약에 컴파일러에 의해 자동으로 생성된 암시적 복사 대입 연산자는 내부에서 상수 멤버를 어떻게 처리할지 모호해져 암시적 생성을 거부함. <br>
또한 데이터 멤버가 상수 객체인 경우에도 상수 멤버를 수정하는 것이 문법에 어긋나기 때문에, 이 또한 암시적 생성을 거부함. <br>
마지막으로, 복사 대입 연산자를 private로 선언한 부모 클래스로부터 파생된 자식 클래스의 경우에도 암시적 복사 대입 연산자를 가질 수 없음<br> 
컴파일러가 거부해버리고, 애초에 자식 클래스는 호출한 권한이 없는 멤버 함수는 암시적 복사 대입 연산자가 어떻게든 호출할 수 없기 때문임 

- 정리
  컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.

-----------------------------------------------------------------

## 2-6 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

2-5에서 컴파일러가 자동으로 만들어낸 함수들을 사용하고 싶지 않을 때에 대해 알아보는 항목 <br> 
컴파일러가 생성 함수는 모두 공개가 되는 public 멤버가 되고, 복사 생성자와 복사 대입 연산자가 자동으로 생성되는 것을 막기 위해 
직접 선언해야 한다는 점은 맞지만, 이를 반드시 public 멤버로 선언해야한다고 한 적은 없음 <br> 
그러니, 복사 생성자와 복사 대입 연산자를 public 멤버가 아닌 private 멤버로 선언하면
1. 클래스 멤버 함수가 명시적으로 선언되기 때문에, 컴파일러는 자신의 기본 버전을 만들 수 없고,
2. private의 접근성을 가지기 때문에, 외부로부터의 호출을 차단하여 복사를 할수 없게 만든다.

하지만 private 멤버 함수도 그 클래스의 멤버 함수 및 friend()함수가 호출 할 수 있는 단점이 존재하는데, 이를 **정의(define)** 를 안하는 방법으로 해결할 수 있음. <br>

```cpp

class HomeForSale{

private:
  HomeForSale(const HomeForSale&); //선언만 존재
  HomeForSale& operator= (const HomeForSale&);

public:
  ....
};

```

외부에서 복사 생성자나 복사 대입 연산자를 호출시키면, 정의되지 않은 함수를 호출하기 때문에 링크 시점에서 에러가 발생 함<br>
(단, 클래스 내부에 friend함수로 호출 가능)

또한, 링크 시점을 에러를 컴파일 시점에러로 옮길 수 도 있다
1. 복사 생성자와 복사 대입 연산자를 private로 선언하되,
2. 이것을 HomeForSale 클래스 자체에 넣지 말고 별도의 기본 클래스에 넣고,
3. 이 클래스로부터 HomeForSale클래스를 파생시키는 것이다.
4. 그리고 그 별도의 클래스는 복사 장지만 맡는 역할을 부여한다.

다음 코드를 보자 

```cpp

class Uncopyable{
protected: //파생된 객체에 대해서
  Uncopyable(); //생성과 소멸을 허용
  ~Uncopyable();

private:
  Uncopyable(const Uncopyable&); //하지만 private로 선언하여 복사를 방지한다/
  Uncopyable& operator=(const Uncopyable&);
};

class HomeForSale : pricate Uncopyable{

// HomeForSale 클래스를 Uncopyable로 부터 상속을 받게하고 그냥 냅둔다.
// 그러면 복사 생성자도, 복사 대입 연산자도 선언되지 않는다.

};

```

이렇게하면, HomeForSale는 Uncopyable로부터 상속을 받았기 때문에, HomeForSale 객체의 복사를 외부(멤버 함수 및 프렌드 함수까지 포함하여)에서 시도하려고 할 때, 통하지 않는다. <br>
즉, 복사 생성자 및 복사 대입 연산자를 선언하지 않는다. <br>
왜냐면 컴파일러가 생성한 복사 함수는 기본 클래스의 대응 버전을 호출하게 되어 있는데, 여기서는 복사 함수들이 부모 클래스에서 공개되어 있지 않기 때문이다. <br>

마지막으로, Uncopyable의 구현과 사용법에 대해 미묘한 부분들을 알아보자.

  - Uncopyable의 구현과 사용법
  1.  Uncopyable로부터 상속은 public일 필요가 없다.
  2.  Uncopyable의 소멸자는 가상 소멸자가 아니여도 된다
  3.  Uncopyable의 클래스는 데이터 멤버가 전혀 없기 때문에, 공백 기본 클래스 최적화 기법(Empty base class Optimization)이 먹힐 수 도 있지만, Uncopyable 클래스는 기본 클래스이기 때문에, 이 기법을 사용한다면 다중 상속으로 갈 가능성이 있다.
  4.  다중 상속 시 공백 기본 클래스 최적화 기법(Empty base class Optimization)이 돌아가지 못할 때도 있다.
  5.  Boost 라이브러리를 보면 Uncopyable과 똑같은 구실을 하는 클래스를 찾을 수 있고, 이것을 써도 된다 → noncopyable class

  - 정리
    컴파일에서 자동으로 제공하는 기능을 허용하지 않을려면, 대응되는 멤버 함수를 private로 선언하고나서 구현은 하지 않은 채로 두면 된다, 아니면 Uncopyable과 비슷한 기본 클래스를 쓰는 방법이 있다. 

-----------------------------------------------------------------

## 2-7 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

C++의 특징 중 하나인 다형성을 통해, 공통 기능을 가진 하나의 클래스를 기본 클래스로 만들어 용도에 따라 적절하게 파생시켜 사용할 수 있는데, 이렇게 파생시킨 객체를 쉽게 사용하기 위해 이 객체에 대한 포인터를 가져오는 팩토리 함수(factory funcion)에 대해 알아보자 

- **팩토리 함수(factory funcion)** <br>

-----------------------------------------------------------------
  + 2-8 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

-----------------------------------------------------------------
+ 2-9 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자
+ -----------------------------------------------------------------
+ 2-10 대입연산자는 *this의 참조자를 반환하게 하자
+ -----------------------------------------------------------------
  + 2-11 operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자
  + -----------------------------------------------------------------
  + 2-12 객체의 모든 부분을 빠짐없이 복사하자
-----------------------------------------------------------------
